---
layout: post
title: "简单工厂模式：提高代码可维护性与扩展性的设计模式"
date: "2023-06-27T01:25:01.733Z"
---
简单工厂模式：提高代码可维护性与扩展性的设计模式

简单工厂模式是一种创建对象的设计模式，其旨在通过一个共同的工厂类来实例化不同的对象。通过使用统一的接口或基类，并根据客户端的需求返回相应的实例，简单工厂模式可以隐藏对象的具体创建细节，使客户端代码更加简洁和可维护。 在简单工厂模式中，工厂类扮演着关键角色。它负责根据传入的参数或条件决定创建哪种类型的对象。客户端只需要通过工厂类调用相应的方法，就能得到所需的对象，而无需关心对象是如何创建和初始化的。 简单工厂模式具有灵活性，当需要新增或修改对象类型时，只需修改工厂类的代码即可，而无需改动客户端代码。这种降低了系统的耦合度，同时也提高了代码的可维护性和扩展性。 然而，简单工厂模式也有一些限制。由于所有的创建逻辑都集中在工厂类中，可能会导致工厂类变得复杂，违背了开放封闭原则。此外，一旦需要创建新的对象类型，就需要修改工厂类的代码，这可能违背了单一职责原则。 总的来说，简单工厂模式是一种简洁而实用的对象创建模式，适用于相对简单的场景。在分离对象创建和使用的同时，提供了一种灵活的方式来管理对象的实例化过程。

哈喽！今天开始，慢慢和大家一起分享我学习和理解设计模式的历程。

### 前言

设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。

让我们从创建型模式开始。先来说说工厂模式！

### 基本介绍

工厂模式是一种创建型的面向对象设计模式，目的将创建对象的具体过程包装起来，从而达到更高的灵活性。`工厂模式的本质就是用工厂方法代替 new 操作创建一种实例化对象的方式`，以提供一种方便地创建有同种类型接口的产品的复杂对象。

简单说来：`我们不new对象了，让工厂方法来生产对象`

工厂模式可以细分如下三类：

简单工厂模式（Simple Factory）

工厂方法模式（Factory Method）

抽象工厂模式（Abstract Factory）

**今天来看下工厂模式之简单工厂模式**

![程序视点](https://developer.qcloudimg.com/http-save/yehe-admin/a7ea5982e434a128cdb6fe120c23110e.png)

### 简单工厂模式

简单工厂模式（Simple Factory）又叫做静态工厂方法（Static Factory Method）模式，但不属于 23 种 GOF 设计模式之一。

简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。

从上面的描述中，我们可以抽象出这么几个角色：

*   工厂类：负责创建需要的实例
*   产品抽象类：工厂类能创建出来的所有产品类的抽象。它负责描述所有实例所共有的公共接口。（这里必须要一个抽象类，不然不能保证返回的不同的产品类属于同一个类型）
*   产品类：工厂类创建出来的目标。它（们）是产品抽象类的具体实现。

### 示例

产品抽象类：

    public interface Phone {
      public String info();
    }
    

产品类（具体实现类）：

    public class HuaweiPhone implements Phone{
      @Override
      public String info() {
        return "我是手机华为";
      }
    }
    

    public class ApplePhone implements Phone{
      @Override
      public String info() {
        return "我是苹果手机";
      }
    }
    

工厂类

    public class PhoneFactory{
      public static Phone createPhone(String name){
        Phone p = null;
        switch(type) {
          case "huawei":
            p = new HuaweiPhone();
            break;
          case "apple":
            p = new ApplePhone();
            break;
          default:
            throw new UnsupportedOperationException("不支持该操作");
        }
        return p;
      }
    }
    

让我们来测试下：

    public class Test {
      public static void main(String[] args) {
        SimpleFactory PhoneFactory = new PhoneFactory();
     
        Phone phone1 = PhoneFactory.createPhone("huawei");
        System.out.println(phone1.info());
        Phone phone2 = PhoneFactory.createPhone("apple");
        System.out.println(phone2.info());
      }
    }
    

输出：

我是华为手机

我是苹果手机

`给什么条件，就创建什么类型的实例`，就这么简单。不愧`简单工厂模式`的名号。

### 简单工厂模式存在的问题

上面的例子中，我们是知道该工厂能创建华为手机和苹果手机。所有我们在测试的时候，也只创建了这两个实例。

**如果现在要创建一个”小米手机“，那这个工厂就没法创建出来了**

小伙伴可能会说，那就在switch...case...中再增加一个case "xiaomi"吧！

嗯嗯，这个办法能解决”小米手机“的创建问题。但如果后面我们还要陆续创建”oppo手机“”三星手机“...

如果延续这种方法，我们每增加一种手机的创建，就要添加一次case，也就要每次都修改 PhoneFactory 类。这显然是违背了【开闭原则】。同时，这样的工厂类太被动了。

那怎么解决这个问题呢？我们下期再分享。

### 简单工厂模式总结

工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。

通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来（不用直接new对象了），仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。

但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。

当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；

一句话：`虽然简单工厂模式实现了对象的创建和对象的使用分离，但增加新的具体产品需要修改工厂类的判断逻辑代码，违背开闭原则`。

为了解决这些缺点，就有了工厂方法模式。

我下回再讲`工厂方法`，今天先到这里了！