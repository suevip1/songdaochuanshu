---
layout: post
title: "Qtæºç é˜…è¯»(äº”)-deleteLater"
date: "2023-07-10T01:23:28.212Z"
---
Qtæºç é˜…è¯»(äº”)-deleteLater
=====================

Qt deleteLaterä½œç”¨åŠæºç åˆ†æ
=====================

> ä¸ªäººç»éªŒæ€»ç»“ï¼Œå¦‚æœ‰é”™è¯¯æˆ–é—æ¼ï¼Œæ¬¢è¿å„ä½å¤§ä½¬æŒ‡æ­£ ğŸ¥³

åœ¨æœ¬ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥åˆ†ææºç ï¼Œæ¢è®¨`deleteLater`çš„åŸç†ã€‚

`deleteLater`æ˜¯Qtæ¡†æ¶æä¾›çš„ä¸€ä¸ªé‡è¦å‡½æ•°ï¼Œç”¨äºåœ¨äº‹ä»¶å¾ªç¯ä¸­å»¶è¿Ÿåˆ é™¤å¯¹è±¡ã€‚

åœ¨è½¯ä»¶å¼€å‘ä¸­ï¼Œå»¶è¿Ÿåˆ é™¤å¯¹è±¡çš„æ¦‚å¿µæ˜¯éå¸¸é‡è¦çš„ï¼Œç‰¹åˆ«æ˜¯å½“å¯¹è±¡ä¸å†è¢«éœ€è¦ï¼Œä½†ç”±äºæŸäº›åŸå› ï¼ˆæ¯”å¦‚å¯¹è±¡æ­£åœ¨è¢«è®¿é—®ã€äº‹ä»¶å¾ªç¯ä¸­ä»æœ‰å…³äºè¯¥å¯¹è±¡çš„äº‹ä»¶ç­‰ï¼‰ï¼Œä¸èƒ½ç«‹å³åˆ é™¤ã€‚`deleteLater`å‡½æ•°æä¾›äº†ä¸€ç§æœºåˆ¶ï¼Œå¯ä»¥å°†å¯¹è±¡çš„åˆ é™¤æ“ä½œå»¶è¿Ÿæ‰§è¡Œï¼Œä»è€Œé¿å…äº†å¯èƒ½çš„æ‚¬ç©ºæŒ‡é’ˆå’Œèµ„æºæ³„æ¼é—®é¢˜ã€‚

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥ç ”ç©¶æºç ï¼Œæ­ç¤º`deleteLater`å‡½æ•°çš„å·¥ä½œåŸç†ã€‚æˆ‘ä»¬å°†åˆ†æ`QCoreApplication`çš„`postEvent`å‡½æ•°ä»¥åŠ`QObject`çš„`event`å‡½æ•°ï¼Œå¹¶è§£é‡Šå®ƒä»¬å¦‚ä½•ååŒå·¥ä½œæ¥å®ç°å»¶è¿Ÿåˆ é™¤çš„æ•ˆæœã€‚

é€šè¿‡æ·±å…¥åˆ†ææºç å¹¶ç†è§£`deleteLater`çš„å†…éƒ¨å·¥ä½œåŸç†ï¼Œæˆ‘ä»¬å°†æ›´å¥½åœ°äº†è§£å®ƒåœ¨Qtæ¡†æ¶ä¸­çš„ä½œç”¨å’Œä¼˜åŠ¿ã€‚

deleteLaterçš„ä½œç”¨
--------------

æ ¹æ®å®˜æ–¹æ–‡æ¡£ä¸­çš„è§£é‡Šï¼š

> Schedules this object for deletion.
> 
> The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g. deleteLater() is called on an object before QCoreApplication::exec()), the object will be deleted once the event loop is started. If deleteLater() is called after the main event loop has stopped, the object will not be deleted. Since Qt 4.8, if deleteLater() is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.
> 
> Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will not perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which deleteLater() was called. This does not apply to objects deleted while a previous, nested event loop was still running: the Qt event loop will delete those objects as soon as the new nested event loop starts.

è®¡åˆ’åˆ é™¤ä¸€ä¸ªå¯¹è±¡ã€‚

**å½“æ§åˆ¶è¿”å›åˆ°äº‹ä»¶å¾ªç¯æ—¶ï¼Œå¯¹è±¡å°†è¢«åˆ é™¤**ã€‚å¦‚æœåœ¨è°ƒç”¨æ­¤å‡½æ•°æ—¶äº‹ä»¶å¾ªç¯æ²¡æœ‰è¿è¡Œ(ä¾‹å¦‚ï¼Œåœ¨QCoreApplication::exec()ä¹‹å‰åœ¨å¯¹è±¡ä¸Šè°ƒç”¨deleteLater())ï¼Œåˆ™ä¸€æ—¦äº‹ä»¶å¾ªç¯å¯åŠ¨ï¼Œè¯¥å¯¹è±¡å°†è¢«åˆ é™¤ã€‚å¦‚æœåœ¨ä¸»äº‹ä»¶å¾ªç¯åœæ­¢åè°ƒç”¨deleteLater()ï¼Œåˆ™ä¸ä¼šåˆ é™¤å¯¹è±¡ã€‚è‡ªQt 4.8ä»¥æ¥ï¼Œå¦‚æœdeleteLater()åœ¨æ²¡æœ‰è¿è¡Œäº‹ä»¶å¾ªç¯çš„çº¿ç¨‹ä¸­çš„å¯¹è±¡ä¸Šè°ƒç”¨ï¼Œåˆ™è¯¥å¯¹è±¡å°†åœ¨çº¿ç¨‹ç»“æŸæ—¶è¢«é”€æ¯ã€‚

æ³¨æ„ï¼Œè¿›å…¥å’Œç¦»å¼€ä¸€ä¸ªæ–°çš„äº‹ä»¶å¾ªç¯(ä¾‹å¦‚ï¼Œé€šè¿‡æ‰“å¼€ä¸€ä¸ªæ¨¡æ€å¯¹è¯æ¡†)ä¸ä¼šæ‰§è¡Œå»¶è¿Ÿåˆ é™¤;å¯¹äºè¦åˆ é™¤çš„å¯¹è±¡ï¼Œå¿…é¡»è¿”å›åˆ°ä»ä¸­è°ƒç”¨deleteLater()çš„äº‹ä»¶å¾ªç¯ã€‚è¿™ä¸é€‚ç”¨äºåœ¨ä»¥å‰çš„åµŒå¥—äº‹ä»¶å¾ªç¯ä»åœ¨è¿è¡Œæ—¶åˆ é™¤çš„å¯¹è±¡:Qtäº‹ä»¶å¾ªç¯å°†åœ¨æ–°çš„åµŒå¥—äº‹ä»¶å¾ªç¯å¼€å§‹æ—¶åˆ é™¤è¿™äº›å¯¹è±¡ã€‚

ğŸ™‹â€â™‚ï¸é‚£ä¸ºä»€ä¹ˆéœ€è¦æŠŠè¿™æ ·ä¸€ä¸ªåˆ é™¤åŠ¨ä½œä¸¢åˆ°äº‹ä»¶å¾ªç¯å»å‘¢ï¼Ÿ

å› ä¸ºä¹Ÿè®¸åœ¨æ‰§è¡Œåˆ é™¤æŸä¸ªQObjectå¯¹è±¡çš„æ“ä½œæ—¶ï¼Œäº‹ä»¶é˜Ÿåˆ—ä¸­ä»ç„¶æœ‰å…³äºè¿™ä¸ªQObjectå¯¹è±¡çš„äº‹ä»¶ï¼Œå¦‚æœç›´æ¥åˆ é™¤è¯¥å¯¹è±¡ï¼Œå°±ä¼šå¯¼è‡´åé¢è°ƒç”¨è¿™ä¸ªå¯¹è±¡æ—¶ï¼Œå¼•èµ·ç¨‹åºçš„å´©æºƒã€‚ä¹Ÿå°±æ˜¯è§£å†³æ‚¬ç©ºæŒ‡é’ˆçš„é—®é¢˜ã€‚

æºç åˆ†æ
----

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆçœ‹`deleteLater`åšäº†äº›ä»€ä¹ˆæ“ä½œï¼š

    void QObject::deleteLater()
    {
        QCoreApplication::postEvent(this, new QDeferredDeleteEvent());
    }
    

å¯ä»¥çœ‹åˆ°ï¼Œ`deleteLater`å‡½æ•°ä¸­ï¼Œä»…ä»…åªæ˜¯å¾€äº‹ä»¶é˜Ÿåˆ—ä¸­æ·»åŠ äº†ä¸€ä¸ª`DeferedDelete`äº‹ä»¶ã€‚

å…¶æ¬¡ï¼Œæˆ‘ä»¬å†çœ‹QObjectçš„äº‹ä»¶å¤„ç†å‡½æ•°â€”â€”`event`

    bool QObject::event(QEvent *e)
    {
        switch (e->type()) {
     	// ...
    
        case QEvent::DeferredDelete:
            qDeleteInEventHandler(this);
            break;
                
    	// ...
    }
    

    void qDeleteInEventHandler(QObject *o)
    {
        delete o;
    }
    

ä»ä¸Šé¢ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œ`deleteLater`å‘å‡ºæ¥çš„äº‹ä»¶ï¼Œæœ€åå¤„ç†çš„æ—¶å€™ï¼Œå°±æ˜¯ç®€ç®€å•å•çš„è°ƒç”¨deleteè¿›è¡Œææ„ã€‚ä¹Ÿå°±èƒ½å°è¯deleteLaterçš„ä½œç”¨ï¼š

> è®¡åˆ’åˆ é™¤ä¸€ä¸ªå¯¹è±¡ã€‚**å½“æ§åˆ¶è¿”å›åˆ°äº‹ä»¶å¾ªç¯æ—¶ï¼Œå¯¹è±¡å°†è¢«åˆ é™¤**ã€‚

ä½†ä½œä¸ºä¸€ä½æŠ€æœ¯äººï¼Œçœ‹åˆ°å®˜æ–¹æ–‡æ¡£ä¸­ï¼Œå¯¹è¿™ä¸ªå‡½æ•°æœ‰ä¸€æ®µè¿™ä¹ˆé•¿çš„æè¿°ï¼Œæ€»è§‰å¾—äº‹æƒ…æ˜¯ä¸æ˜¯æœ‰ç‚¹å¤ªç®€å•äº†ï¼Œéš¾é“æ˜¯æˆ‘æ‰“å¼€çš„æ–¹å¼ä¸å¯¹ï¼ŸæŠ±ç€è¿™ä¸ªæƒ³æ³•ï¼Œæˆ‘åˆçœ‹äº†ä¸€éæºç ï¼Œä¹Ÿç®—æ˜¯æ‰¾åˆ°äº†ä¸€äº›å¦å¤–çš„å¤„ç†ã€‚

å†æ¢æºç 
----

è¿™æ¬¡ï¼Œæˆ‘ä»`deleteLater`ä¸­å‘é€äº‹ä»¶(`postEvent`)ä¸‹æ‰‹ï¼Œçœ‹æ˜¯ä¸æ˜¯è¿™ä¸ªé‡Œé¢æœ‰ç€ç‰¹æ®Šå¤„ç†ï¼š

    void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority)
    {
        // ...
    
        if (event->type() == QEvent::DeferredDelete && data == QThreadData::current()) {
            // remember the current running eventloop for DeferredDelete
            // events posted in the receiver's thread.
    
            // Events sent by non-Qt event handlers (such as glib) may not
            // have the scopeLevel set correctly. The scope level makes sure that
            // code like this:
            //     foo->deleteLater();
            //     qApp->processEvents(); // without passing QEvent::DeferredDelete
            // will not cause "foo" to be deleted before returning to the event loop.
    
            // If the scope level is 0 while loopLevel != 0, we are called from a
            // non-conformant code path, and our best guess is that the scope level
            // should be 1. (Loop level 0 is special: it means that no event loops
            // are running.)
            int loopLevel = data->loopLevel;
            int scopeLevel = data->scopeLevel;
            if (scopeLevel == 0 && loopLevel != 0)
                scopeLevel = 1;
            static_cast<QDeferredDeleteEvent *>(event)->level = loopLevel + scopeLevel;
        }
        // ...
    }
    

åœ¨è¿™é‡Œé¢ï¼ŒæŠŠè¿™ä¸ª`DeferedDelete`äº‹ä»¶ä¸­çš„å¾ªç¯çº§åˆ«è®¾ç½®äº†ä¸€ä¸‹ï¼Œä»¥ä¾¿å¾…ä¼šè¿›è¡Œäº‹ä»¶å‘é€çš„æ—¶å€™ï¼Œèƒ½å¤Ÿè¿›è¡Œå½“å‰äº‹ä»¶æ˜¯å¦è¦å¤„ç†çš„åˆ¤æ–­ã€‚

    void QCoreApplicationPrivate::sendPostedEvents(QObject *receiver, int event_type,
                                                   QThreadData *data)
    {
            // ...
    
            if (pe.event->type() == QEvent::DeferredDelete) {
                // DeferredDelete events are sent either
                // 1) when the event loop that posted the event has returned; or
                // 2) if explicitly requested (with QEvent::DeferredDelete) for
                //    events posted by the current event loop; or
                // 3) if the event was posted before the outermost event loop.
    
                int eventLevel = static_cast<QDeferredDeleteEvent *>(pe.event)->loopLevel();
                int loopLevel = data->loopLevel + data->scopeLevel;
                const bool allowDeferredDelete =
                    (eventLevel > loopLevel
                     || (!eventLevel && loopLevel > 0)
                     || (event_type == QEvent::DeferredDelete
                         && eventLevel == loopLevel));
                if (!allowDeferredDelete) {
                    // cannot send deferred delete
                    if (!event_type && !receiver) {
                        // we must copy it first; we want to re-post the event
                        // with the event pointer intact, but we can't delay
                        // nulling the event ptr until after re-posting, as
                        // addEvent may invalidate pe.
                        QPostEvent pe_copy = pe;
    
                        // null out the event so if sendPostedEvents recurses, it
                        // will ignore this one, as it's been re-posted.
                        const_cast<QPostEvent &>(pe).event = nullptr;
    
                        // re-post the copied event so it isn't lost
                        data->postEventList.addEvent(pe_copy);
                    }
                    continue;
                }
            }
    
            // ...
    }
    

ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åˆ¤æ–­å½“å‰æ˜¯å¦å…è®¸å¤„ç†`DeferredDelete`äº‹ä»¶æ—¶ï¼Œæœ‰ä¸‰ä¸ªæ¡ä»¶ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢æ³¨é‡Šæ‰€è¯´çš„ï¼š

1.  å½“å‘å¸ƒäº‹ä»¶çš„äº‹ä»¶å¾ªç¯è¿”å›æ—¶
2.  äº‹ä»¶åœ¨æœ€å¤–å±‚çš„äº‹ä»¶å¾ªç¯ä¹‹å‰è°ƒç”¨
3.  æ˜¾ç¤ºçš„è°ƒç”¨QEvent::DeferredDeleteäº‹ä»¶

    const bool allowDeferredDelete =
                    (eventLevel > loopLevel
                     || (!eventLevel && loopLevel > 0)
                     || (event_type == QEvent::DeferredDelete
                         && eventLevel == loopLevel));
    

å¦‚æœ`DeferredDelete`ä¸èƒ½åœ¨å½“å‰çš„å¾ªç¯ä¸­è¢«å¤„ç†ï¼Œé‚£ä¹ˆå°†äº‹ä»¶é‡æ–°å°è£…ï¼Œé‡æ–°æ·»åŠ åˆ°çº¿ç¨‹çš„äº‹ä»¶åˆ—è¡¨ä¸­ï¼Œç­‰å¾…èƒ½å¤Ÿå¤„ç†è¯¥äº‹ä»¶çš„äº‹ä»¶å¾ªç¯å»å¤„ç†ã€‚

ä½¿ç”¨æç¤º
----

é€šè¿‡ä¸Šé¢çš„åˆ†æï¼Œè°ƒç”¨`deleteLater`ä¼šå»¶è¿Ÿåˆ é™¤ä¸€ä¸ªQObjectå¯¹è±¡ï¼Œå¹¶æœ€ç»ˆå¦¥å–„çš„åˆ é™¤ã€‚ä½†æ˜¯ï¼Œåœ¨æˆ‘ä»¬ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œä»ç„¶æ˜¯è¦æ³¨æ„ï¼Œå°†åŸæŒ‡é’ˆç½®`nullptr`çš„ï¼Œä¸ç„¶å°±ä¼šå¯¼è‡´é‡æŒ‡é’ˆäº†ã€‚

é‚£ä¹ˆï¼Œ**æˆ‘ä»¬åº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™å»è¿›è¡Œç½®ç©ºå¤„ç†å‘¢**ï¼Ÿ

Qtå®˜æ–¹æ–‡æ¡£ä¸­æœ‰åšè§£é‡Šï¼š

> \[signal\] void QObject::destroyed(QObject \*obj = nullptr)
> 
> This signal is emitted immediately before the object obj is destroyed, after any instances of QPointer have been notified, and cannot be blocked.  
> All the objects's children are destroyed immediately after this signal is emitted

åœ¨ä¸€ä¸ªQObjectå¯¹è±¡ææ„æ—¶ï¼Œä¼šå‘å°„ä¸€ä¸ªä¿¡å·â€”â€”`destroyed`ã€‚ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š

    QObject* obj = new QObject();
    
    connect(obj, &QObject::destroyed, [&] () { obj = nullptr; });
    
    obj->deleteLater();
    
    

æ€»ç»“
--

1.  **deleteLaterä¸ºQtæä¾›äº†ä¸€ä¸ªæ–¹ä¾¿ä¸”å®‰å…¨çš„æ–¹å¼æ¥å»¶è¿Ÿåˆ é™¤å¯¹è±¡ï¼Œé¿å…äº†æ‚¬æŒ‚æŒ‡é’ˆå’Œèµ„æºæ³„æ¼çš„é—®é¢˜ã€‚å®ƒæä¾›äº†ä¸€ç§ç®€åŒ–ä»£ç çš„æœºåˆ¶ï¼Œåœ¨ç‰¹å®šæƒ…å†µä¸‹éå¸¸æœ‰ç”¨ã€‚**
2.  **ç›¸è¾ƒäºæ‰‹åŠ¨åˆ é™¤å’Œç›´æ¥è°ƒç”¨deleteï¼ŒdeleteLaterä¸ºå»¶è¿Ÿåˆ é™¤å¯¹è±¡æä¾›äº†ä¸€ç§æ›´åŠ ç®€ä»‹å’Œå®‰å…¨çš„æ–¹å¼ã€‚æ‰‹åŠ¨åˆ é™¤éœ€è¦å¼€å‘äººå‘˜è‡ªå·±ç®¡ç†å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œè€ŒdeleteLateråˆ™é€šè¿‡å°†åˆ é™¤è¯·æ±‚åŠ å…¥åˆ°äº‹ä»¶é˜Ÿåˆ—ï¼Œå®ç°äº†è‡ªåŠ¨åŒ–çš„å»¶è¿Ÿåˆ é™¤ã€‚**
3.  **deleteLateré€‚ç”¨äºéœ€è¦å»¶è¿Ÿåˆ é™¤å¯¹è±¡çš„åœºæ™¯ï¼Œç‰¹åˆ«æ˜¯åœ¨æ§½å‡½æ•°ä¸­éœ€è¦åˆ é™¤ä¸ä¿¡å·å…³è”çš„å¯¹è±¡æ—¶ã€‚**

> ğŸ’• åˆ›ä½œä¸æ˜“ï¼Œå¦‚æœæœ¬ç¯‡åšå®¢å¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œéº»çƒ¦ç‚¹èµã€æ”¶è—ã€å…³æ³¨æ”¯æŒä¸€ä¸‹ğŸ˜‰