---
layout: post
title: "有关 python 切片的趣事"
date: "2023-06-10T01:13:09.290Z"
---
有关 python 切片的趣事
===============

哈喽大家好，我是咸鱼

今天来讲一个我在实现 python 列表切片时遇到的趣事

在正式开始之前，我们先来了解一下**切片（slice）**

切片操作是访问序列（列表、字符串......）中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列

语法如下

    name[start : end : step]
    

*   start 是切片的起始索引值，当 start 是序列首位时可以省略
*   end 是切片结束索引值，当 end 是序列末位时可以省略
*   step 为步长，可以不提供，默认是1，不能为0，为负数时表示列表翻转

需要注意的是，切片操作遵循**包头不包尾**的原则，即**从序列的第 start 位索引起，向右取到后 end-1 位元素为止，按 m 间隔过滤**

下面举一些关于切片的例子

    # 获取列表的前 n 个元素：
    lst = [1, 2, 3, 4, 5, 6]
    n = 3
    result = lst[:n]
    print(result)  # [1, 2, 3]
    
    # 获取列表的后 n 个元素：
    lst = [1, 2, 3, 4, 5, 6]
    n = 3
    result = lst[-n:]
    print(result)  # [4, 5, 6]
    
    # 获取列表中的偶数元素：
    lst = [1, 2, 3, 4, 5, 6]
    result = lst[1::2]
    print(result)  # [2, 4, 6]
    
    # 获取列表中的奇数元素：
    lst = [1, 2, 3, 4, 5, 6]
    result = lst[::2]
    print(result)  # [1, 3, 5]
    
    # 获取列表中的倒数第二个元素：
    lst = [1, 2, 3, 4, 5, 6]
    result = lst[-2:-1]
    print(result)  # [5]
    
    # 获取列表中的最后两个元素：
    lst = [1, 2, 3, 4, 5, 6]
    result = lst[-2:]
    print(result)  # [5, 6]
    

根据 GPT 的回答，Fortran 是最早支持切片语法的语言，历史上曾经有多种语言支持切片操作  
![image](https://img2023.cnblogs.com/blog/2958925/202306/2958925-20230610090937405-909192543.png)  
上面这些语言虽然说都支持切片语法，但我觉得不够 python 那样的灵活简洁

1.  简洁而直观的语法：

Python 的切片语法非常简洁和直观，使用起来非常方便。通过使用冒号（:）来指定起始位置、结束位置和步长，可以轻松地进行切片操作。

2.  强大的切片功能：

Python 的切片语法不仅支持基本的切片操作，还可以使用负数索引和省略号（...）来处理更复杂的情况。这使得对列表、字符串、元组等序列类型的数据进行灵活的切片成为可能

再介绍完了切片之后，我们来进入正题，那天咸鱼在写一个关于列表切片操作的文档

现象
--

我们知道：**根据单个索引进行取值时，如果索引越界，就会报错**

    list1 = [1,2,3]
    print(list1[5])
    
    """
    报错信息如下:
    Traceback (most recent call last):
      File "E:\PycharmProjects\projects\demo\草稿纸.py", line 2, in <module>
        print(list1[5])
    IndexError: list index out of range
    """
    

但是当咸鱼不小心**将切片结束索引值设置成了超过了列表长度的值的时候**，发现居然没有报错

    list1 = [1,2,3]
    print(list1[1:5]) # 结果[2, 3]
    

是不是很有趣，**Python 中的切片操作不会引发索引越界的错误**

关于这个现象，官方文档里面是有介绍的

> The slice of _s_ from _i_ to _j_ is defined as the sequence of items with index _k_ such that `i <= k < j`. If _i_ or _j_ is greater than `len(s)`, use `len(s)`.
> 
> If _i_ is omitted or `None`, use `0`. If _j_ is omitted or `None`, use `len(s)`. If _i_ is greater than or equal to _j_, the slice is empty.

也就是说，对于序列 s ：

*   当初始索引值或者结束索引值大于序列长度时，就用长度值（`len(s)`）作为索引值
*   当初始索引值没写或者是 None 时，用 0 作为初始索引值
*   当结束索引值没写或者是 None 时，用序列长度值（`len(s)`）作为初始索引值
*   当初始索引值大于等于结束索引值时，结果为空对象

    my_list = [1, 2, 3, 4, 5]
    
    # 有效的切片范围
    print(my_list[1:4])  # 输出: [2, 3, 4]
    
    # 超出索引范围的切片，会自动调整为有效的索引
    print(my_list[1:10])  # 输出: [2, 3, 4, 5]
    
    # 负数索引也适用
    print(my_list[-3:10])  # 输出: [3, 4, 5]
    

**总结**
------

Python 的切片语法设计得很安全，即使指定的切片索引超出了序列的长度，也不会引发索引越界错误。相反，它会自动调整切片范围，只返回有效的结果

当进行切片操作时，**Python会根据切片的参数和可用的索引范围来确定切片的实际范围**

虽然不知道龟哥为什么设计 Python 的切片语法要允许索引超出边界，而不是设计成抛出索引错误？

但是可以知道的是，这种设计使得切片操作更加灵活和方便，无需手动检查索引范围或引发索引越界异常

它允许我们在切片操作中不必担心边界情况，并且可以更加简洁地处理列表、字符串和其他序列类型的操作