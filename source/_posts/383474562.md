---
layout: post
title: "【23种设计模式】设计模式综述（开篇）"
date: "2023-08-27T00:59:09.277Z"
---
【23种设计模式】设计模式综述（开篇）
===================

一、设计模式概述：
---------

​ **设计模式（Design pattern）**代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

​ 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

二、面向对象的23中设计模式：
---------------

**说明：**这23种设计模式分为三大类，创建型模式、结构型模式和行为型模式。  
![image](https://img2023.cnblogs.com/blog/1913282/202308/1913282-20230826173240295-1382184228.png)

### 创建型模式【5种】：

**关注对象的创建。**

创建型模式就是用来解决对象实例化和使用的客户端耦合的模式，可以让客户端和对象实例化都独立变化，做到相互不影响。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/rP6L4ianADQFAvVadyr29taemd5DsXng3er592LWSHibeUg1zIT1xXXBKHkOnjSmM55EWujvlficntmP8ibYjRPGLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 结构型模式【7种】：

**关注类与对象之间的组合。**

结构型模式主要研究的是类和对象的组合的问题。它包括两种类型，一是类结构型模式：指的是采用继承机制来组合实现功能；二是对象结构型模式：指的是通过组合对象的方式来实现新的功能。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/rP6L4ianADQFAvVadyr29taemd5DsXng3UkI5UkzQKZolMlaiaPQyUJwVYtOssQYDkEFRFIRBg5hkusv9u3iaWtag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 行为型模式【11种】：

**关注对象和行为的分离**

行为型模式主要讨论的是在不同对象之间划分责任和算法的抽象化的问题。行为型模式又分为类的行为模式和对象的行为模式两种。

*   类的行为模式——使用继承关系在几个类之间分配行为。
*   对象的行为模式——使用对象聚合的方式来分配行为。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/rP6L4ianADQFAvVadyr29taemd5DsXng3RJpMrbicNDRjUffiasgxOVGGX7ZxsKNUgHnw10E9PyIpIGpJq9HM6RVg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

三、设计模式六大原则详细解析：
---------------

![image](https://img2023.cnblogs.com/blog/1913282/202308/1913282-20230826173304096-403573402.png)

### 单一职责原则【SRP】:

（1）**SRP(Single ResponsibilitiesPrinciple)**的定义：就一个类而言，应该仅有一个引起它变化的原因。简而言之，就是功能要单一。

（2）如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

（3）软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。

**小结：**单一职责原则（**SRP**）可以看做是低耦合、高内聚在面向对象原则上的引申， 将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，引起它变化的原因就越多，这样就会导致职责依赖，大大损伤其内聚性和耦合度。

### 开闭原则【OCP】:

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

（1）**OCP(Open-ClosePrinciple)**的定义：就是说软件实体(类，方法等等)应该可以扩展（扩展可以理解为增加），但是不能在原来的方法或者类上修改，也可以这样说，对增加代码开放，对修改代码关闭。

（2）**OCP**的两个特征：对于扩展（增加）是开放的，因为它不影响原来的，这是新增加的。对于修改是封闭的，如果总是修改，逻辑会越来越复杂。

**小结：**开放封闭原则（**OCP**）是面向对象设计的核心思想。遵循这个原则可以为我们面向对象的设计带来巨大的好处：可维护（维护成本小，做管理简单，影响最小）、可扩展（有新需求，增加就好）、可复用（不耦合，可以使用以前代码）、灵活性好（维护方便、简单）。开发人员应该仅对程序中出现频繁变化的那些部分做出抽象，但是不能过激，对应用程序中的每个部分都刻意地进行抽象同样也不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

### 里氏代换原则【LSP】:

里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。**LSP** 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

（1）**LSP(Liskov SubstitutionPrinciple)**的定义：子类型必须能够替换掉它们的父类型。更直白的说，LSP是实现面向接口编程的基础。

**小结：**任何基类可以出现的地方，子类一定可以出现，所以我们可以实现面向接口编程。LSP是继承复用的基石，只有当子类可以替换掉基类，软件的功能不受到影响时，基类才能真正被复用，而子类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

### 依赖转换原则【DIP】:

依赖转换原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

（1）**DIP(Dependence InversionPrinciple)**的定义：抽象不应该依赖细节，细节应该依赖于抽象。简单说就是，我们要针对接口编程，而不要针对实现编程。

（2）高层模块不应该依赖低层模块，两个都应该依赖抽象，因为抽象是稳定的。抽象不应该依赖具体和细节，具体和细节应该依赖抽象。

**小结：**依赖倒置原则其实可以说是面向对象设计的标志，如果在我们编码的时候考虑的是面向接口编程，而不是简单的功能实现，体现了抽象的稳定性，只有这样才符合面向对象的设计。

### 接口隔离原则【ISP】:

接口隔离原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

（1）接口隔离原则（**Interface Segregation Principle**）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。

（2）使用多个专门的接口比使用单一的总接口要好。

（3）一个类对另外一个类的依赖性应当是建立在最小的接口上的。

（4）一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。

（5）“不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。

**小结：**接口隔离原则（**ISP**）告诉我们，在做接口设计的时候，要尽量设计的接口功能单一，功能单一，使它变化的因素就少，这样就更稳定，其实这体现了高内聚，低耦合的原则，这样做也避免接口的污染。

### 迪米特法则【DP】:

迪米特法则，又称最少知道原则**（Demeter Principle）**。最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

**小结：**组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏替换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。

本文来自博客园，作者：[码农阿亮](https://www.cnblogs.com/wml-it/)，转载请注明原文链接：[https://www.cnblogs.com/wml-it/p/17659171.html](https://www.cnblogs.com/wml-it/p/17659171.html)

* * *

**技术的发展日新月异，随着时间推移，无法保证本博客所有内容的正确性。如有误导，请大家见谅，欢迎评论区指正！**  
**开源库地址,欢迎点亮:**  
[**GitHub：**](https://github.com/ITMingliang)https://github.com/ITMingliang  
[**Gitee：**](https://gitee.com/mingliang_it)   https://gitee.com/mingliang\_it  
[**GitLab：**](https://gitlab.com/ITMingliang) https://gitlab.com/ITMingliang  

* * *

**建群声明：** **本着技术在于分享，方便大家交流学习的初心，特此建立【编程内功修炼交流群】，为大家答疑解惑。热烈欢迎各位爱交流学习的程序员进群，也希望进群的大佬能不吝分享自己遇到的技术问题和学习心得！进群方式：扫码关注公众号，后台回复【进群】。**  
  
![](https://images.cnblogs.com/cnblogs_com/wml-it/2196906/o_230823011905_wxgzhss.png)

* * *