---
layout: post
title: "【笔者感悟】笔者的工作感悟【二】"
date: "2023-07-11T01:16:55.036Z"
---
【笔者感悟】笔者的工作感悟【二】
================

博客推行版本更新，成果积累制度，已经写过的博客还会再次更新，不断地琢磨，高质量高数量都是要追求的，工匠精神是学习必不可少的精神。因此，大家有何建议欢迎在评论区踊跃发言，你们的支持是我最大的动力，你们敢投，我就敢肝

写在前面
====

在上一篇笔者的工作感悟【一】笔者讲到了一些个人经历，帮助大家从思维上学生转换到社会人士，在思维成功转换以后，接下来我们就要学会干活，除了一些比较恶劣的职场环境，大部分职场都是把活干好了才能拿到报酬，因此这里笔者想给大家分享一些拙见，帮助大家能够把活干好

问题解答
====

问题一：要不要刷算法题？
------------

这个问题相信是很多同学都一定会问的，甚至很多同学会说，我看到有些同学即便不刷算法题，也能拿到高薪的工作，那么我是不是不刷算法题我也能在职场中混得还行？

笔者的回答是必须刷，笔者在这里不想从比较功利的角度讨论，大厂面试算法占了多少比重，我们回归到工作的本质来说。

想必大家都知道，计算机是一个傻瓜，没有独立思考能力，我们说前进他不会后退，我们说往东他不会往西，那不知道大家有没有想过，我们作为开发，我们在拿什么指挥它工作，

另外想必也会有感触，我们把自己写好的代码讲给一个门外汉听的时候，我们会发现，即便我们不和他们讲任何专业知识，他们也一样听不懂我们在说什么

事实上，这看似毫无关联的两件事，其实正好是人和计算机交互的正反两面

前一个是人走向计算机，我们要把我们的想法传输给计算机，让它工作

后一个是计算机走向人，我们要把计算机的工作内容还原成人能理解的想法

而连接这两个主体的是什么，**就是算法**

我们来回顾一下算法的基本概念

算法是一系列解决问题或执行任务的步骤，它描述了在给定输入后，通过一系列有限步骤来产生所需输出的过程。算法在计算机科学和数学中被广泛应用。

算法的特点如下：

1.  明确定义：算法必须具有明确的输入和输出，以及一系列明确定义的操作步骤。
    
2.  可执行性：算法必须是可执行的，即可以实际运行并产生结果。
    
3.  有限性：算法必须在有限的时间内运行结束。
    
4.  输入：算法可以接受一个或多个输入。
    
5.  输出：算法可以产生一个或多个输出。
    
6.  确定性：每个步骤都必须具有唯一确定的含义，不会产生二义性。
    
7.  结构化：算法可以由基本操作和控制结构（如顺序结构、分支结构和循环结构）组成，形成一个结构化的整体。
    
8.  有效性：算法应该有效利用计算机资源，如时间和空间。
    
9.  可读性：算法应该易于理解和阅读。
    

通过设计高效和优化的算法，可以提高问题的解决效率，减少计算资源的使用，满足实际应用的需求。

同学们再回想一下平时做算法题的时候，是不是三个阶段

1.  先理解自然语言的问题描述
2.  转换成有限计算机工作步骤
3.  最后根据你写的步骤来写编程语言

我给大家举一个例子：经典背包问题

**问题描述**

给定一组具有重量和价值的物品，和一个限制总重量的背包。要求在不超过背包总重量的前提下，选择一些物品放入背包，使得放入背包的物品总价值最大化。

**算法步骤**

1.  定义一个二维数组dp，其中dp\[i\]\[j\]表示在背包容量为j的情况下，前i个物品的最大价值。
2.  初始化dp数组的第一行和第一列为0，表示没有物品或者背包容量为0的情况下，最大价值都为0。
3.  对于每个物品i，遍历所有背包容量j，如果物品i的重量小于等于背包容量j，则可以选择将物品i放入背包，此时背包容量变为j-w\[i\]，最大价值变为dp\[i-1\]\[j-w\[i\]\]+v\[i\]，即考虑前i-1个物品，在背包容量为j-w\[i\]的情况下的最大价值加上物品i的价值。
4.  如果物品i的重量大于背包容量j，无法将物品i放入背包，最大价值保持为dp\[i-1\]\[j\]。
5.  比较将物品i放入背包与不放入背包两种情况下的最大价值，取较大值作为dp\[i\]\[j\]的值。
6.  遍历完所有物品和背包容量后，dp数组右下角的值即为问题的解，即在限制背包容量的情况下，可以放入背包的物品总价值最大化。

**代码实现**

    public class KnapsackProblem {
    
        public static int knapsack(int[] weights, int[] values, int capacity) {
            int n = weights.length;
            int[][] dp = new int[n+1][capacity+1];
    
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= capacity; j++) {
                    if (weights[i-1] <= j) {
                        dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1]);
                    } else {
                        dp[i][j] = dp[i-1][j];
                    }
                }
            }
    
            return dp[n][capacity];
        }
    
        public static void main(String[] args) {
            int[] weights = {1, 2, 3};
            int[] values = {6, 10, 12};
            int capacity = 5;
    
            int max = knapsack(weights, values, capacity);
            System.out.println("Maximum value that can be obtained: " + max);
        }
    }

大家是不是发现，我们所做的一切，都是算法在起着作用

**结论：算法之所以被称为内功心法，指的是一个人能在计算机思维和自然人思维中熟练地来回切换，因此算法很重要**

问题二：现在学什么语言比较合适？
----------------

之所以大家现在整天想着学什么好就业，是人心浮躁的后果，这个时代大家都喜欢挣快钱，但是笔者提醒大家，来得快的东西往往去的也快，很多中了头奖的家庭，往往最后的结局并不会多圆满

笔者认为，除非你现在学的是就业面特别狭窄的技术或者特别老旧的技术，例如VB语言，Pascal语言啥的，笔者现在见到的确实是不多

一般情况下没有必要换，你有几十张一块钱，也抵不过别人一张一百块

那么有同学会问，万一我学的技术若干年后过时了怎么办，笔者认为也不用担心

学到深处很多东西是相通的，像C++，Java都是面向对象编程，要过渡过去是不需要完全从头开始的

**结论：除非现在学的就业面特别窄或者过时了，否则没有必要特地去换或者追求新技术**

**问题三：工作中老是curd怎么办？**
---------------------

说实话，笔者自己也才工作了一年，加上笔者技术一般，也没有分到啥特别高端技术的项目，那么笔者的建议是什么，就是尝试着从程序员走向软件工程师，笔者之前在博客中强调，要有工程化思维，很多同学软件工程这门课可能背的很熟，也是少有的能够在笔试中轻松通过的考试，毕竟没有敲代码

但是同学们扪心自问一下，在工作中真正用到这门课知识的部分有多少，同学有没有尝试过用工程化的思维来工作，例如你参与一个项目只是拿到需求就开始敲，还是纵观整个项目做一份开发报告，做测试有没有自己写过测试报告，后续和其他岗位的交接有没有记录

**笔者最深刻的印象就是我那些同事开项目会议的时候，都是进了会议室打开execl或者word临时写一个会议记录，而不是带着进度报告来讨论哪里有问题，那怎么可能做得出名堂来，典型的头痛医头，脚痛医脚**

工作中用不到软件工程，那怎么能叫软件工程师呢

程序员和软件工程师在职责和工作范围上存在一些区别。以下是它们的区别：

1.  职责：
    
    *   程序员主要负责编写代码，实现软件开发过程中的具体功能和逻辑。
    *   软件工程师则更加关注整个软件项目的生命周期，包括需求分析、设计、开发、测试、维护等。
2.  角色：
    
    *   程序员通常是一个团队中的一个成员，负责根据规范和设计方案编写代码。
    *   软件工程师通常扮演着项目或团队的领导者或决策者的角色，负责项目管理、技术选型、架构设计等。
3.  技能要求：
    
    *   程序员主要需要具备编码的技能和经验，例如掌握各种编程语言和工具。
    *   软件工程师相对于程序员，除了需要掌握编码技能外，还需要具备系统设计、需求分析、架构设计、项目管理等更高级的技能。
4.  工作范围：
    
    *   程序员的工作范围主要集中在具体的编码实现和单个功能或模块的开发上。
    *   软件工程师的工作范围更广，他们需要关注整个软件项目的生命周期，并协调团队成员之间的合作。

很多同学沉溺于技术，当然不是说技术不重要，技术很重要，笔者也同样喜欢研究技术，但是编程往往在这个工程中只占一小部分，要当工程师还有很长一段路要走呢，整天CURD那只能证明终究还是程序员，那么可替代性当然就很强，可不就得35岁就请你走人换精力更旺盛的应届生嘛

**结论：尝试着用工程化的思维工作**

**问题四：有没有什么好的学习方法？**
--------------------

笔者也经常在网上看到某某几步法，有些还吹得特别玄幻，背后经过美国XX专家研究，帮助多少人从一事无成到XX大咖，这些东西笔者以前参加工作前都尝试过，基本没啥用

这还是我之前提到的人心浮躁的问题，比较明显的是很多同学沉迷于挣快钱，有些同学看似没有想着挣快钱，希望通过自己的努力来获取成果，这比前一种同学在思维上前进了一步，但是很多同学其实并没有真正下功夫去啃书本，钻研项目，很多同学学习盲目求快，幻想着一夜之间从学渣变成学霸，结果给自己制造焦虑，然后必然会去寻找怎么样学习快，怎么样学习高效，事实上在笔者看来，从你搜索开始，你就已经注定不可能学好了，因为你心乱了，这还是人心浮躁，只不过是一种比较隐蔽的人心浮躁罢了

学习本质事实上是个很单纯的东西，把某样东西反复重复，从不认识到认识，从认识到理解，理解到记住，记住到本能，如此而已。

所谓的高效办法，那也只是基于你自己领悟以后总结出来的所谓的方法，不能一棒子打死所谓的学习方法都没有用，但是你情绪浮躁，学也只是形似神不似，那只会邯郸学步，让你原本会的东西都忘了

如果硬要笔者介绍学习方法，那么笔者给大家推荐一个

例如我现在要学习：例如我现在要学习谭浩强的C语言程序设计，很多同学可能学习的时候力求把书上的东西还原出来，但事实上你要真有这本事有限的时间内一字不落地把书上的内容记下来，你现在就能当我的老师了，同学们要记住，书是人写的，书上的所有知识体系都是基于写书人的语言体系，但是人和人是不一样的，有时候两个人的生理结构命中注定相克，他的语言体系并不适合于你，那么你想学号这本书该怎么办呢，用你自己的语言把书上的内容还原出来，这也是笔者之前在学习感悟里强调过的要建立自己的知识体系

这个时候就回到了那句老掉牙的话，适合自己的才是最好的

**结论：大道至简，追求那些花拳绣腿往往会变得不堪一击，要更注重实在**

**附注**
======

那么今天呢就先和大家聊到这里，笔者由于只工作了一年，加上笔者前半年由于经历了数年的动荡，渴望安定，基本上都处于一个半摆烂的状态，所以能给大家分享的工作经验也有限，笔者接下来会更加努力的工作，给大家带来更多的经验分享，希望同学们工作顺利，早日升职加薪、当上总经理、出任CEO、迎娶白富美、走上人生巅峰，想想是不是还有点小激动呢

在黑夜里梦想着光，心中覆盖悲伤，在悲伤里忍受孤独，空守一丝温暖。 我的泪水是无底深海，对你的爱已无言，相信无尽的力量，那是真爱永在。 我的信仰是无底深海，澎湃着心中火焰，燃烧无尽的力量，那是忠诚永在。