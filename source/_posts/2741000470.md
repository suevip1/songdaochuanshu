---
layout: post
title: "JS逆向实战21——某查查webpack密码加密"
date: "2023-08-16T00:55:28.120Z"
---
JS逆向实战21——某查查webpack密码加密
========================

声明
==

本文章中所有内容仅供学习交流，抓包内容、敏感网址、数据接口均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，若有侵权，请联系我立即删除！

网站
==

> aHR0cHM6Ly93d3cucWNjLmNvbS8=

前言
==

阅读前 请先阅读下我的另一篇文章 看看别的webpack打包的网站是如何逆向的。（[https://www.cnblogs.com/zichliang/p/17517073.html）](https://www.cnblogs.com/zichliang/p/17517073.html%EF%BC%89)  
此文章只是单纯分析。不涉及滑块以及风控以及headers其他的参数。  
只是单纯研究密码的加密。

数据接口分析
======

![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815160440805-2102542014.png)  
如上图所示，我们需要把`epass`参数的生成给找出来  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815162302429-957500308.png)  
直接搜索这个参数 点击第二个  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815162239796-1201128984.png)  
console运行下  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815162443898-1016240180.png)  
证明 `o.default.encrypt(a, "qcc")` 这个方法就是我们所需要的方法函数  
解析进断点。往下走  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815162606241-1333966833.png)  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815162711510-415315268.png)  
这就可以判断。这是通过webpack打包的程序。  
我们点进这个函数中  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815162952293-2041604496.png)  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815163028132-494632852.png)  
然后发现这不就是加载器 只不过不能直接用吗？

扣代码
===

扣加载器
----

其实这个加载器很简单。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815163957762-453453655.png)  
我们把源码复制到本地，收缩起来，发现这个文件本身就是个自执行文件。  
这个文件，我们将他手动修改一下

    !function (r) {
        var l = {};
        function d(e) {
            var t = l[e];
            if (void 0 !== t)
                return t.exports;
            var a = l[e] = {
                id: e,
                loaded: !1,
                exports: {}
            };
            console.log(e)
            return r[e].call(a.exports, a, a.exports, d),
                a.loaded = !0,
                a.exports
        }
    }({
        //模块代码
    })
    

修改成这个鸟样子就可以了。

定位加密函数
------

我们重新输入账号和密码然后过下最开始我们过的断点。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815164604980-982321343.png)  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815164632144-1793040390.png)

持续往下走。。。。  
在这里打上断点  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815165645888-422358948.png)  
然后去刷新页面。  
因为webpack打包是初始化项目，所以后面不需要再输入密码去看断点了。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815165730861-294023202.png)  
看下堆栈。我们往下看第二个模块代码 251115  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815165812734-453668399.png)  
可以发现 `e.AES = n._createHelper(v)` 这个地方就是我们加密初始化的地方。

那么有个问题来了： **为什么 35519 不是呢？**  
很简单： **一句话 这个模块代码是调用加密算法的。**

改写加密函数
------

把这个模块代码放到分发器中。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815170257988-994546452.png)  
还需要加一步============> 把这个加密方法抛出去 ，这样后续才能调用 window.aes\_encrypt["encrypt"](%22123123%22,%22qcc%22) 这个方法。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815170314294-416330744.png)

还需要两步

1.  在加载器中调用这个加密方法。  
    ![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815170447037-1948799891.png)
2.  打印下所需分发器 函数的值  
    ![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815171024834-907657927.png)

后面就很简单了，一直运行 缺什么模块函数就补什么模块函数。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815170509526-347792817.png)

结果
==

全部都补充完毕，我们运行下我们代码。  
![](https://img2023.cnblogs.com/blog/2721529/202308/2721529-20230815171138972-1322668049.png)