---
layout: post
title: "深入理解数据库事务：确保数据完整性与一致性"
date: "2023-08-22T00:56:04.015Z"
---
深入理解数据库事务：确保数据完整性与一致性
=====================

前言
==

在现代信息系统中，数据是至关重要的资产之一。作为一名后端开发人员，与数据库的交道必不可少，为了确保数据的完整性、一致性和可靠性，数据库引入了事务的概念。本次将带您深入了解数据库事务的重要性、特性以及如何在应用程序中正确地使用事务来维护数据的稳定性。

什么是数据库事务？
---------

数据库事务是一组数据库操作的集合，这些操作要么全部成功执行，要么全部失败回滚。事务是数据库管理系统（DBMS）中的核心概念，用于确保数据在并发访问和操作时的一致性和完整性。

### ACID 特性

事务通常遵循 ACID 特性，这是指：

*   **原子性（Atomicity）**：事务中的操作要么全部成功，要么全部失败。如果任何操作失败，整个事务都会回滚，保持数据的一致性。

> 假设您正在购物超市，您选择了一些商品放入购物篮。原子性就像是您在结账时，要么所有商品都被正确地扫描和计算，要么没有商品被结账，就像是所有商品一起被称为一个“原子”单位。

*   **一致性（Consistency）**：事务将数据库从一个合法状态转换为另一个合法状态，不会违反数据完整性约束。

> 在购物过程中，超市会检查您购物篮中的商品是否与价格一致，以确保不会因为错误标价而导致不一致的情况。一致性就像是超市保持商品和价格一致，您购买的商品总是符合预期。

*   **隔离性（Isolation）**：并发执行的事务相互隔离，一个事务的操作不会影响其他事务，直到事务提交才对其他事务可见。

> 想象您和朋友同时在超市购物，但您的购物篮和朋友的购物篮是分开的，互不干扰。这就是隔离性，不同的购物篮（事务）在彼此之间是隔离的，不会相互干扰

*   **持久性（Durability）**：一旦事务提交，其对数据库的更改将永久保存，即使系统崩溃也不会丢失。

> 假设您购买了商品并完成了结账，超市会将您购买的记录存档，以备将来查询。即使您离开超市，您的购买记录仍然被保留，就像是您的购物信息被“持久”存储

事务的基本操作
-------

一个典型的事务通常包括以下步骤：

1.  **开始事务（BEGIN）**：事务开始前，DBMS 记录当前状态以备后用。
    
2.  **执行操作（Perform Operations）**：在事务内执行数据库操作，如插入、更新、删除等。
    
3.  **提交事务（COMMIT）**：如果事务内的所有操作都成功完成，可以将事务提交，将更改永久保存到数据库中。
    
4.  **回滚事务（ROLLBACK）**：如果在事务执行期间发生错误，可以回滚事务，撤消之前的操作，将数据库恢复到事务开始前的状态。
    

事务的隔离级别
-------

事务隔离级别控制了事务之间的可见性和并发行为。常见的隔离级别包括：

*   **读未提交（Read Uncommitted）**：在这个隔离级别下，一个事务可以读取其他事务尚未提交的数据。这可能导致脏读（读取了未提交的数据）、不可重复读（同一查询在事务执行期间返回不同结果）和幻读（事务在同一查询中看到不同的数据行）等问题。读未提交的隔离级别最不严格，可能会引发数据不一致问题
    
*   **读已提交（Read Committed）**：在这个隔离级别下，一个事务只能读取已经提交的数据，避免了脏读问题。但是，不可重复读和幻读问题仍然可能出现。因为其他事务可能在事务进行期间提交新的数据，导致不同时间点的查询结果不一致。
    
*   **可重复读（Repeatable Read）**：可重复读隔离级别确保在同一事务内，同一个查询的结果保持一致。这意味着一个事务中的查询不会受到其他事务的修改影响。这可以防止脏读和不可重复读问题，但幻读问题仍然可能出现，因为其他事务可能插入新数据，导致新数据行的出现。
    
*   **串行化（Serializable）**：串行化是最严格的隔离级别，它确保每个事务都在独立的时间段内执行，防止了并发问题。事务按照顺序一个接一个地执行，这可以解决脏读、不可重复读和幻读问题。然而，串行化可能会对性能产生较大的影响，因为事务需要依次执行。
    

* * *

上面说到事务的隔离级别可以解决脏读、幻读、不可重复读的问题。那么什么是脏读、幻读、和不可重复读呢？

*   **脏读（Dirty Read）**：  
    脏读指的是在一个事务中读取了另一个事务未提交的数据。假设事务 A 修改了某一行数据，但还没有提交。同时，事务 B 尝试读取了事务 A 修改的数据。如果事务 A 最终回滚了，那么事务 B 读取的数据就是不存在的，这就是脏读。脏读会导致不准确的数据展示，因为读取的数据可能是临时的、未经验证的。

> 想象你正在制作一个蛋糕，但在制作过程中，你的朋友看了一眼，然后走了。在他离开之前，你还没有完成蛋糕，但他已经看到了不完整的状态。这就好像是一个“脏读”：朋友读取了还没有完成的信息，结果可能是不准确或临时的。

*   **不可重复读（Non-repeatable Read）**：  
    不可重复读是指在同一个事务内，多次读取同一数据时，得到不同的结果。这可能是因为在事务执行期间，其他事务修改了数据。例如，事务 A 在读取某一行数据后，事务 B 修改了这行数据，并提交了。现在事务 A 再次读取相同的数据，发现数据已经不同了，造成了不一致的现象。

> 假设你正在读一本小说，当你读到一部分内容时，有人偷偷地在书的后面添加了一些新章节。如果你再次阅读同一部分，你会发现内容已经改变了，因为有新的内容被添加进来。这就像是“不可重复读”：同样的数据在短时间内发生了变化，导致你得到了不同的结果。

*   **幻读（Phantom Read）**：  
    幻读是指在同一个事务内，多次查询同一范围的数据时，得到不同的结果。这与不可重复读类似，但幻读关注的是数据的数量变化。例如，事务 A 在查询某个范围内的所有数据时，事务 B 插入了新数据，并提交了。现在事务 A 再次查询同一范围的数据，发现数据行的数量增加了，这就是幻读。

> 想象你正在草地上采摘草莓，你数了一下有多少个成熟的草莓。然后你去拿一个篮子，当你回来时，发现有一些新的草莓从草丛里冒出来，导致总数增加了。这就是“幻读”：同一范围内的数据在短时间内发生了变化，导致数量发生了变化。

事务的传播行为
-------

事务的传播行为是指在多个事务边界交互时，一个事务如何与另一个事务进行交互和传播。传播行为定义了事务的范围、边界和嵌套关系，以确保事务的一致性和正确性。以下是几种常见的事务传播行为：

*   **PROPAGATION\_REQUIRED（需要事务）**：  
    这是默认的传播行为。如果当前没有事务，就创建一个新事务；如果已经存在事务，就加入该事务。这意味着如果方法被调用时没有事务，则会创建一个新事务。如果方法已经在事务中，则方法将使用已经存在的事务。这样做可以保证事务嵌套。

> 这就像您和朋友在一起制作一张拼图。如果朋友已经在拼图上工作（存在事务），您会加入他的工作。如果没有人在拼图，您会创建一个新的拼图，然后加入制作过程。这样，无论之前是否有拼图，您都可以保证最终拼图是一张完整的。

*   **PROPAGATION\_REQUIRES\_NEW（需要新事务）**：  
    无论当前是否存在事务，都会创建一个新的事务。如果方法已经在事务中，则当前事务会被挂起，新事务将创建。这样做可以在方法执行期间独立于外部事务创建一个新的事务，确保完全隔离。

> 这就像您与朋友们一起在不同的活动中度过周末。无论朋友们在做什么活动（存在事务），您都决定自己尝试一项新活动，不受其他人的影响。您可以全身心地投入新的活动，不必担心与其他活动的冲突。

*   **PROPAGATION\_NESTED（嵌套事务）**：  
    如果当前存在事务，则在该事务内嵌套一个新事务。如果没有事务，则行为类似于 PROPAGATION\_REQUIRED。嵌套事务可以回滚到嵌套点，而不会影响外部事务。这样可以实现更细粒度的事务管理。

> 想象您和家人一起做一个家庭项目，同时每个家庭成员也在做各自的小项目。您的小项目被嵌套在整个家庭项目中。您的项目可以独立完成，但仍然受到家庭项目的影响。如果家庭项目失败，您的项目也会受到影响。

*   **PROPAGATION\_SUPPORTS（支持事务）**：  
    如果当前存在事务，则加入该事务；如果没有事务，则以非事务方式执行。这意味着方法将根据调用方的上下文来决定是否执行在事务中。

> 这就像您加入一个跳绳团队的训练。如果其他人正在跳绳（存在事务），您可以选择加入他们的活动。如果没有人在跳绳，您可以以非正式的方式自己练习，不需要参与到团队的事务中。

*   **PROPAGATION\_NOT\_SUPPORTED（不支持事务）**：  
    以非事务方式执行方法。如果当前存在事务，则将其挂起，方法执行完毕后恢复原事务。这样可以保证方法的执行不受外部事务的影响。

> 这就像您在休闲时间去运动，不受任何工作的干扰。无论别人是否在工作，您可以专注于自己的活动，没有事务的干扰。

*   **PROPAGATION\_MANDATORY（强制性的事务）**：  
    必须在一个已存在的事务中执行，否则将抛出异常。这样可以确保方法在事务上下文中被调用。

> 这就像您参加一个要求穿制服的活动。您必须穿制服（存在事务）才能参与，否则将无法参加。

*   **PROPAGATION\_NEVER（不允许事务）**：  
    必须在非事务环境中执行，否则将抛出异常。这样可以确保方法不会被错误地嵌套在事务中。

> 这就像您在一个休息时间内，被告知不能工作。无论其他人是否在工作，您不能参与到事务中。

如何正确使用事务？
---------

在应用程序中，正确使用事务至关重要。以下是一些指导原则：

1.  **小而短的事务**：将事务保持尽可能小和短，以减少对数据库资源的锁定时间，提高并发性能。
    
2.  **适当的隔离级别**：选择适当的隔离级别，平衡数据的一致性和性能需求。
    
3.  **异常处理**：捕获和处理事务中的异常，以便在错误发生时能够正确地回滚事务。
    
4.  **批量操作**：对大量数据进行操作时，考虑使用批量操作，减少事务的数量，提高性能。
    
5.  **事务嵌套**：某些数据库支持事务嵌套，但必须小心使用，确保正确的提交和回滚顺序。
    

总结
--

事务是数据库管理中保证数据一致性和完整性的重要工具。通过遵循 ACID 特性、正确使用事务操作和选择适当的隔离级别，我们可以确保应用程序的数据在并发环境下保持稳定。深入理解和正确使用数据库事务，将使您的应用更加可靠、稳定和高效。