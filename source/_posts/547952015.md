---
layout: post
title: "语音合成技术汇总1：Glow-TTS：通过单调对齐实现文本到语音的生成流"
date: "2023-07-30T01:08:55.135Z"
---
语音合成技术汇总1：Glow-TTS：通过单调对齐实现文本到语音的生成流
====================================

今天开始开一期语音合成经典论文的翻译

Glow-TTS：通过单调对齐实现文本到语音的生成流

摘要：

最近，文本到语音（Text-to-Speech，TTS）模型，如FastSpeech和ParaNet，被提出以并行方式从文本生成mel频谱图（mel-spectrograms）。尽管并行TTS模型具有优势，但它们不能在没有自回归TTS模型作为外部对齐器的指导下进行训练。在本论文中，我们提出了Glow-TTS，一种用于并行TTS的基于流的生成模型，不需要任何外部对齐器。我们引入了单调对齐搜索（Monotonic Alignment Search，MAS），一种用于训练Glow-TTS的内部对齐搜索算法。通过利用流的特性，MAS搜索文本和语音的潜在表示之间最可能的单调对齐关系。与自回归TTS模型Tacotron 2相比，Glow-TTS在合成时获得了数量级的速度提升，并且语音质量相当，仅需要1.5秒来合成一分钟的语音端到端。我们进一步展示了我们的模型可以轻松扩展到多说话人环境。我们的演示页面和代码可在public.12上获得。

关键词： Glow-TTS，生成流，文本到语音，并行TTS，单调对齐，流的特性，自回归TTS，Tacotron 2，合成语音，多说话人。

1\. 引言

文本到语音（Text-to-Speech，TTS）是从文本生成语音的任务，基于深度学习的TTS模型已成功产生了与人类语音无法区分的自然语音。在神经网络TTS模型中，自回归模型如Tacotron 2（Shen等，2018）或Transformer TTS（Li等，2019）展现了最先进的性能。在这些自回归模型的基础上，已经取得了许多进展，以在模拟不同说话风格或不同韵律（Wang等，2018；Skerry-Ryan等，2018；Jia等，2018）方面生成多样化的语音。

尽管自回归TTS模型具有高质量，但在实时服务中直接部署端到端自回归模型存在一些困难。由于模型的合成时间与输出长度呈线性增长，生成长篇语音会导致不必要的延迟，而未经过复杂框架设计的TTS系统可能会在多个管道中传播这种延迟（Ma等，2019）。此外，大多数自回归模型在某些情况下显示出缺乏鲁棒性（Ren等，2019）。例如，当输入文本包含重复单词时，自回归TTS模型通常会产生严重的注意力错误。

为了克服自回归TTS模型的这些限制，提出了并行TTS模型，如FastSpeech。这些模型可以比自回归TTS模型更快地合成mel频谱图。除了快速采样外，FastSpeech通过强制对齐单调性来减少极难句子的失败情况。

然而，这些并行TTS模型的优势来自于文本和语音之间良好对齐的注意力图，这些图是从它们的外部对齐器中提取的。最近提出的并行模型通过从预训练的自回归模型中提取注意力图来解决这些挑战。因此，并行TTS模型的性能严重依赖于自回归TTS模型的性能。此外，由于并行TTS模型假设在训练过程中给定了这种对齐，所以它们不能在没有外部对齐器的情况下进行训练。

在本文中，我们的目标是消除并行TTS模型训练过程中对任何外部对齐器的需求。我们提出了Glow-TTS，一种用于并行TTS的基于流的生成模型，可以内部学习自己的对齐关系。Glow-TTS的训练目标是最大化给定文本情况下语音的对数似然，并且由于生成流的性质，其采样过程是完全并行的。为了消除对其他网络的依赖，我们引入了单调对齐搜索（Monotonic Alignment Search，MAS），一种新颖的方法，仅利用文本和语音的潜在表示来搜索最可能的单调对齐关系。这种内部对齐搜索算法简化了并行TTS模型的整个训练过程，只需在两个GPU上进行3天的训练。

没有任何外部对齐器，我们的并行TTS模型可以比自回归TTS模型Tacotron 2快15.7倍地生成mel频谱图，同时保持相当的性能。与其他TTS模型只有在dropout操作中具有随机性的情况不同，Glow-TTS提供了多样化的语音合成。通过改变归一化流的潜在变量，我们可以控制Glow-TTS合成样本的一些特性。我们进一步展示了我们的模型可以通过只进行少量修改来扩展到多说话人环境。

2\. 相关工作

文本到语音（TTS）模型： TTS模型是一类生成模型，从文本合成语音。TTS模型中的一个子类包括Tacotron 2（Shen等，2018）、Deep Voice 3（Ping等，2017）和Transformer TTS（Li等，2019），它们从文本生成mel频谱图，这是一种音频的压缩表示。它们产生的语音质量媲美人类声音。另一个子类，也称为声码器（vocoder），已经开发出来将mel频谱图转换为高保真音频波形（Shen等，2018；Van Den Oord等，2016），并具有快速合成速度（Kalchbrenner等，2018；Van Den Oord等，2017；Prenger等，2019）。研究还致力于增强TTS模型的表现力。通过辅助嵌入方法，已提出生成多样化语音的方法，可以控制一些因素，如语调和节奏（Skerry-Ryan等，2018；Wang等，2018）。此外，一些研究旨在合成不同说话人的语音（Jia等，2018；Gibiansky等，2017）。

注意： 以上是关于TTS模型的相关工作的简要介绍。由于篇幅有限，该部分只提及了一些代表性的TTS模型，而没有详细阐述各种模型的技术细节。在实际论文中，相关工作部分通常会更加详尽地讨论相关领域内的研究，并对现有的方法和技术进行全面的回顾和对比。

并行解码模型： 对于序列到序列（seq2seq）模型来说，以并行方式解码输出序列存在一些挑战。其中一个挑战是缺乏关于每个输入标记需要生成多少输出标记的信息。例如，大多数TTS数据集不包含语音中每个音素的持续时间值。另一个挑战是在并行方式下建模输出标记之间的条件依赖关系，这使得并行模型难以与自回归模型的性能相匹配。

为了应对这些挑战，已经提出了各种领域的并行解码模型。在自然语言处理领域，Gu等（2017）通过使用外部对齐器根据每个输入标记来分割输出标记，来解决这些挑战。此外，他们使用序列级知识蒸馏（Kim和Rush，2016）来减小自回归教师网络和并行模型之间的性能差距。在TTS领域，Ren等（2019）同样从自回归TTS模型Transformer TTS中提取对齐信息，并利用序列级知识蒸馏来提升性能。另一个并行TTS模型ParaNet（Peng等，2019）则利用其教师网络的软注意力图。

我们的Glow-TTS与所有先前的方法不同，它不依赖于自回归教师网络或外部对齐器，而是在并行TTS中内部学习自己的对齐关系。

基于流的生成模型： 基于流的生成模型因其优点而受到广泛关注（Hoogeboom等，2019；Durkan等，2019；Serrà等，2019）。它们通过应用一些可逆变换来估计数据的准确似然。生成流模型简单地通过训练来最大化这种似然。除了高效的密度估计外，（Dinh等，2014；2016；Kingma＆Dhariwal，2018）中提出的变换保证了快速高效的采样。Prenger等（2019）和Kim等（2018）将这些变换引入原始音频语音合成中，以克服自回归声码器WaveNet（Van Den Oord等，2016）的缓慢采样速度。他们提出的模型WaveGlow和FloWaveNet都比WaveNet更快地合成原始音频。通过应用这些变换，Glow-TTS可以在并行方式下合成给定文本的mel频谱图。

与我们的工作并行的是Flowtron（Valle等，2020）和Flow-TTS（Miao等，2020）。Flowtron是一个基于流的TTS模型，其展示了模型的多样应用，例如通过使用流的属性进行风格转换和控制语音变化。与我们的工作的主要区别在于Flowtron使用自回归流，其目标不是快速语音合成。Flow-TTS是一个并行TTS合成器，使用基于流的解码器和带有位置编码的多头软注意力，与我们的工作相比，我们通过估计每个输入标记的持续时间来预测硬单调对齐。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729133214885-802126790.png)

3\. Glow-TTS

在本节中，我们描述了一种新型的并行TTS模型，即Glow-TTS，它直接通过最大化似然来进行训练，无需其他网络的参与。Glow-TTS通过生成流的逆变换实现并行采样。在第3.1节中，我们阐述了模型的训练和推理过程，并在图1中对这些过程进行了说明。我们在第3.2节中介绍了我们的新颖对齐搜索算法，它消除了训练Glow-TTS所需的其他网络，并在第3.3节中涵盖了Glow-TTS的所有组件，包括文本编码器、持续时间预测器和基于流的解码器。

3.1. Glow-TTS

一般来说，用于条件密度估计的归一化流将给定条件融入到每个流中，并将数据映射到具有条件流的已知先验。然而，Glow-TTS将文本条件融入到先验分布的统计量中，而不是融入到每个流中。

给定一个mel频谱图x，Glow-TTS使用基于流的解码器fdec：x → z将mel频谱图x转换为潜在变量z，而不需要任何文本信息，并且潜在变量z遵循某种各向同性高斯分布PZ。然后，文本编码器fenc将文本条件c映射到文本的高级表示h，并将h投影到高斯分布的统计量µ和σ中。因此，文本序列的每个标记都有其相应的分布，潜在变量z的每个帧都遵循文本编码器预测的这些分布之一。

我们将潜在变量和分布之间的这种对应关系定义为对齐（alignment）A。因此，如果潜在变量zj遵循第i个文本标记的预测分布N(zj；µi，σi)，则我们定义A(j) = i。这种对齐可以解释为序列到序列建模中的硬注意力。因此，给定一个对齐A，我们可以计算数据的准确对数似然，如下所示：

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729133855808-2011283104.png)

 其中，T\_mel是mel频谱图的帧数。由于文本和语音是单调对齐的，我们假设对齐A是单调递增的。

注意：N(zj；µA(j)，σA(j)) 表示在给定文本条件和对齐的情况下，潜在变量z的第j个维度（即z的第j个元素）遵循一个高斯分布，其均值由µA(j)预测，标准差由σA(j)预测。这个高斯分布描述了潜在变量z在第j个维度上的不确定性，即在这个维度上的取值可能会在均值附近波动，并且波动程度由标准差决定。

我们的目标是找到最大化对数似然的参数θ和对齐A，如公式3所示。然而，寻找公式3的全局最优解在计算上是不可行的。为了解决这个难题，我们通过将目标从公式3修改为公式4，减少了参数θ和单调对齐A的搜索空间。

最大化θ和A的目标函数为：

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729135423984-50863294.png)

&lt;span class="katex"&gt;&lt;span class="katex-mathml"&gt;&lt;br&gt;

为了解决计算难题，我们将目标函数改写为：

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729135435970-1948242042.png)

因此，训练Glow-TTS可以分解为两个连续的问题：(i) 在给定当前参数θ的情况下，通过公式5和6搜索与潜在表示z和预测分布最可能对齐的A∗；(ii) 更新当前参数θ，使得在给定A∗的情况下最大化对数概率log pX(x|c; θ, A∗)。在实践中，我们使用迭代的方法来处理这两个问题。在每个训练步骤中，我们首先找到A∗，然后使用梯度下降更新参数θ。虽然我们修改后的目标不能保证得到公式3的全局解，但它仍然提供了全局解的一个很好的下界。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729135731381-1374222495.png)

 为了解决对齐搜索问题（问题i），我们引入了一种新颖的对齐搜索算法，称为单调对齐搜索（Monotonic Alignment Search，MAS），详细描述在第3.2节。需要注意的是，Glow-TTS也可以像FastSpeech一样通过最大化L(θ, Aext)进行训练，其中Aext是从外部对齐器提取得到的。但是，MAS完全消除了我们训练过程中对外部对齐器的依赖。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729135925485-1043971685.png)

　　　　　　　　　　　　　　(a) 对齐的示例，覆盖了文本表示h的所有标记。(b) 计算最大对数似然Q的过程。(c) 搜索最可能的对齐A∗的过程。

　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图2. 单调对齐搜索的图示说明。

除了最大化对数似然之外，我们还训练了一个持续时间预测器fdec，用于预测每个文本标记对应的mel频谱图中的帧数。为了训练持续时间预测器，我们需要为每个文本标记提供一个持续时间标签。我们通过从最可能的对齐A∗（MAS的输出）中提取这个标签来获得持续时间标签，尽管在训练初期MAS可能提供了一个较差的对齐。

根据对齐A∗，我们可以计算每个文本标记对应的语音帧数，如公式7所示，并将帧数dj作为第j个输入标记的持续时间标签。给定文本的高级表示h，我们的持续时间预测器fdur通过均方误差（MSE）损失进行学习，如公式8所示。与FastSpeech（Ren等人，2019）一样，我们在对数域中训练fdur的持续时间dj。我们还对持续时间预测器的输入应用停止梯度运算符sg\[·\]（在反向传播中移除输入的梯度）（Oord等人，2017），以避免影响最大似然目标。因此，我们的最终目标函数如公式9所示。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729140308384-1056369760.png)

 在推断（inference）过程中，如图1b所示，Glow-TTS通过文本编码器fenc和持续时间预测器fdur来预测先验分布的统计信息以及每个文本标记的持续时间。我们将这些预测的持续时间向上取整为整数，并根据每个持续时间来复制相应数量的分布。这样扩展后的分布就成为Glow-TTS在推断过程中的先验分布。然后，Glow-TTS从这个先验分布中对潜在变量z进行采样，并通过将逆转换f−1dec应用到潜在变量z上，以并行方式合成mel频谱图。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729140408903-1530865244.png)

cdef void maximum\_path\_each(int\[:,::1\] path, float\[:,::1\] value, int t\_x, int t\_y, float max\_neg\_val) nogil:
  cdef int x 
  cdef int y
  cdef float v\_prev
  cdef float v\_cur
  cdef float tmp
  cdef int index = t\_x - 1
　\# 参数解释：   
\# path: 用于存储最终的单调对齐A∗的矩阵   
\# value: 用于计算最大对数似然Q的矩阵   
\# t\_x: mel频谱图的长度Tmel  
\# t\_y: 文本的长度Ttext   
\# max\_neg\_val: 一个很小的负值，用于初始化Q矩阵的元素  
  
\# 计算Q矩阵的上三角部分
  for y in range(t\_y):
    for x in range(max(0, t\_x + y - t\_y), min(t\_x, y + 1)):
      if x == y:
        v\_cur \= max\_neg\_val
      else:
        v\_cur \= value\[x, y-1\]
      if x == 0:
        if y == 0:
          v\_prev \= 0.
        else:
          v\_prev \= max\_neg\_val
      else:
        v\_prev \= value\[x-1, y-1\]
      value\[x, y\] \= max(v\_cur, v\_prev) + value\[x, y\]
\# 回溯计算对齐
  for y in range(t\_y - 1, -1, -1):
    path\[index, y\] \= 1
    if index != 0 and (index == y or value\[index, y-1\] < value\[index-1, y-1\]):
      index \= index - 1

3.2. 单调对齐搜索 (Monotonic Alignment Search)

如在第3.1节中提到的，单调对齐搜索 (Monotonic Alignment Search, MAS) 旨在寻找潜在变量 z 和文本表示 h 之间最可能的单调对齐 A∗。由于有大量的对齐方式可以探索，我们根据我们的假设对它们进行限制。我们假设文本和语音是单调对齐的，并且所有文本标记都在语音中有对应。因此，我们只考虑单调对齐并且不跳过任何 h 元素的对齐方式。图2a显示了一个我们关心的可能的对齐方式。

我们在算法1中呈现了我们的对齐搜索算法。我们首先在 h 的第 i 个元素和 z 的第 j 个元素之间推导出递归解，并且通过使用这个推导来找到最可能的对齐 A∗。算法1中的计算过程模拟了这个推导的过程，用于寻找最可能的单调对齐 A∗。

让 Qi,j 表示在 h 和 z 部分给定的情况下，分别到第 i 个元素和第 j 个元素的最大对数似然。由于我们的假设 h:i 应该被单调对齐，即 zj 对应着 hi，而 zj−1 对应着 hi−1 或 hi。这意味着 Qi,j 可以基于可能的部分对齐方式来计算：

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729142651584-503643651.png)

这个过程在图2b中有所说明。我们迭代地计算所有的Q值，直到QTtext,Tmel。需要注意的是，QTtext,Tmel是所有可能的单调对齐的最大对数似然值。

同样地，最可能的对齐A∗可以通过确定在递推关系（方程式11）中哪个Q值较大来检索得到。因此，我们从对齐的末尾开始回溯，A∗(Tmel) = Ttext，以找到所有的A∗值（如图2c所示）。

我们算法的时间复杂度是O(Ttext × Tmel)。虽然我们的方法难以并行化，但它在CPU上运行速度很快，无需使用GPU执行。在我们的实验中，它每次迭代所需的时间不到20毫秒，仅占总训练时间的不到2%。此外，在推断阶段我们不需要使用MAS，因为有一个持续预测器来估计每个输入标记的持续时间。

3.3. 模型架构

Glow-TTS的整体架构可在附录A.1中查看。我们还在附录A.2中列出了模型的配置。

解码器 (Decoder)：Glow-TTS的核心部分是基于流的解码器。在训练过程中，我们需要高效地将梅尔频谱图转换为潜在表示，以进行最大似然估计和内部对齐搜索。在推断过程中，需要将先验分布高效地反演成梅尔频谱图分布，以进行并行解码。因此，我们的解码器由一系列流组成，可以在并行中执行前向和反向变换。其中包括仿射耦合层 (Affine Coupling Layer) (Dinh et al., 2014; 2016)、可逆1x1卷积 (Invertible 1x1 Convolution) 和激活标准化 (Activation Normalization) (Kingma & Dhariwal, 2018)。

具体来说，我们的解码器是多个块的堆叠，每个块包含激活标准化、可逆1x1卷积和仿射耦合层。我们遵循WaveGlow (Prenger et al., 2019)中的仿射耦合层架构，但不使用局部条件 (Local Conditioning) (Van Den Oord et al., 2016)。

为了提高计算效率，在解码器操作之前，我们将80通道的梅尔频谱图帧沿时间维度分成两半，并将它们组合成一个160通道的特征图。我们还修改了1x1卷积，以减少计算其雅可比行列式对数的耗时。在每次1x1卷积之前，我们沿通道维度将特征图分成40个组，并单独对它们进行1x1卷积

编码器（Encoder）：我们遵循Transformer TTS（Li等人，2019）的编码器结构，并进行了两个小修改。我们去掉了位置编码，并将相对位置表示（Shaw等人，2018）添加到自注意力模块中。我们还为编码器预处理层（pre-net）添加了残差连接。为了估计先验分布的统计信息，我们在编码器的最后添加了一个线性层。持续时间预测器由两个带有ReLU激活函数的卷积层组成，之后是层归一化和随机失活（dropout），最后是一个投影层。我们的持续时间预测器的架构和配置与FastSpeech（Ren等人，2019）相同。。

4.  实验

为了评估我们提出的方法，我们在两个不同的数据集上进行实验。对于单一发音人的TTS，我们在广泛使用的单一女性发音人数据集LJSpeech（Ito，2017）上训练我们的模型，该数据集包含13100个短音频片段，总时长约为24小时。我们将数据集随机划分为训练集（12500个样本）、验证集（100个样本）和测试集（500个样本）。对于多发音人TTS，我们使用LibriTTS语料库（Zen等人，2019）的train-clean-100子集，其中包含约247位发音人的约54小时音频记录。我们首先剪辑了数据中所有音频片段的开头和结尾静音部分，然后过滤掉所有文本长度大于190的数据，并将其分成三个数据集进行训练（29181个样本）、验证（88个样本）和测试（442个样本）。此外，我们还收集了用于鲁棒性测试的非分布文本数据。类似于（Battenberg等人，2019），我们从书籍《哈利·波特与魔法石》的前两章中提取了227个话语。

为了将Glow-TTS与自回归TTS模型进行比较，我们将Tacotron 2设置为基准模型，它是最广泛使用的模型，并且遵循（Valle，2018）的配置。在所有实验中，我们将音素作为输入文本标记。我们在音素序列的条件下同时训练Glow-TTS和Tacotron 2。我们将除了基线预训练的文本嵌入层之外的所有参数初始化为与预训练基线相同。我们按照（Valle，2019）的配置进行mel频谱图的训练，然后将两个模型生成的所有mel频谱图通过预训练的声码器WaveGlow4转换为原始波形。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729143344465-1431482746.png)

在训练过程中，我们将Glow-TTS和Tacotron 2生成的所有mel频谱图通过预训练的声码器WaveGlow4转换为原始波形。在训练中，我们简单地将学习到的先验分布的方差σ设置为常数1。使用Adam优化器进行240,000次迭代训练Glow-TTS，学习率调度与（Vaswani等人，2017）中相同。这仅需在2个NVIDIA V100 GPU上进行混合精度训练的3天时间。

为了在多发音人环境中训练Glow-TTS，我们添加了发音人嵌入并增加了文本编码器和解码器的所有隐藏维度。通过将全局条件（Van Den Oord等人，2016）应用于解码器的所有仿射耦合层，我们将模型与发音人嵌入进行条件设置。其余设置与单发音人环境相同。在这种情况下，我们将Glow-TTS训练了480,000次以达到收敛。

5.1. 音频质量 我们使用Amazon Mechanical Turk（AMT）测量平均意见分数（MOS）来比较所有音频的质量，包括地面真实（GT）和我们通过Glow-TTS合成的样本。结果如表1所示。我们随机选择了50个句子用于评估，这些句子来自于我们的测试数据集。从地面真实的mel频谱图转换得到的原始音频质量（4.19±0.07）是TTS模型的上限。我们测量了Glow-TTS在不同先验分布标准差（即温度）下的性能；其中温度为0.333时显示出最佳性能。对于任何温度，我们的Glow-TTS都展现出与强大的自回归基线Tacotron 2相当的性能。

5.2. 采样速度 我们使用包含500个句子的测试数据集来测量TTS模型的采样速度。图3展示了我们的并行TTS模型的推理时间几乎保持在40毫秒，不论句子长度如何，而Tacotron 2的推理时间随着长度的增加而线性增加，这是由于顺序采样导致的。基于平均语音长度的推理时间，Glow-TTS比Tacotron 2快15.7倍合成mel频谱图。

我们还测量了从文本合成一分钟语音的总推理时间，这是在端到端的方式下进行的。对于这个测量，Glow-TTS合成一个长度超过5000帧的mel频谱图，然后WaveGlow将mel频谱图转换为一分钟语音的原始波形。总推理时间仅为1.5秒来合成一分钟的语音，其中Glow-TTS和WaveGlow的推理时间分别占总推理时间的4%和96%。也就是说，Glow-TTS的推理时间仍然只需要55毫秒来合成一个非常长的mel频谱图，并且与声码器WaveGlow相比可以忽略不计。

5.3. 多样性 在样本多样性方面，大多数之前的TTS模型如Tacotron 2或FastSpeech仅在推理时依赖于dropout。然而，由于Glow-TTS是一种基于流的生成模型，它可以在给定输入文本的情况下合成各种各样的语音。这是因为从输入文本中采样的每个潜在表示z都会转换成不同的mel频谱图f−1dec(z)。

我们可以用从标准正态分布中采样的噪声ε表示这个潜在表示z ∼ N (µ, T)，其中先验分布的均值µ和周期T如下所示：

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729143825395-1531887046.png)

 因此，我们可以通过改变噪声ε和温度T来合成多样性的语音。图4a展示了在相同的噪声ε下，通过改变温度可以控制语音的音高，同时保持基频轮廓的趋势。此外，图4b展示了Glow-TTS可以通过仅改变噪声ε来生成具有不同基频轮廓形状的各种语音。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729143953134-754655255.png)

(a) 图中展示了从相同的句子生成的语音样本，其高斯噪声ε相同，但是温度T不同，对应的音高轨迹也不同。

(b) 图中展示了从相同的句子生成的语音样本，其温度T相同（T = 0.667），但是高斯噪声ε不同，对应的音高轨迹也不同。

(a) 图中展示了对输入句子长度的稳健性比较（黄色：Tacotron 2，蓝色：Glow-TTS）。可以看出，Glow-TTS对于输入句子长度的变化更加稳定。

(b) 图中展示了不同语音持续时间的mel频谱图（从上到下依次是1.25倍，1.0倍，0.75倍和0.5倍）。这些是通过控制输入文本中每个token的持续时间来实现的，而Glow-TTS具备这种控制语音持续时间的能力。

5.4. 长度稳健性和可控性

长度稳健性。为了研究TTS模型处理长文本的能力，我们从书籍《哈利·波特与魔法石》中提取了一些语音片段，并对其进行合成。这些语音片段的最大长度超过了800个字符，远远大于LJ数据集中输入字符的最大长度（小于200个字符）。我们通过Google语音识别API（Google Cloud Speech-To-Text）对合成的样本进行字符错误率（CER）测量。

图5a显示了与(Battenberg等，2019)类似的结果。Tacotron 2的CER在输入字符长度超过约260个时开始增长。然而，即使我们的模型在训练中没有见过这么长的文本，它也表现出对输入长度的稳健性。

除了长度稳健性的结果，我们还对特定句子的注意力错误进行了分析。结果显示在附录B.1中。  
长度可控性。由于Glow-TTS与FastSpeech共享相同的持续时间预测器架构，我们的模型也能够控制输出语音的说话速率。我们通过将正标量值乘以持续时间预测器的预测结果来实现控制。我们在图5b中可视化了结果。我们分别将不同的值（1.25、1.0、0.75和0.5）乘以持续时间的预测值。如图5b所示，我们的模型生成了不同长度的mel频谱图。尽管我们的模型在训练中没有见过如此极端快速或缓慢的语音，但该模型可以在不降低质量的情况下控制语音的速度。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729144536690-972956687.png)

 (a) 从不同说话者身份生成的相同句子的语音样本的音高轨迹。 (b) 不同说话者身份的声音转换样本的音高轨迹。 图6. 从在LibriTTS数据集上训练的Glow-TTS中合成的语音样本的基频（F0）轮廓。

![](https://img2023.cnblogs.com/blog/2147832/202307/2147832-20230729144657196-565730481.png)

5.5. 多说话者 TTS

音频质量：我们使用类似于第5.1节的方法来测量MOS。我们随机选择了50个句子用于评估。我们比较了两种不同设置下的音频质量：地面实况音频和从地面实况梅尔频谱合成的音频。结果如表2所示。从地面实况梅尔频谱转换的原始音频质量（4.06±0.07）是TTS模型的上限。我们的模型在最佳配置下实现了约3.5的MOS，这表明Glow-TTS可以建模多样的说话者风格。

  
说话者相关的语音持续时间：图6a显示了使用不同说话者身份生成的相同句子的梅尔频谱。由于持续时间预测器的唯一不同输入是说话者嵌入，该结果表明我们的模型会根据说话者身份不同来预测每个输入标记的持续时间。换句话说，模型根据不同的说话者身份对每个输入标记的持续时间进行个性化预测。

语音转换：由于我们没有将说话者身份提供给编码器，先验分布被迫与说话者身份无关。换句话说，Glow-TTS学会了解耦潜在表示z和说话者身份。为了调查解耦程度，我们将一个具有正确说话者身份的地面真实梅尔频谱转换为潜在表示，然后用不同的说话者身份进行逆转换。结果显示在图6b中。它显示转换后的语音保持了类似的基频趋势，但具有不同的音高。这表明Glow-TTS学会了将声音特征与说话者身份分离开来，使得它可以实现声音的转换。

结论： 我们提出了Glow-TTS，一种新型的并行TTS模型，它提供了快速和高质量的语音合成。Glow-TTS是一种基于流的生成模型，直接通过最大似然估计进行训练，并可以并行地生成给定文本的梅尔频谱。通过引入我们的新型对齐搜索算法Monotonic Alignment Search（MAS），我们简化了整个并行TTS模型的训练过程，仅需要3天的训练时间。除了简单的训练过程外，我们还展示了Glow-TTS的额外优势，例如控制合成语音的说话速率或音高，对长篇音频的鲁棒性，以及在多说话者场景下的可扩展性。由于这些优势，我们认为Glow-TTS是现有TTS模型的一个很好的替代选择。