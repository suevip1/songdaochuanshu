---
layout: post
title: "PB从入坑到放弃（四）常用函数"
date: "2023-07-17T01:26:38.613Z"
---
PB从入坑到放弃（四）常用函数
===============

### 写在前面

这一期呢，来整理下`PB` 常用的函数，包括系统的和一些自己封装好的函数

### 一、字符串相关

#### 1.1 Len函数

> 获取字符串长度

① 语法

    Len(string)
    

②参数

`string`\-->string 类型变量

③ 返回值

*   返回值：`Long`
*   函数执行成功时返回字符串长度，发生错误返回-1
*   函数执行成功时返回字符串长度，发生错误返回-1

#### 1.2 Mid 函数

> 截取字符串

① 语法

    Mid(string,start,length)
    

② 参数

*   string-->string类型，指定要从中要截取的字符串
*   start-->long类型，指定字串第一个字符在string中的位置，第一个位置1
*   length-->long类型，可选项，指定字串长度

③ 返回值

*   返回值：`String`
*   成功时返回`string`字符串中从start位置开始、长度为length的子串
*   如果start参数的值大于string中字符个数，那么Mid()函数返回空字符串
*   如果省略了`length`参数或`length`参数的值大于从`start`开始、`string`字符串中余下字符的长度，函数返回所有余下的字符
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 1.3 Pos函数

> 在一个字符串中查找所包含的另一个字符串的起始位置

①语法

    Pos ( string1, string2, start )
    

② 参数

*   `string1`\-->string类型，目标字符串
*   `string2`\-->string类型，指定要在`string1`中查找的字符串
*   `start`\-->long类型，可选项，指定从`string1`的第几个字符开始查找 缺省值为1

③ 返回值

*   返回值：`Long`
*   成功时返回在`start`位置后`string2`在`string1`中第一次出现的起始位置。
*   如果在`string1`中按指定要求未找到`string2`、或`start`的值超过了`string1`的长度，那么`Pos()`函数返回0。
*   如果任何参数的值为`NULL`，函数返回`NULL`
*   用法`Pos()`函数在字符串查找时区分大小写，因此，`xiezhr`不匹配`XIEZHR`

#### 1.4 Left函数

> 得到字符串左部指定个数的字符

①语法

    Left ( string, n )
    

② 参数

*   `string`\-->string类型，指定要提取子串的字符串
*   `n`\-->long类型，指定子串长度

③ 返回值

*   返回值 :`String`
*   成功时返回`string`字符串左边`n`个字符，发生错误时返回空字符串""
*   如果任何参数的值为`NULL`，`Left()`函数返回`NULL`
*   如果`n`的值大于`string`字符串的长度，函数返回整个`string`字符串，但并不增加其它字符

#### 1.5 Right 函数

> 从字符串右端取指定个数字符

① 语法

    Right ( string, n )
    

② 参数

*   `string`\-->string类型，指定要提取子串的字符串
*   `n`\-->long类型，指定子串长度

③ 返回值

*   返回值：`String`
*   成功时返回`string`字符串右边n个字符，发生错误时返回空字符串""
*   如果任何参数的值为`NULL`，`Right()`函数返回`NULL`
*   如果n的值大于`string`字符串的长度，函数返回整个`string`字符串，并且不增加其它字符

#### 1.6 Trim 函数

> 删除字符串首部和尾部的空格

① 语法

    Trim ( string )
    

② 参数

`string`\-->string类型，要删除空格的目标字符串

③返回值

*   返回值：`String`
*   成功时返回删除了串首部和尾部空格的字符串，发生错误时返回空字符串（""）
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 1.7 Match 函数

> 字符串中是否包含指定模式的字符

① 语法

    Match ( string, textpattern )
    

② 参数

*   `string`\-->`string`类型，要检查是否匹配指定模式的目标字符串
*   `textpattern`\-->`string`类型，指定文本匹配模式

③ 返回

*   返回值 `Boolean`
*   如果字符串`string`与模式`textpattern`相匹配，则函数返回`true`，否则返回`false`
*   如果指定的匹配模式无效或上述两个参数中的任何一个未曾赋值，那么`Match()`函数返回`false`
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 1.8 Fill 函数

> 生成一个由指定字符串填充的指定长度的新字符串

① 语法

    Fill ( string, n )
    

② 参数

*   `string`\--> `string`类型，指定用于重复填充的字符串
*   `n`\-->`long`类型，指定由该函数返回的字符串的长度

③ 返回

*   返回值：`String`
*   成功时返回`n`个字符的字符串，该字符串以参数`string`中的字符串重复填充而成
*   如果参数`string`中的字符个数多于`n`个，那么使用`string`字符串的前n个字符填充函数返回的字符串
*   如果参数`string`中的字符个数少于`n`个，那么使用`string`字符串反复填充，直到返回的字符串长度达到`n`为止
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 1.9 Lower 函数

> 将字符串中的大写字母转换为小写字母

① 语法

    Lower ( string )
    

② 参数

`string`\-->需要转换的目标字符串

③ 返回

*   返回值：`String`
*   函数执行成功时返回将大写字母转换为小写字母后的字符串，发生错误时返回空字符串""
*   如果`string`参数的值为`NULL`，函数返回`NULL`

#### 1.10 Upper 函数

> 将字符串中的小写字母转换为大写字母

① 语法

    Upper( string )
    

② 参数

`string`\--> 需要转换的目标字符串

③ 返回

*   返回值：`String`
*   成功时返回将小写字母转换为大写字母后的字符串，发生错误时返回空字符串""
*   如果`string`参数的值为`NULL`，函数返回`NULL`

#### 1.11 Replace 函数

> 将一个字符串中指定个数的字符串替换为另一个字符串

① 语法

    Replace ( string1, start, n, string2 )
    

② 参数

*   `string1`\--> string类型，指定要使用string2替换其中一部分内容的字符串
*   `start`\--> long类型，指定要从哪个字符位置开始替换字符串，字符串中第一个字符的位置为1
*   `n`\--> long类型，指定要替换多少个字符
*   `string2`\-->string类型，指定用哪个字符串替换string1的部分字符

③ 返回

*   返回值：`String`
*   成功时返回替换后的字符串，发生错误时返回空字符串""
*   如果start参数指定的位置超过了`string1`的长度，函数把将`string2`拼接到`string1`的后  
    面形成的字符串返回
*   如果`n`的值为0，函数把`string2`插入到`string1`指定位置后形成的字符串返回
*   如果任何参数的值为`NULL`，函数返回NULL

#### 1.12 Space 函数

> 生成一个由空格组成的指定字符个数的字符串

① 语法

    Space ( n )
    

② 参数

`n`\-->`long`类型，指定要填充的空格个数，即填充后返回的字符串的长度

③ 返回

*   返回值：`String`
*   成功时返回由`n`个空格组成的字符串，发生错误时返回空字符串""
*   如果参数`n`的值为`NULL`，函数返回`NULL`

#### 1.13 LeftTrim 函数

> 删除字符串左边空格

① 语法

    LeftTrim ( string )
    

② 参数

`string`\-->string类型，需要处理的字符串

③ 返回

*   返回值：`String`
*   成功时返回删除了左部空格的字符串，发生错误时返回空字符串""
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 1.14 RightTrim 函数

> 删除字符串右边空格

① 语法

    RightTrim ( string )
    

② 参数

`string`\-->string类型，需要处理的字符串

③ 返回

*   返回值：`String`
*   成功时返回删除了`string`字符串右部空格的字符串，发生错误时返回空字符串""
*   如果任何参数的值为`NULL`，函数返回`NULL`

### 二、日期时间相关

#### 2.1 Year 函数

> 获取日期中的年份

① 语法

    Year(date)
    

② 参数

`date`\--> `date`类型的值

③ 返回

*   返回值：`Integer`
*   成功时得到`date`参数中的年份（四位数字），发生错误时返回1900
*   如果`date`参数的值为`NULL`，则函数返回`null`
*   PB能够处理的年份从1000到3000之

#### 2.2 Month 函数

> 获取日期中的月份

① 语法

    Month ( date )
    

② 参数

`date`\--> `date`类型的值

③ 返回

*   返回值：`Integer`
*   成功时得到`date`参数中的月份（1到12之间）
*   如果`date`参数的值为`NULL`，函数返回`NULL`

#### 2.3 Day 函数

> 获取日期中的号数(1到31之间的整数值)

① 语法

    Day (date)
    

② 参数

`date`\--> `date`类型的值

③ 返回

*   返回值：`Integer`
*   成功时返回号数(1到31之间的整数值)
*   如果`date`参数的值为`NULL`，函数返回`NULL`

#### 2.4 Hour 函数

> 获取时间值中的小时，采用24小时制

① 语法

    Hour (time)
    

② 参数

`time`\-->`time`类型的值

③ 返回

*   返回值：`Integer`
*   成功时得到`time`参数中的小时（00到23之间）
*   如果`time`参数的值为`NULL`，函数返回`NULL`

#### 2.5 Minute 函数

> 获取时间值中的分钟，00～59之间

① 语法

    Minute (time)
    

② 参数

`time`\-->`time`类型的值

③ 返回

*   返回值：`Integer`
*   成功时得到`time`参数中的分钟（00到59之间）
*   如果`time`参数的值为`NULL`，函数返回`NULL`

#### 2.6 Second 函数

> 获取时间值中的秒，在00～59之间

① 语法

    Second (time)
    

② 参数

`time`\-->`time`类型的值

③ 返回

*   返回值：`Integer`
*   成功时得到`time`参数中的秒（00到59之间）
*   如果time参数的值为`NULL`，函数返回`NULL`

#### 2.7 Today 函数

> 获取当前系统日期，在某些情况下，同时得到当前系统时间

① 语法

    Today()
    

② 参数

无

③ 返回

*   返回值：Date 当前系统日期
*   单独调用Today()函数时，返回当前系统日期
*   用做某些函数的参数、而该参数要求`DateTime`类型的值时，函数能够在返回当前系统日期的同时返回当前系统时间

#### 2.8 Now 函数

> 获取**客户机**的当前系统时间

① 语法

    Now()
    

② 参数

无

③ 返回

*   返回值：Time 客户机的当前系统时间

#### 2.9 RelativeDate 函数

> 获取指定日期前多少天或后多少天的日期

① 语法

    RelativeDate(date,n)
    

② 参数

*   `date`\-->`Date`类型，指定基准日期
*   `n`\-->`integer`类型，指定天数

③ 返回

*   返回值：`Date`
*   当`n>0`时返回指定日期后第n天的日期；
*   当`n<0` 时返回指定日期前第n天的日期。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 2.10 RelativeTime 函数

> 获取指定时间前多少秒或后多少秒的时间，采用24小时制

① 语法

    RelativeTime (time, n)
    

② 参数

*   `time`\--> time类型，指定基准时间
*   `n`\--> long类型，指定秒数

③ 返回

*   返回值：`Time`
*   当`n>0`时返回指定时间后第n秒的时间；
*   当`n<0`时返回指定时间前第n秒的时间。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 2.11 DaysAfter 函数

> 获取两个日期间的天数

① 语法

    DaysAfter ( date1, date2 )
    

② 参数

*   `date1`\-->`date`类型，指定开始日期
*   `date2`\-->`date`类型，指定截止日期

③ 返回

*   返回值：`Long`
*   成功时得到两个日期之间的天数
*   如果`date2`的日期在`date1`的前面，函数返回负值。
*   如果任何参数的值为`NULL`，函数返回NULL

#### 2.12 DayName 函数

> 获取指定日期是一周中的星期几(例如，Sunday, Monday...)

① 语法

    DayName ( date )
    

② 参数

`date`\--> `date`类型值或变量

③ 返回

*   返回值：`String`
*   成功时返回指定日期的星期表示(例如，Sunday, Monday...)
*   如果`date`参数的值为`NULL`，函数返回`NULL`

#### 2.13 DayNumber

> 获取指定日期是一星期中的第几天(用1到7之间的整数表示，星期天为1，星期一为2，...)。

① 语法

    DayNumber ( date )
    

② 参数

`date`\-->`date`类型值或变量

③ 返回

*   返回值：`Integer`
*   成功时返回指定日期是一星期中的第几天(用1~7表示，星期天为1，星期一为2，...)
*   如果date参数的值为`NULL`，函数返回NULL

### 三、配置文件读取

配置文件xiezhr.ini 内容如下

    [transaction]
    DBMS =O84 Oracle8/8i (8.x.4+)
    username =xiezhr
    password =xiezhr
    servername =127.0.0.1:1521/orcl
    

#### 3.1 ProfileString函数

> 获取配置文件中指定节点内容

① 语法

    ProfileString(filename,nodename,default_value)
    

② 参数

*   `filename`\--> 配置文件名称
*   `nodename`\--> 配置文件中的节点名称
*   `default_value`\--> 未找到指定的节或键，则返回的默认值

③ 返回

*   返回值：string
*   如果找到指定的节和键，则返回对应的值
*   如果未找到指定的节或键，则返回默认值default\_value

④ 举个栗子

我们来获取项目根目录下xiezhr.in配置文件中的数据库用户名、密码、连接信息

    ls_username = ProfileString("xiezhr.ini","transaction","username","scott")
    ls_password = ProfileString("xiezhr.ini","transaction","password","tiger")
    ls_servername = ProfileString("xiezhr.ini","transaction","servername","127.0.0.1:1521/orcl")
    

#### 3.2 SetProfileString 函数

> 设置配置文件中指定节点内容

① 语法

    SetProfileString(filename,nodename,sourcename,value)
    

② 参数

*   `filename`\--> 配置文件名称
*   `nodename`\-->节点名称
*   `sourcename`\-->节点下目标位置名称
*   `value-->` 需要设置的值

③ 返回

*   返回值：`Integer`
*   如果成功写入值，则返回0
*   如果写入失败，则返回-1

④ 举个栗子

我们修改项目更目录下xiezhr.ini配置文件内容,将username值设置成xiezhr

    SetProfileString('xiezhr.ini','transaction','username',xiezhr')
    

### 四、数组相关

string ls\_arr\[\]

#### 4.1 upperbound 函数

> 获取数组长度

① 语法

    upperbound(array)
    

② 参数

`array`\-->数组名 ls\_arr

③ 返回

*   返回值：long
*   成功返回：array数组长度
*   失败返回：-1

#### 4.2 lowerbound 函数

> 获取指定数组数组的下界

① 语法

    lowerbound(array)
    

② 参数

`array`\-->数组名 ls\_arr

③ 返回

*   返回值：long
*   成功返回：array数组长度
*   失败返回：-1

**小技巧**

**怎么将数组置空？**

    string ls_arr[],ls_null[]
    int i
    for i=1 to 10
    	ls_arr[i]=string(i)
    next
    messagebox('数组长度',UpperBound(ls_arr))
    ls_arr = ls_null 
    messagebox('数组长度',UpperBound(ls_arr))
    

### 五、数据类型转换

#### 5.1 String 函数

> 按照指定格式将数据转换成字符串

① 语法

    String(data,{format})
    

② 参数

`data`\--> 指定需要转换的数据，据类型可以是`Date`、`DateTime`、数值类型、`Time`

`format`\--> 可选项，指定转换的数据格式

数据格式说明如下

Ⅰ **需要转换的数据data 为数值**

> **语法格式为**：正数格式；负数格式；零的显示格式

*   \# 代表0~9之间的任意数字
*   0 代表每个零都要显示
*   $或￥ 代表货币符号
*   % 百分号
*   . 小数点
*   ， 逗号

注意：除小数点（.）、逗号（，）能够出现在格式字符#和0之间外，其它字符只能放置在格式串的前面或后面

如果显示格式有多个部分，各部分之间的分号（；）不能省略

Ⅱ **需要转换的数据data 为字符串**

> **语法格式为**：正常字符串格式

*   @代表字符串中的任意字符
*   @除外任何字符照原样显示

举个栗子

    string("0166767593",（@@）@@@@-@@@@)
    //显示为（01）6676-7593
    

Ⅲ **需要转换的数据data为日期**

1）年份

*   `yy`两位数字表示的年份（如**92**）
    
*   `yyyy`四位数字表示的年份（如**1992**）
    
    2）月份
    
*   `m`开头不带0的月份（如**9**）
    
*   `mm`开头带0的月份（如**09**）
    
*   `mmm`月份的英文缩写（如**Feb**）
    
*   `mmmm`月份的英文全称（如**February**）
    
    3）日
    
*   `d`开头不带0的日数（如**9**）
    
*   `dd`开头带0的日数（如**09**）
    
*   `ddd`星期的英文缩写（如**Mon**）
    
*   `dddd`星期的英文全称（如**Monday**）
    

4.  windows系统定义的格式

*   `[General]` Windows系统中定义的短日期格式
*   `[LongDate]` Windows系统中定义的长日期格式
*   `[ShortDate]` Windows系统中定义的短日期格式

Ⅳ **需要转换的数据data为时间**

1） 小时

*   h开头不带0的小时（比如6）
    
*   hh开头带0的小时（比如06）
    
    2） 分钟
    
*   h开头不带0的小时（比如6）
    
*   hh开头带0的小时（比如06）
    
    3） 秒
    
*   s开头不带0的秒（比如6）
    
*   ss开头带0的秒（比如06）
    

4）上午下午

*   AM/PM 显示上、下午时间
*   am/pm显示上、下午时间
*   A/P显示上、下午时间
*   a/p显示上、下午时间

#### 5.2 Time 函数

> 把其他类型数据转换成Time类型的值

① 语法

    Ⅰ 将DateTime类型或第一个值是DateTime或Time的Blob值转换成Time类型的值
    Time ( datetime )
    Ⅱ 将其值是个有效时间的字符串转换成Time类型的值
    Time ( string )
    Ⅲ 将表示时、分、秒、以及微秒的整数组合成一个时间值
    Time(hour, minute, second {, microsecond })  
    

② 参数

*   `datetime` --> `DateTime`类型的值或第一个值是`DateTime`或`Time`的`Blob`类型的值
    
*   `string` \--> `string`类型，其值包括一个有效的以字符串形式表示的时间（比如**9am**或**10:25**）
    
*   `hour, minute, second {, microsecond }`
    
    *    `hour`\--> integer类型，指定时间中的小时，**从0到23**
        
    *    `minute`\-->integer类型，指定时间中的分钟，**从0到59**
        
    *    `second`\-->integer类型，指定时间中的秒，**从0到59**
        
    *    `microsecond` -->integer类型，可选项，指定时间中的微秒，**从0到32767**
        

③ 返回

Ⅰ `datetime` 转换

*   返回值：Time
    
*   成功时返回相应的Time类型值
    
*   如果`datetime`参数中的值不是有效时间或数据类型不兼容，函数返回`00:00:00.000000`
    
*   如果`datetime`参数的值为`NULL`，函数返回`NULL`
    
    Ⅱ 字符串转换
    
*   返回值：Time
    
*   成功时返回相应的Time类型值
    
*   string参数中的值不是有效格式时间，函数返回`00:00:00.000000`
    
*   如果string参数的值为`NULL`，函数返回`NULL`
    
    Ⅲ 时分秒毫秒合成时间
    
*   返回值：Time
    
*   成功时返回由hour、minute、second、microsecond 四个参数确定的时间
    
*   如果这四个参数中任何一个参数使用了无效值,函数返回NULL
    

#### 5.3 Date 函数

> 将其它类型的数据转换为Date类型的数据

① 语法

    Ⅰ将DateTime类型或第一个值是DateTime或Date的Blob值转换成Date类型的值
    Date ( datetime )
    Ⅱ 将有效日期的字符串转换成Date类型的值
    Date ( string )
    Ⅲ 将年、月、日合成一个日期
    Date ( year, month, day )
    

② 参数

*   `datetime` --> `DateTime`类型的值或第一个值是`DateTime`或`Time`的`Blob`类型的值
    
*   `string` \--> `string`类型，有效字符串形式的日期（比如1992-09-23）
    
*   `year, month, day`
    
    *    `year`\--> integer类型，指定日期中的年份，用四位数字表示，**从0到9999**
        
    *    `month`\-->integer类型，定日期中的月份，用一位或两位数字表示，**从1到12**
        
    *    `day`\-->integer类型，指定日期中的号数，用一位或两位数字表示，**从1到31**
        

③ 返回

Ⅰ `datetime` 转换日期

*   返回值：Date
*   成功时返回相应的Date类型值
*   如果`datetime`参数中的值不是有效日期或数据类型不兼容，函数返回`1900-01-01`
*   如果`datetime`参数的值为`NULL`，函数返回`NULL`

Ⅱ 字符串转换日期

*   返回值：Date
*   函数执行成功时返回相应的Date类型值。
*   如果`string`参数中的值不是有效日期或数据类型不兼容，函数返回`1900-01-01`
*   如果`string`参数的值为`NULL`，函数返回`NULL`

Ⅲ 年月日合成日期

*   返回值：Date
*   函数执行成功时返回由`year`、`month`、day三个参数确定的日期
*   如果这三个参数中任何一个参数使用了无效值（比如月份指定为15），函数返回`1900-01-01`
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 5.4 DateTime 函数

> 将其它类型的数据转换为DateTime类型的数据

① 语法

    Ⅰ 把日期和时间值组合成DateTime类型的值
    DateTime ( date {, time } )
    Ⅱ 将Blob类型的值转换成DateTime类型的值
    DateTime ( blob )
    

② 参数

Ⅰ日期和时间值组合成`DateTime`类型的值

*   `date`\-->Date类型的日期值
*   `time`\-->可选参数，Time类型的时间值,省略时，时间默认是`00:00:00.000000`

Ⅱ `Blob`类型的值转换成`DateTime`类型的值

*   `blob` \-->Blob类型变量 把该变量第一个值转换为`DateTime`类型的值 ,`blob`参数也可以是包含`blob`类型数据的Any类型变量

③ 返回

Ⅰ 日期和时间值组合成`DateTime`类型的值

*   返回值：`DateTime`
*   成功时返回日期和时间组合而成的`DateTime`类型的值
*   如果任何参数的值为`NULL`，函数返回`NULL`

Ⅱ 将Blob类型的值转换成`DateTime`类型的值

*   返回值：`DateTime`
*   成功时返回相应的`DateTime`类型值
*   如果`blob`参数的值为`NULL`,函数返回`NULL`

#### 5.5 Asc 函数

> 获取字符串第一个字符的ASCII码整数值

① 语法

    Asc ( string )
    

② 参数

`string`\-->目标字符串

③ 返回

*   返回值：`integer`
*   行成功时返回`string`参数第一个字符的`ascii`值
*   如果`string`参数的值为`null`，函数返回null

#### 5.6 Char 函数

> 将字符串的第一个字符、Blob变量的第一个值、或一个整数转换成字符

① 语法

    Char ( any )
    

② 参数

`any`\-->字符串、`Blob`变量或整数，也可以是包含上述类型数据的Any类型变量

③ 返回

*   返回值：`Char`
*   返回参数`any`的第一个字符
*   如果`any`参数的值为`NULL`，函数返回`NULL`

#### 5.7 Dec 函数

> 将字符串或Blob值转换成Decimal类型的值

① 语法

    Dec ( strorblob )
    

② 参数

`strorblob`\-->string类型变量或Blob类型变量

③ 返回

*   返回值：`Decimal`
*   成功时返回相应的`Decimal`类型值
*   如果`strorblo`b参数中的值不是有效数字或数据类型不兼容，函数返回0
*   如果`strorblob`参数的值为`NULL`，函数返回`NULL`

#### 5.8 Double 函数

> 字符串或Blob值转换成Double类型的值

① 语法

    Double(strorblob)
    

② 参数

`strorblob`\-->string类型变量或Blob类型变量

③ 返回

*   返回值：`Double`
*   成功时返回相应的`Double`类型值
*   如果`strorblob`参数中的值不是有效数字或数据类型不兼容，函数返回0
*   如果`strorblob`参数的值为`NULL`，函数返回`NULL`

#### 5.9 Integer 函数

> 将字符串或Blob值转换成Integer类型的值

① 语法

    Integer ( strorblob )
    

② 参数

`strorblob`\-->string类型变量或Blob类型变量

③ 返回

*   返回值：`Integer`
*   成功时返回相应的`Integer`类型值
*   如果`strorblob`参数中的值不是有效数字或数据类型不兼容，函数返回0
*   如果`strorblob`参数的值为`NULL`，函数返回`NULL`

#### 5.10 Long 函数

> 将其它类型的数据转换为Long类型的值

① 语法

    Ⅰ 将两个无符号整数组合成一个长整数值
    Long ( lowword, highword )
    Ⅱ 字符串或Blob值转换成Long类型的值
    Long ( strorblob )
    

② 参数

Ⅰ 将两个无符号整数组合成一个长整数值

*   `lowword` -->`UnsignedInteger`类型，指定长整数中的低位值
*   `highword` -->`UnsignedInteger`类型，指定长整数中的高位值

Ⅱ 字符串或Blob值转换成Long类型的值

`strorblob`\-->string类型变量或Blob类型变量

③ 返回

Ⅰ 将两个无符号整数组合成一个长整数值

*   返回值:`Long`
*   成功时返回由低位值和高位值组合后的长整数值
*   发生错误时返回-1
*   如果任何参数的值为`NUL`L，函数返回`NULL`

Ⅱ 字符串或Blob值转换成Long类型的值

*   返回值:`Long`
*   成功时返回由低位值和高位值组合后的长整数值
*   发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 5.11 Real 函数

> 将字符串或Blob值转换成Real类型的值

① 语法

    Real ( strorblob )
    

② 参数

`strorblob`\-->`string`类型变量或`Blob`类型变量

③ 返回

*   返回值：`Real`
*   成功时返回相应的`Real`类型值
*   如果`strorblob`参数中的值不是有效数字或数据类型不兼容，函数返回0
*   如果`stringorblob`参数的值为`NULL`,函数返回`NULL`

#### 5.12 IsDate 函数

> 判断指定的字符串是否包含有效的日期

① 语法

    IsDate ( strvalue )
    

② 参数

`strvalue`\-->`string`类型，指定要判断的字符串

③ 返回

*   返回值：`Boolean`
*   如果`strvalue`包含了有效的日期，函数返回`TRUE`，否则返回`FALSE`
*   如果`strvalue`参数的值为`NULL`，函数返回`NULL`

#### 5.13 IsNumber 函数

> 判断字符串是否是有效的数值

① 语法

    IsNumber ( strvalue )
    

② 参数

`strvalue`\-->`string`类型，指定要判断的字符串

③ 返回

*   返回值：`Boolean`
*   如果`strvalue`的值为有效数字，函数返回`TRUE`，否则返回`FALSE`
*   如果`strvalue`参数的值为`NULL`，函数返回`NULL`

#### 5.14 IsTime 函数

> 判断字符串的值是否是有效的时间

① 语法

    IsTime ( strvalue )
    

② 参数

`strvalue`\-->`string`类型，指定要判断的字符串

③ 返回

*   返回值：`Boolean`
*   如果`strvalue`的值为有效的时间，函数返回`TRUE`，否则返回`FALSE`
*   如果`strvalue`参数的值为`NULL`，函数返回`NULL`

#### 5.15 IsNull 函数

> 判断值是否是NULL

① 语法

    IsNull(any)
    

② 参数

`any`：任何变量或表达式

③ 返回

*   返回值：`Boolean`
*   如果any的值为`NULL`，函数返回`TRUE`，否则返回`FALSE`

#### 5.16 IsValid 函数

> 判断对象变量是否已经实例化

① 语法

    IsValid ( objectname )
    

② 参数

`objectname`\-->要检测的对象名

③ 返回

*   返回值：`Boolean`
*   如果指定对象已经创建了对象实例，函数返回`TRUE`，否则返回`FALSE`
*   如果参数`objectname`的值为`NULL`，函数返回`NULL`

#### 5.17 SetNull 函数

> 将指定变量的值设置为NULL。这里的变量可以是除数组、结构、自动实例化对象之外的任何数据类型

① 语法

    SetNull ( anyvariable )
    

② 参数

`anyvariable`\-->要将其值设置为`NULL`的变量

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果参数的值为`NULL`，函数返回`NULL`

### 六、数值计算

#### 6.1 Abs 函数

> 计算绝对值

① 语法

    Abs ( n )
    

② 参数

`n`\-->要求绝对值的数值型变量 或 返回值为数值的表达式

③ 返回

*   成功时返回`n`的绝对值
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.2 Ceiling 函数

> 返回大于n的最小整数

① 语法

    Ceiling ( n )
    

② 参数

`n`\-->数值型变量 或 返回值为数值的表达式

③ 返回

*   成功时返回大于n的最小整数。
*   如果参数n的值为`NULL`，函数返回`NULL`

#### 6.3 Cos 函数

> 计算余弦

① 语法

    Cos ( n )
    

② 参数

`n`\-->数值型变量 或 返回值为数值的表达式

③ 返回

*   成功时返回n的余弦
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.4 Exp 函数

> 计算e的n次方

① 语法

    Exp ( n )
    

② 参数

`n`\-->指定幂值

③ 返回

*   返回值：`Double`
*   成功时返回e（约等于2.71828）的n次方。
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.5 Fact 函数

> 计算n的阶乘

① 语法

    Fact ( n )
    

② 参数

`n`\-->数值型变量 或 返回值为数值的表达式

③ 返回

*   返回值：`Double`
*   成功时返回n的阶乘。
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.6 Int 函数

> 得到小于等于n的最大整数

① 语法

    Int ( n )
    

② 参数

`n`\-->数值型变量 或 返回值为数值的表达式

③ 返回

*   返回值：`Integer`
*   成功时返回小于等于n的最大整数
*   如果n的值太小或太大，超过了整数的表示范围，则函数返回0。
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.7 Log 函数

> 计算n的自然对数

① 语法

    Log ( n )
    

② 参数

`n`\-->数值型变量 或 返回值为数值的表达式值必须大于0

③ 返回

*   返回值：`Double`
*   成功时返回n的自然对数
*   如果n小于等于0，将导致运行错误
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.8 LogTen 函数

> 计算n的常用对数（以10为底）

① 语法

    LogTen ( n )
    

② 参数

`n`\-->数值型变量 或 返回值为数值的表达式值必须大于0

③ 返回

*   返回值：`Double`
*   成功时返回n的常用对数
*   如果n小于等于0，将导致运行错误
*   如果参数n的值为`NULL`，函数返回`NULL`

#### 6.9 Max 函数

> 求两个数中最大值

① 语法

    Max ( x, y )
    

② 参数

*   `x`\-->数值型变量或表达式，参加比较的第一个数
*   `y` -->数值型变量或表达式，参加比较的第二个数

③ 返回

*   成功时返回参数比较的两个数中更大者。
*   如果任何参数的值为`NULL`，返回`NULL`

#### 6.10 Min 函数

> 两个数中的最小值

① 语法

    Min( x, y )
    

② 参数

`x`\-->数值型变量或表达式，参加比较的第一个数  
`y` \-->数值型变量或表达式，参加比较的第二个数

③ 返回

*   成功时返回参数比较的两个数中较小者
*   如果任何参数的值为`NULL`，返回`NULL`

#### 6.11 Mod 函数

> 求余数

① 语法

    Mod ( x, y )
    

② 参数

`x`\-->数值型变量或表达式，被除数  
`y` -->数值型变量或表达式，除数

③ 返回

*   成功时返回x除以y所得的余数
*   如果任何参数的值为`NULL`，数返回`NULL`

#### 6.12 Pi 函数

> 计算n与Pi(3.14159265358979323...)的乘积

① 语法

    Pi ( n )
    

② 参数

`n`\-->数值型变量或表达式

③ 返回

*   返回值：`Double`
*   函数执行成功时返回n与Pi(3.14159265358979323...)的乘积
*   发生错误时返回-1
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.13 Rand 函数

> 得到1与n之间的一个伪随机数

① 语法

    Rand ( n )
    

② 参数

`n`：数值型变量或表达式 产生随机数的最大值 1到32,767之间

③ 返回

*   成功时返回1与n之间的一个伪随机数，包括1和n在内
*   如果参数n的值为NULL，函数返回`NULL`

#### 6.14 Randomize 函数

> 初始化伪随机数发生器，这样让应用程序每次使用不同的伪随机数序列

① 语法

    Randomize ( n )
    

② 参数

`n`\-->数值型变量或表达式，指定伪随机数生成器使用的起始值，不同的起始值可以生成不同的伪随机数序列

注：n的值在0到32,767之间

③ 返回

*   返回值：`Integer`
*   当n的值为0时，该函数把系统时钟作为伪随机数生成器的起始值，这样可以生成不可重复的伪随机数序列
*   当n的值不为0时，可以产生不同的伪随机数序列，但是，如果两次使用相同的伪随机数生成器起始值，那么两  
    次生成的伪随机数序列相同

#### 6.15 Round 函数

> 将x四舍五入到n位

① 语法

    Round ( x, n )
    

② 参数

*   `x`\-->要四舍五入的数值型数据
    
*   `n`\-->整数类型，指定从哪个小数位上四舍五入x。
    
    注：有效值在0到18之间
    

③ 返回

*   返回值：`Decimal`
*   成功时返回将x四舍五入到小数点后第n位的数值，
*   如果函数执行失败或任何参数的值为`NULL`，函数返回`NULL`

#### 6.16 Sign 函数

> 确定n是整数、负数还是零

① 语法

    Sign ( n )
    

② 参数

`n`\-->数值型变量或表达式

③ 返回

*   返回值Integer
*   当n大于0时返回1
*   当n小于0时返回-1
*   当n等于0时返回0
*   如果参数n的值为`NULL`，函数返回`NULL`

#### 6.17 Sin 函数

> 计算正弦，其中参数以弧度为单位

① 语法

    Sin( n )
    

② 参数

`n`\-->数值型变量或表达式

③ 返回

*   返回值：`Double`
*   成功时返回n的正弦
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.18 Sqrt 函数

> 计算平方根

① 语法

    Sqrt ( n )
    

② 参数

`n`\-->数值型变量或表达式 n的值大于0

③ 返回

*   返回值：`Double`
*   函数执行成功时返回n的平方根。
*   如果n是负数，则执行该函数时引发运行错误。
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.19 Tan 函数

> 计算正切，其中参数以弧度为单位

① 语法

    Tan( n )  
    

② 参数

`n`\-->数值型变量或表达式

③ 返回

*   返回值：`Double`
*   成功时返回n的正切值
*   如果参数n的值为`NULL`，返回`NULL`

#### 6.20 Truncate 函数

> 截断数值到指定的小数位 , 所谓截断就是舍弃指定位之后的数值

① 语法

    Truncate ( x, n )
    

② 参数

*   `x`\-->要截断的数值型数据
*   `n`\-->整数类型，指定从哪个小数位上截断x

注：有效值在0到18之间

③ 返回

*   返回值：`Decimal`
*   成功时返回将x截断到小数点后第n位的数值
*   失败或任何参数的值为NULL，返回NULL

### 七、定时相关

#### 7.1 CPU 函数

> 到自当前应用程序启动后开始CPU所消耗的时间，以毫秒为单位

① 语法

CPU()

② 参数

无

③ 返回

*   返回值：`Long`
*   返回自当前应用程序启动后开始CPU所消耗的时间，以毫秒为单位

#### 7.2 Timer 函数

> 在指定的时间间隔内反复触发指定窗口的定时器事件

① 语法

    Timer ( interval {, windowname } )
    

② 参数

*   `interval`\-->指定两次触发`Timer`事件之间的时间间隔，有效值在0到65之间
*   `windowname`\-->窗口名，指定时间间隔到时要触发哪个窗口的Timer事件。省略该参数时，触发当前窗口的Timer事件

注：

参数的值指定为0，那么关闭定时器，不再触发指定窗口的Timer事件

#### 7.3 Idle 函数

> 该函数在用户每次活动（例如，按键盘、移动鼠标等）后重置定时器，n秒后触发应用对象的Idle事件

① 语法

    Idle ( n )
    

② 参数

`n`\-->指定空闲时间间隔，以秒为单位

参数的值设置为0时，停止空闲检测，不再触发应用对象的Idle事件

③ 返回

*   返回值：`Integer`
*   成功时返回1，此时启动定时器
*   如果不能启动定时器或定时器未启动而n的值指定为0时，函数返回-1
*   如果任何参数的值为`NULL`，返回`NULL`

### 八、注册表相关

#### 8.1 RegistrySet 函数

> 在系统注册库中设置或创建指定键

① 语法

    RegistrySet ( key, valuename, valuetype, value )
    

② 参数

*   `key`\-->`string`类型，指定键名
*   `valuename`\-->`string`类型，指定要访问值的名称
    *   每个键可以有一个未命名的值和多个命名的值
    *   要访问未命名的值，把该参数指定为空字符串（""）
    *   如果注册库中不存在指定值名，该函数将创建新的值名
*   `valuetype`\-->`RegistryValueType`枚举类型，指定值的数据类型。有效取值请参看用法
*   `value`\-->要设置的值，其数据类型应该与`valuetype`参数指定的类型相匹配

③ 返回

*   返回值:`Integer`
*   成功时返回1，发生错误时返回-1
*   如果`valuevariable`的数据类型与`valuetype`参数指定的类型不匹配，将引发运行错误

④ 举个栗子

    //利用注册表修改ODBC配置信息
    RegistrySet( 'HKEY_CURRENT_USER\Software\ODBC\ODBC.INI\ODBC Data Sources','localdb',REGSTRING!,'Driver do Microsoft Access (*.mdb)')
    

#### 8.2 RegistryGet 函数

> 从系统注册库中得到指定键的值

① 语法

    RegistryGet ( key, valuename, valuetype, valuevariable )
    

② 参数

*   `key`\-->`string`类型，指定键名
*   `valuename`\-->`string`类型，指定要访问值的名称。每个键可以有一个未命名的值和多个命名的值。要访问未  
    命名的值，把该参数指定为空字符串""
*   `valuetype`\-->`RegistryValueType`枚举类型，指定值的数据类型。有效取值请参看用法
*   `valuevariable`\-->用于保存键值的变量，其数据类型应该与`valuetype`参数指定的类型相匹配

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果`valuevariable`的数据类型与`valuetype`参数指定的类型不匹配，将引发运行错误

④ 举个栗子

    //取得打印机驱动程序名称	RegistryGet("HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Print\Printers\"+str_printername,"Printer Driver", RegString!,str_driver)
    

#### 8.3 RegistryDelete 函数

> 删除Windows系统注册库中的一个键或键的某个值

① 语法

    RegistryDelete ( key, valuename )
    

② 参数

*   `key`\-->`string`类型，指定键名，将删除该键或删除该键的某个值
    
*   `valuename`\-->`string`类型，指定要删除的值的名称
    
    注：如果想删除键、键的值、以及其下的所有子键，那么将该参数指定为空字符串
    

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1

④ 举个栗子

    event clicked;Registrydelete( "HKEY_LOCAL_MACHINE\Software\NEUHIS", "")
    

#### 8.4 RegistryKeys 函数

> 从系统注册库中得到指定键的有效子键

① 语法

    RegistryKeys ( key, subkeys )
    

② 参数

*   `key`\-->`string`类型，指定键名
*   `subkeys`\-->字符串数组变量，用于保存各子键

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1

④ 举个栗子

    string str_printer[]  //定义一个字符串型数组
    int_return = RegistryKeys("HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Print\Printers", str_printer)
    

#### 8.5 RegistryValues 函数

> 得到与指定键相关的一组值名

① 语法

    RegistryValues ( key, valuename )
    

② 参数

*   `key`\-->string类型，指定键名
*   `valuename`\-->字符串数组变量，用于保存值名

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1

### 九 、文件操作相关

#### 9.1 FileOpen 函数

> 以指定的读写方式打开指定的文件，同时返回该文件的句柄

① 语法

    FileOpen(filename{,filemode{,fileaccess{,filelock{,writemode,{creator,filetype}}}}})
    

② 参数

*   `filename`\-->`string`类型，指定要打开文件的名称，其中可以包含路径
    
*   `filemode`\-->`FileMode`枚举类型，可选项，指定文件打开方式
    
    *    ​ `LineMode!` - 缺省值，行模式
    *    `StreamMode!` - 流模式
*   `fileaccess`\-->`FileAccess`枚举类型，可选项，指定文件访问方式。
    
    *    `Read!` - 缺省值，只读方式，这样打开的文件只能进行读操作；
    *    `Write!` - 只写方式，这样打开的文件只能进行写操作
*   `filelock`\-->`FileLock`枚举类型，可选项，指定文件加锁方式
    
    *    `n LockReadWrite!` - 缺省值，只有打开该文件的用户能够访问该文件，其它用 户对该文件的访问均被拒
    *    `n LockRead!` - 只有打开该文件的用户能够读该文件，但其它任何用户均可写该文件
    *    `n LockWrite!` - 只有打开该文件的用户能够写该文件，但其它任何用户均可读该文件
    *    `n Shared!` - 所有用户均可读写该文件
*   `writemode`\-->`WriteMode`枚举类型，可选项
    
    *    Write! 该参数指定在指定文件已经存在时数据的添加方式
        
    *    Append! - 缺省值，将数据添加到原文件尾部
        
    *    Replace! - 覆盖原有数据
        
*   `creator`\-->可选项，用于Macintosh机，使用四个字符的字符串指定文件的创建者。指定该参数后，必须同时  
    指定`filetype`参数
    
*   `filetype`\-->可选项，用于Macintosh机，使用四个字符的字符串指定文件类型
    

③ 返回

*   返回值：`Integer`
*   成功时返回打开文件的句柄，随后的文件操作函数利用该句柄完成对文件的操作
*   发生错误时函数返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

④ 举个栗子

    int li_file_no
    string ls_getpath_data
    ls_getpath_data = "F:\xiezhr.txt"
    li_file_no = FileOpen(ls_getpath_data,LineMode!,Write!,Shared!,Append!)
    

#### 9.2 FileWrite 函数

> 向指定文件中写数据

① 语法

    FileWrite (fileno , variable )
    

② 参数

`fileno`\-->`integer`类型，指定文件句柄（由`FileOpen()`函数得到）  
`variable`\-->`string`或`blob`类型，其值将写入`fileno`参数指定的文件

③ 返回

*   返回值：`Integer`
*   成功时返回写入文件的字符或字节数，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

④ 举个栗子

    int li_file_no
    string ls_getpath_data
    string ls_writed
    string ls_err
    ls_writed = "个人公众号：XiezhrSpace"
    
    ls_getpath_data =  "F:\xiezhr.txt"
    li_file_no = FileOpen(ls_getpath_data,LineMode!,Write!,Shared!,Append!)
    
    if li_file_no = 0 then
       ls_err ="不能打开文件!" 
    	FileClose(li_file_no)
    	return -1
    else
    	if FileWrite(li_file_no, ls_writed) < 0 then		  		 
    		  ls_err = "写文件出错！"
    		  FileClose(li_file_no)
    		  return -1
    	 end if
    end if
    

#### 9.3 FileRead 函数

> 从指定文件中读取数据

① 语法

    FileRead ( fileno, variable )
    

② 参数

`fileno`\-->`integer`类型，指定文件句柄（由`FileOpen()`函数得到）  
`variable`\-->`string`或`blob`类型的变量，用于保存读取的数据

③ 返回

*   返回值：`Integer`
*   成功时返回读取的字符数或字节数；
*   如果在读取任何字符前读到了文件结束符（`EOF`），函数返回-100
*   当指定文件以行模式打开时，如果在读取任何字符之前遇到了回车（`CR`）或换行（`LF`）字符，函数返回0
*   如果发生其它错误，返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

④ 举个栗子

将xiezhr.txt 文件中的内容读取出来放到变量ls\_Input 中

    int li_FileNum
    string ls_path
    string ls_Input
    ls_path =  "F:\xiezhr.txt"
    li_FileNum = FileOpen(ls_path, LineMode!)
    FileRead(li_FileNum, ls_Input)
    

#### 9.4 FileClose 函数

> 关闭先前用FileOpen()函数打开的文件

① 语法

    FileClose ( fileno )
    

② 参数

`fileno`\-->`integer`，指定要关闭文件的文件句柄，该句柄使用`FileOpen()`函数打开文件时得到

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果`fileno`参数的值为`NULL`，函数返回`NULL`

#### 9.5 FileExists 函数

> 检查指定的文件是否存在

① 语法

    FileExists ( filename )
    

② 参数

`filename`\-->`string`类型，指定要检查存在性的文件的文件名，其中可以包含路径

③ 返回

*   返回值：`Boolean`
*   如果指定文件存在时返回`TRUE`，不存在时返回`FALSE`
*   如果`filename`参数的值为`NULL`，函数返回`NULL`

#### 9.6 FileDelete 函数

> 删除指定的文件

① 语法

    FileDelete ( filename )
    

② 参数

`filename`\-->`string`类型，指定要删除文件的文件名，其中可以包含路径

③ 返回

*   返回值：`Boolean`
*   成功时返回`TRUE`，发生错误时返回`FALSE`
*   如果filename参数的值为`NULL`，函数返回`NULL`

#### 9.7 FileLength 函数

> 得到指定文件的长度（以字节为单位）

① 语法

    FileLength ( filename )
    

② 参数

`filename`\-->`string`类型，指定要得到其长度的文件的文件名，其中可以包含路径

③ 返回

*   返回值：`Long`
*   成功时返回指定文件的长度（以字节为单位）
*   如果指定的文件不存在，函数返回-1
*   如果`filename`参数的值为`NULL`，函数返回`NULL`

#### 9.8 FileSeek 函数

> 将文件指针移动到指定位置。读写文件时相应函数会自动移动文件指针

① 语法

    FileSeek ( fileno, position, origin )
    

② 参数

*   `fileno`\-->`integer`类型，指定文件句柄（由`FileOpen()`函数得到）
*   `position`\-->`long`类型，指定相对于origin参数指定位置的新位置偏移量，以字节为单位
*   `origin`\-->`eekType`枚举类型，指定从哪里开始移动文件指针，即指针移动的基准
    *    `FromBeginning!` - 缺省值，从文件开头移动指针
    *    `FromCurrent!` \- 从当前位置移动文件指针
    *    `FromEnd!` \- 从文件结尾处移动文件指针

#### 9.9 GetFileOpenName 函数

> 显示打开文件对话框，让用户选择要打开的文件

① 语法

    GetFileOpenName(title,pathname,filename{,extension{,filter}})
    

② 参数

*   `title`\-->`string`类型，指定对话框的标题
*   `pathname`\-->`string`类型变量，用于保存该对话框返回的文件路径及文件名
*   `filename`\-->`string`类型变量，用于保存该对话框返回的文件名
*   `extension`\-->`string`类型，可选项，使用1到3个字符指定缺省的扩展文件名
*   `filter`\-->`string`类型，可选项，其值为文件名掩码，指定显示在该对话框的列表框中供用户选择的文件名满  
    足的条件（比如_._，_.TXT，_.EXE等）

③ 返回

*   返回值：`Integer`
*   成功时返回1
*   当用户单击了对话框上的“Cancel”按钮时函数返回0
*   发生错误时返回-1。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 9.10 GetFileSaveName 函数

> 显示保存文件对话框，让用户选择要保存到的文件

① 语法

    GetFileSaveName(title,pathname,filename{,extension{,filter}})
    

② 参数

`title`\-->`string`类型，指定对话框的标题  
`pathname`\-->`string`类型变量，用于保存该对话框返回的文件路径及文件名  
`filename`\-->`string`类型变量，用于保存该对话框返回的文件名  
`extension`\-->`string`类型，可选项，使用1到3个字符指定缺省的扩展文件名  
`filter`\-->`string`类型，可选项，其值为文件名掩码，指定显示在该对话框的列表框中供用户选择的文件名满  
足的条件（比如_._，_.TXT，_.EXE等）

③ 返回

*   返回值：`Integer`
*   成功时返回1
*   当用户单击了对话框上的“Cancel”按钮时函数返回0
*   发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

### 十、打印相关

#### 10.1 PrintOpen 函数

> 启动打印作业并返回作业号

① 语法

    PrintOpen ( { jobname } )
    

② 参数

`jobname`\-->`string`类型，可选项，指定要打开打印作业的名称，该名称将显示在打印管理器窗口中

③ 返回

*   返回值:`Long`
*   成功时返回打印作业号，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

注:

*   应用程序执行`PrintOpen()`函数后，启动新的打印作业并走纸到下一页，同时将打印机缺省字体设置为该打印  
    作业的字体
*   打印光标的位置位于打印区的左上角
*   使用`PrintOpen()`函数打开打印作业、使用同组的其它函数完成打印任务后，必须使用  
    `PrintClose()`关闭打印作业，或根据需要使用`PrintCancel()`函数取消打印作业

#### 10.2 PrintClose 函数

> 关闭打印作业并把打印页面发送到打印机上

① 语法

    PrintClose ( printjobnumber )
    

② 参数

`printjobnumber`\-->要关闭的打印作业的作业号

③ 返回

*   返回值:`Integer`
*   函数执行成功时返回1，发生错误时返回-1
*   如果参数`printjobnumber`的值为`NULL`，函数返回`NULL`

注意：应用程序使用`PrintOpen()`函数启动打印作业后，必须使用`PrintClose()`在完成打印任务后关闭打印作  
业，或根据需要使用`PrintCancel()`函数取消打印作业

#### 10.3 PrintCancel 函数

> 取消用PrintOpen()函数启动的打印作业

① 语法

    PrintCancel ( printjobnumber )
    

② 参数

`printjobnumber`\-->要取消的打印作业的作业号

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1。
*   如果参数`printjobnumber`的值为`NULL`，函数返回`NULL`

#### 10.4 Print 函数

> 以当前字体在打开的打印作业中打印一行或多行文本

① 语法

    Print(printjobnumber,{tab1,}string{,tab2})
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `tab1`\-->`Integer`类型，**可选项**，指定文本开始打印的位置，在开始打印字符串之前将打印光标移动到该位置，  
    从打印区的左边界开始计算，以千分之一英寸为单位。  
    如果打印光标已经位于指定位置、或打印光标已经超过了指定位置、或省略了该参数，那么，Print()函数从  
    打印光标的当前位置开始打印
*   `string`\-->`string`类型，指定要打印的字符串。如果字符串中包括回车换行字符（rn），那么该字符串将被  
    分成多行输出，但是，除第一行之外，其它行忽略tab1参数指定的起始打印位置
*   `tab2`\-->`Integer`类型，可选项，指定字符串打印结束后打印光标移动到的位置，从打印区的左边界开始计算，  
    以千分之一英寸为单位。  
    如果打印光标已经超过了指定位置，那么Print()函数忽略该参数，打印光标位于已打印字符串的尾部。如果  
    省略了该参数，Print()函数把打印光标移动到下一行的起始位置

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

④ 具体说明

*   在打印作业中，PB使用打印光标来跟踪打印位置。打印光标保存了即将打印区域左上角的坐标。
*   使用Print()函数打印文本后，PowerBuilder自动更新打印光标
*   PB使用行距来决定打印出的两行文本之间的距离，行距与字符的高度成比例，缺省的行距是字符  
    高度的1.2倍
*   使用PrintSetSpacing()函数可以改变行距
*   当Print()函数在下一行打印输出时，它把打印光标的x坐标设置为0、y坐标增加当前行距指示的数值。  
    由于每打印一行时Print()函数都自动调整打印光标的y坐标位置，因此，该函数会自动处理分页，因此，应  
    用程序没有必要调用PrintPage()函数进行分页

#### 10.5 PrintBitmap 函数

> 在打印区域的指定位置打印位图

① 语法

    PrintBitmap ( printjobnumber, bitmap, x, y, width, height )
    

② 参数

`printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号  
`bitmap`\-->`string`类型，指定要打印的位图文件的文件名  
`x`\-->`integer`类型，指定位图起始打印位置的x坐标，以千分之一英寸为单位  
`y`\-->`integer`类型，指定位图起始打印位置的y坐标，以千分之一英寸为单位  
`width`\-->`integer`类型，指定位图的打印宽度，以千分之一英寸为单位。如果该参数的值指定为0，那么按图  
像的原始宽度打印  
`height`\-->`integer`类型，指定位图的打印高度，以千分之一英寸为单位。如果该参数的值指定为0，那么按图  
像的原始高度打印

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.6 PrintDataWindow 函数

> 打印数据窗口控件的内容，用该函数可以在一个打印作业中打印多个数据窗口控件的内容，每个都从新的一页开始打印

① 语法

    PrintDataWindow ( printjobnumber, dwcontrol )
    

② 参数

`printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号  
`dwcontrol`\-->要打印其内容的数据窗口控件名或子数据窗口控件名

③ 返回

*   返回值:`Integer`
*   成功时返回1，发生错误时返回-1
*   如果参数`printjobnumber`的值为`NULL`，函数返回`NULL`

#### 10.7 PrintDefineFont 函数

> 定义打印作业使用的字体，对每个打印作业PB支持八种字体。

① 语法

    PrintDefineFont(printjobnumber,fontnumber,facename,height,weight,fontpitch,fontf
    amily, italic,underline)
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
    
*   `fontnumber`\-->指定赋给当前定义字体的编号，有效值在1到8之间
    
*   `facename`\-->`string`类型，指定字体名称，该字体应该是你的打印机支持的字体，比如“宋体”
    
*   `height`\-->`Integer`类型，使用正值指定字体的高度，以千分之一英寸为单位；使用负值指定字体点数，比  
    如，-18代表18点。一般来说，使用点数更精确些
    
*   `weight`：指定字体的磅数，正常字体为400磅，粗体为700磅
    
*   `fontpitch`：`FontPitch`枚举类型，指定字体标准
    
    *    Default! - 缺省值
    *    Fixed! - 固定形式
    *    Variable! - 可变形式
*   `fontfamily`：FontFamily枚举类型，指定字体系列
    
    *    AnyFont!
    *    Decorative!
    *    Modern!
    *    Roman!
    *    Script!
    *    Swiss!
*   `italic`：`boolean`类型，指定是否使用斜体样式。有效取值为：
    
    *    TRUE - 使用斜体样式
    *    FALSE - 不使用斜体样式 缺省值为FALSE

`underline`\-->`boolean`类型，指定是否加下划线。

*    TRUE - 加下划线；
*    FALSE - 不加下划线 缺省值为FALSE

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.8 PrintLine 函数

> 在当前打印页上绘出指定厚度的一条线

① 语法

    PrintLine ( printjobnumber, x1, y1, x2, y2, thickness )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `x1`\-->`integer`类型，指定直线起点的x坐标，以千分之一英寸为单位
*   `y1`\-->`integer`类型，指定直线起点的y坐标，以千分之一英寸为单位
*   `x2`\-->`integer`类型，指定直线终点的x坐标，以千分之一英寸为单位
*   `y2`\-->`integer`类型，指定直线终点的y坐标，以千分之一英寸为单位
*   `thickness`\-->`integer`类型，指定直线的厚度，以千分之一英寸为单位

③ 返回

*   返回值：Integer。
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.9 PrintOval 函数

> 在指定位置以指定线宽绘制椭圆或圆

① 语法

    PrintOval ( printjobnumber, x, y, width, height, thickness )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `x1`\-->`integer`类型，指定直线起点的x坐标，以千分之一英寸为单位
*   `y1`\-->`integer`类型，指定直线起点的y坐标，以千分之一英寸为单位
*   `x2`\-->`integer`类型，指定直线终点的x坐标，以千分之一英寸为单位
*   `y2`\-->`integer`类型，指定直线终点的y坐标，以千分之一英寸为单位
*   `thickness`\-->`integer`类型，指定直线的厚度，以千分之一英寸为单位

③ 返回

*   返回值：Integer。
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.10 PrintPage 函数

> 将当前页发送给打印机或打印池并在当前打印作业中启动一个新的打印页

① 语法

    PrintPage ( printjobnumber )
    

② 参数

`printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.11 PrintRect 函数

> 在指定位置以指定线宽打印矩形

① 语法

    PrintRect ( printjobnumber, x, y, width, height, thickness )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `x1`\-->`integer`类型，指定直线起点的x坐标，以千分之一英寸为单位
*   `y1`\-->`integer`类型，指定直线起点的y坐标，以千分之一英寸为单位
*   `x2`\-->`integer`类型，指定直线终点的x坐标，以千分之一英寸为单位
*   `y2`\-->`integer`类型，指定直线终点的y坐标，以千分之一英寸为单位
*   `thickness`\-->`integer`类型，指定直线的厚度，以千分之一英寸为单位

③ 返回

*   返回值：Integer。
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.12 PrintRoundRect 函数

> 在指定位置以指定线宽打印圆角矩形

① 语法

    PrintRoundRect(printjobnumber,x,y,width,height,xradius,yradius,thickness)
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `x`\-->`integer`类型，指定圆角矩形左上角的x坐标，以千分之一英寸为单位
*   `y`\-->`integer`类型，指定圆角矩形左上角的y坐标，以千分之一英寸为单位
*   `width`\-->`integer`类型，指定圆角矩形的宽度，以千分之一英寸为单位
*   `height`\-->`integer`类型，指定圆角矩形的高度，以千分之一英寸为单位
*   `xradius`\-->`integer`类型，指定圆角矩形圆角部分的x半径，以千分之一英寸为单位
*   `yradius`\-->`integer`类型，指定圆角矩形圆角部分的y半径，以千分之一英寸为单位
*   `thickness`\-->`integer`类型，指定圆角矩形边线的厚度，以千分之一英寸为单位

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.13 PrintScreen 函数

> 在打印作业中打印屏幕图像

① 语法

    PrintScreen ( printjobnumber, x, y {, width, height } )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `x`\-->`integer`类型，指定要打印屏幕图像左上角在打印页上的x坐标，以千分之一英寸为单位
*   `y`\-->`integer`类型，指定要打印屏幕图像左上角在打印页上的y坐标，以千分之一英寸为单位
*   `width`\-->`integer`类型，可选项，指定屏幕图像的打印宽度，以千分之一英寸为单位。如果省略了该参数，那  
    么PB按屏幕的原始宽度打印屏幕图像。如果指定了该参数，必须同时指定height参数
*   `height`\-->`integer`类型，可选项，指定屏幕图像的打印高度，以千分之一英寸为单位。如果省略了该参数，  
    那么PB按屏幕的原始高度打印屏幕图像

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.14 PrintSend 函数

> 直接向打印机发送任意字符串，通常用于发送打印机的控制代码

① 语法

    PrintSend ( printjobnumber, string {, zerochar } )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `string`\-->`string`类型，指定发送到打印机的字符串。在该字符串中，使用非打印字符的ASCII码值表示非打  
    印字符
*   `zerochar`\-->`integer`类型，可选项，指定在string参数中用于表示数值0的ASCII码值。有效取值在1到255  
    之间

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.15 PrintSetFont 函数

> 设置当前打印作业使用的字体

① 语法

    PrintSetFont ( printjobnumber, fontnumber )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `fontnumber`\-->指定该打印作业使用字体的字体编号，该编号与`PrintDefineFont()`函数中定义的编号应该  
    对应，字体编号的有效取值在1到8之间，0表示使用打印机的缺省字体

③ 返回

*   返回值：`Integer`
*   成功时返回当前字体的高度，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.16 PrintSetSpacing 函数

> 设置行间距因子，打印函数将使用该因子来决定行间距

① 语法

    PrintSetSpacing ( printjobnumber, spacingfactor )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `spacingfactor`\-->指定行间距因子，用字符高度的倍数表示，缺省值为1.2

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.17 PrintSetup 函数

> 打开打印机设置对话框

① 语法

    PrintSetup ( )
    

② 参数

无

③ 返回

*   返回值：Integer
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.18 PrintText

> 在指定位置打印一行文本

① 语法

    PrintText ( printjobnumber, string, x, y {, fontnumber } )
    

② 参数

*   `printjobnumber`**\-->**用`PrintOpen()`函数打开的打印作业号
*   `string`\-->`string`类型，指定要打印的文本
*   `x`\-->`integer`类型，指定文本开始打印位置的x坐标，以千分之一英寸为单位
*   `y`\-->`integer`类型，指定文本开始打印位置的y坐标，以千分之一英寸为单位
*   `fontnumber`\-->可选参数，指定打印文本使用的字体号，该编号由`PrintDefineFont()`函数确定。省略该参  
    数时，以打印作业的当前字体打印文本

③ 返回

*   返回值：`Integer`
*   成功时返回文本打印后打印光标的x位置，即参数x的值加上打印文本的宽度
*   发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.19 PrintWidth

> 确定一个字符串在指定打印作业中按当前字体所占的宽度，以千分之一英寸为单位

① 语法

    PrintWidth ( printjobnumber, string )
    

② 参数

*   `printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号
*   `string`\-->`string`类型，指定要决定其打印宽度的字符串

③ 返回

*   返回值：`Integer`
*   成功时返回按当前字体计算的字符串打印宽度，以千分之一英寸为单位，发生错误时返回-1。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.20 PrintX 函数

> 返回打印光标的x坐标位置

① 语法

    PrintX ( printjobnumber )
    

② 参数

`printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号

③ 返回

*   返回值：`Integer`
*   成功时返回打印光标的x坐标位置，以千分之一英寸为单位，发生错误时返回-1。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 10.21 PrintY 函数

> 返回打印光标的y坐标位置

① 语法

    PrintY ( printjobnumber )
    

② 参数

`printjobnumber`\-->用`PrintOpen()`函数打开的打印作业号

③ 返回

*   返回值：`Integer`
*   成功时返回打印光标的y坐标位置，以千分之一英寸为单位，发生错误时返回-1。
*   如果任何参数的值为`NULL`，函数返回`NULL`

### 十一、系统与环境相关

#### 11.1 Yield 函数

> 功能将控制权转移给其它图形对象，包括非PB对象。该函数检测消息队列，如果有消息，就把消  
> 息取出。利用该函数可以在执行耗时较长的操作时把控制权转让给其它应用。

① 语法

    Yield()
    

② 参数

无

③ 返回

*   返回值：`Boolean`
*   如果在消息队列中提取到了消息，那么函数返回`TRUE`，否则返回`FALSE`

④ 使用说明

> 正常情况下，PowerBuilder应用程序在执行一段代码（比如函数或事件处理程序）的过程中不响应用户的操  
> 作。  
> 对耗时短暂的代码段来说，这种处理方式没有什么不妥的地方  
> 但是，如果某个代码段的执行耗时较长，应用程序又希望为用户提供更多的控制权，那么需要在这段代码中插  
> 入Yield()函数，让用户能够进行其它操作，特别在循环执行的代码中更应该如此。  
> 应用程序执行Yield()函数后，如果发现消息队列中存在消息，它将允许对象处理这些消息，处理之后，继续  
> Yield()函数后面代码的执行。  
> 因此，代码中插入Yield()函数将降低应用程序的运行效率

#### 11.2 Clipboard 函数

> 提取或替换Windows系统剪贴板的文本内容。

① 语法

    Clipboard ( { string } )
    

② 参数

`string`\-->`string`类型，可选项，指定要复制到系统剪贴板上的文本。  
如果剪贴板上已有内容的话，该文本将取代剪贴板的当前内容

③ 返回

*   返回值：`String`
*   行成功时，如果剪贴板上包含文本数据，那么函数返回剪贴板的当前内容
*   如果剪贴板上包含非文本数据（比如位图）或不包含任何数据，那么函数返回空字符串""
*   如果string参数的值为`NULL`，返回NULL
*   用法无论是否指定string参数，将返回剪贴板的当前内容
*   当指定`string`参数时，剪贴板的原有内容被`string`参数的值取代；
*   省略string参数时，仅仅得到剪贴板的内容

#### 11.3 CommandParm 函数

> 得到应用程序运行时指定的命令参数

① 语法

    CommandParm()
    

② 参数

无

③ 返回

*   返回值：`String`
*   成功时返回应用程序运行时的命令行参数，
*   函数执行错误或没有命令行参数时函数返回空字符串""

#### 11.4 DoScript 函数

> 执行AppleScript程序段，该函数只在Macintosh平台上有效

① 语法

    DoScript ( script, result )
    

② 参数

*   `script`\-->`string`类型，指定要运行的程序段（script）
*   `result`\-->`string`类型，由`AppleScript`程序段返回的结果信息或出错信息

③ 返回

*   返回值：`Integer`
*   返回由`AppleScript`返回的结果代码。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 11.5 GetApplication 函数

> 得到当前应用对象的句柄，这样你可以查询或设置应用对象的属性（通常用于编写通用代码）

① 语法

    GetApplication ( )
    

② 参数

无

③ 返回

*   返回值：`Application`
*   返回当前应用对象的句柄

#### 11.6 GetEnvironment 函数

> 得到操作系统、处理器、屏幕显示等与系统相关的信息

① 语法

    GetEnvironment ( environmentinfo )
    

② 参数

`environmentinfo`\-->`Environment`对象名，用于保存系统环境信息

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1
*   如果参数`environmentinfo`的值为`NULL`，函数返回`NULL`

#### 11.7 GetFocus 函数

> 确定当前焦点位于哪个控件上

① 语法

    GetFocus ( )
    

② 参数

无

③ 返回

*   返回值：`GraphicObject`
*   成功时返回当前得到焦点控件的引用，发生错误时返回无效引用

#### 11.8 Post 函数

> 将指定消息加入到某个窗口的消息队列中，这个窗口既可以是PowerBuilder应用的窗口，也可以是其它应用  
> 的窗口

① 语法

    Post( handle, messageno, word, long )  
    

② 参数

*   `handle`\-->`long`类型，指定窗口的系统句柄，将向该窗口邮寄消息
*   `messageno`\-->`UnsignedInteger`类型，指定要邮寄的消息号
*   `word`\-->`long`类型，指定与消息一起邮寄的word类参数值。如果messageno参数指定的消息不使用该参数，那  
    么将这个参数的值设置为0
*   `long`\-->`long`类型或string，指定与消息一起邮寄的long型参数值或字符串

③ 返回

*   返回值：`Boolean`
*   如果任何参数的值为`NUL`L，函数返回`NULL`

#### 11.9 Restart 函数

> 停止所有程序段的执行、关闭所有窗口、提交事务、断开与数据库的连接，然后重新启动应用程序

① 语法

    Restart()
    

② 参数

无

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1

#### 11.10 Run 函数

> 运行指定的应用程序

① 语法

    Run ( string {, windowstate } )
    

② 参数

*   `string`\-->`string`类型，指定要运行的应用程序的名称，其中可以包括路径以及相应的参数，就像在命令行中  
    键入的那样
*   `windowstate`\-->`WindowState`枚举类型，可选项，指定程序运行时的窗口状态
    *    Maximized! - 最大化窗口
    *    Minimized! - 最小化窗口
    *    Normal! - 缺省值，正常窗口

③ 返回

*   返回值:`Integer`
*   成功时返回1，发生错误时返回-1
*   如果任何参数的值为`NULL`，返回NULL

④ 使用说明

*   用Run()函数，应用程序能够启动操作系统中的任何程序。
*   当在Run()参数中指定了要启动应用程序的参数时，参数的意义、格式、个数等由具体的应用程序确定。
*   如果在Run()函数的string参数中指定了文件名但没有给出扩展名时，PowerBuilder认为该文件的扩展名  
    为.EXE。
*   要运行扩展名不是.EXE的应用程序（比如.BAT, .COM, 或.PIF），必须在Run()函数的参数中指定文件的  
    扩展名

#### 11.11 Send 函数

> 向窗口发送指定的消息并立即执行相应的事件处理程序

① 语法

    Send( handle, messageno, word, long )
    

② 参数

*   `handle`：`long`类型，指定窗口的系统句柄，将向该窗口发送消息
*   `messageno`：`UnsignedInteger`类型，指定要发送的消息号
*   `word`：`long`类型，指定与消息一起发送的word类参数值。如果`messageno`参数指定的消息不使用该参数，那  
    么将这个参数的值设置为0
*   `long`：`long`类型或string，指定与消息一起发送的long型参数值或字符串

③ 返回

*   返回值：`Long`
*   成功时返回Windows系统调用`SendMessage()`的返回值，发生错误时返回-1
*   如果任何参数的值为`NULL`，函数返回`NULL`

④ 使用说明

> Send()函数用于向窗口发送非PB预定义事件的消息，这个窗口可以是PB应用的窗口，也可以是其它应用的窗口
> 
> Send()函数直接触发指定窗口相应的事件，执行事件处理程序后返回到调用应用中，这一点与Post()函数不  
> 同，Post()函数把发送的消息放置在指定窗口消息队列的尾部，然后返回到应用程序中，它并不等待相应事件  
> 事件处理程序的执行。
> 
> 因此，我们说Post()函数采用的是异步方式，Send()函数采用的是同步方式。  
> Send()函数的参数handle指定接收消息的窗口句柄，对PowerBuilder窗口来说，使用Handle()函数可以得到该句柄。
> 
> 对其它应用程序的窗口来说，可以调用系统API函数查找窗口并得到相应窗口的句柄。
> 
> 实际上，Send()函数把它的各个参数直接传送给Windows的系统调用SendMessage()。
> 
> 在各种C++开发工具的WINDOWS.H文件中可以查到各消息编号。
> 
> 如果应用程序要发送PowerBuilder定义事件（包括预定义事件和用户定义事件），那么使用TriggerEvent()函数既简单有方便。
> 
> 当应用程序在long参数位置指定一个字符串时，Send()函数复制一个该字符串的副本，然后将副本的地址传  
> 送给指定窗口

#### 11.12 ShowHelp 函数

> 显示应用程序帮助，该帮助使用Microsoft Windows帮助系统进行操作

① 语法

    ShowHelp ( helpfile, helpcommand {, typeid } )
    

② 参数

*   `helpfile`\-->`string`类型，指定帮助文件的名称
*   `helpcommand`\-->`HelpCommand`枚举类型，指定显示帮助的格式
*   `typeid`参数
    *    Keyword! - 转移到由指定关键字确定的主题
    *    Topic! - 显示指定主题的帮助
    *    typeid：可选项，指定帮助主题

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1。
*   如果任何参数的值为`NULL`，函数返回`NULL`

#### 11.13 SignalError 函数

> 触发应用对象的SystemError事件，通常用于代码调试

① 语法

    SignalError ( { number }, { text } )
    

② 参数

*   `number`\-->`integer`类型，可选项，其值将保存到Error对象的number属性中
*   `text`\-->`string`类型，可选项，其值将保存到Error对象的text属性中

③ 返回

*   返回值：`Integer`
*   成功时返回1，发生错误时返回-1

### 十二、通用功能函数封装

#### 12.1 根据SQL创建DataStore

①定义函数

    /*
    \>====================================================================
    \> function:gf_createDataStore
    \>--------------------------------------------------------------------
    \> 描述: 根据SQL创建DataStore
    \>--------------------------------------------------------------------
    \> 参数:
    \> String 类型  sql语句
    \>--------------------------------------------------------------------
    \> 返回: 
    \>  DataStore类型 (函数执行成功返回DataStore)
    \>  Integer 类型  (函数执行成功数据的总行数)
    \>  String 类型  (函数执行失败时返回错误信息)
    \>====================================================================
    */
    String ls_DwSyntax     //创建数据存储的语法
    String ls_Errors       //错误信息
    String ls_FunName      //函数名称
    
    ls_FunName = '~r~nCreateDataStore()-'	 
    
    //创建数据存储语法
    ls_DwSyntax = SQLCA.SyntaxFromSQL(as_SqlSelect, 'Style(Type=Grid)',ls_Errors)
    If Len(ls_Errors) > 0 Then
    	as_ErrInfo = ls_FunName + '不能返回数据窗语法,错误信息:'   + ls_Errors
    	Return -1
    End If
    
    ads_DataStore.Create(ls_DwSyntax,ls_Errors)
    If Len(ls_Errors) > 0 Then
    	as_ErrInfo = ls_FunName + '不能创建数据存储对象,错误信息:' + ls_Errors
    	Return -1
    End If
    
    //检索数据
    ads_DataStore.SetTransObject(SQLCA)
    ai_RowCount = ads_DataStore.Retrieve()
    
    If ai_RowCount < 0 Then
    	as_ErrInfo = ls_FunName + '数据存储检索错误!'
    	Return -1
    End If
    
    as_ErrInfo = ''
    Return 1
    

② 调用函数

    int li_count
    string ls_sql
    string ls_err
    DataStore lds_Info
    
    ls_sql = "select empno, ename, job, mgr, hiredate, sal, comm, deptno from emp where empno = '7369' "
    lds_Info = Create DataStore
    If gf_createDataStore(lds_RecipeInfo,ls_sql,li_count,ls_err) = -1 Then
    	goto Err
    End If
    return
    Err:
    messagebox('提示信息',ls_err)
    

#### 12.2 获取exe名称

① 引用动态库，定义外部函数

    FUNCTION ulong GetModuleFileName(ulong hModule,ref string lpFileName,ulong
    nSize) LIBRARY "kernel32.dll" ALIAS FOR "GetModuleFileNameA"
    

② 定义函数

    /*
    \>====================================================================
    \> function:gf_file_getexe
    \>--------------------------------------------------------------------
    \> 描述: 获取exe名称
    \>--------------------------------------------------------------------
    \> 参数:
    \> showexesuffix:integer类型 (0、不显示exe后缀,1、显示exe后缀)
    \>--------------------------------------------------------------------
    \> 返回: string类型 (函数执行成功返回exe的名称)
    \>====================================================================
    */
    string str_temp,separator
    string str_list[]
    integer i = 1,ll_pos,ll_max
    string ls_fileName
    GetModuleFileName(handle(this),ls_fileName,100)
    separator = '\'
    ll_pos = pos(ls_fileName,separator,1)
    do
    	if ll_pos = 0 then
    		str_list[i] = ls_fileName
    	else
    		str_list[i] = left(ls_fileName,ll_pos - 1)
    		i ++
    		ls_fileName = mid(ls_fileName,ll_pos + len(separator))
    		ll_pos = pos(ls_fileName,separator,1)
    		if ll_pos = 0 then str_list[i] = ls_fileName
    	end if
    loop while ll_pos <> 0
    	ll_max = upperbound(str_list)
    	if showexesuffix = 1 then
    		return mid(str_list[ll_max],1,pos(str_list[ll_max],'.') - 1)
    	else
    		return str_list[ll_max]
    	end if
    

③ 调用函数

    string ls_exe
    ls_exe = gf_get_exe(0) //不显示exe后缀
    ls_exe = gf_get_exe(1) //显示exe后缀
    

#### 12.3 文件写入

① 定义函数

    /*
    \>==================================================================
    \> Function: gf_file_write
    \>--------------------------------------------------------------------
    \> 描述: 文件写入
    \>--------------------------------------------------------------------
    \> 参数:
    \> string fileway (打开文件的方式)
    \> string filepath (要写入的文件路径和文件名称)
    \> string filecontent (要写入的内容)
    \>--------------------------------------------------------------------
    \> 返回: integer (0:成功,-1:失败。)
    ====================================================================
    */
    long ll_file,ll_FLength,ll_i,ll_count
    string ls_content
    choose case fileway
    	case 'w'
    		//流模式、写入、所有用户均可读写该文件、覆盖
    		ll_file = fileopen(filepath,streamMode!,Write!,Shared!,Replace!)
    	case 'w+'
    		//流模式、写入、所有用户均可读写该文件、追加
    		ll_file = fileopen(filepath,streamMode!,Write!,Shared!,append!)
    	case 'wl'
    		//行模式、写入、所有用户均可读写该文件、覆盖
    		ll_file = fileopen(filepath,LineMode!,Write!,Shared!,Replace!)
    	case 'wl+'
    		//行模式、写入、所有用户均可读写该文件、追加
    		ll_file = fileopen(filepath,LineMode!,Write!,Shared!,append!)
    	case else
    		messagebox('提示','gf_file_write:传入的参数错误!')
    		return - 1
    end choose
    IF ll_file > 0 THEN
        ll_FLength = len(filecontent)
    	if ll_FLength > 32765 then
    		if mod(ll_FLength,32765) = 0 then
    			ll_count = ll_FLength / 32765
    		else
    			ll_count = ll_FLength / 32765 + 1
    		end if
    	else
    		ll_count = 1
    	end if
    	for ll_i = 1 to ll_count
    		ls_content = left(filecontent,32765)
    		FileWrite(ll_file,ls_content)
    		filecontent = right(filecontent,len(filecontent) - 32765)
    	next
    	FileClose(ll_file)
    else
    	messagebox('提示','gf_file_write:文件打开失败!')
    	return - 1
    end if
    return 0
        
    

② 调用函数

    gf_file_write('w',getcurrentdirectory() + '\1.txt','流模式覆盖')
    gf_file_write('w+',getcurrentdirectory() + '\1.txt','流模式追加')
    gf_file_write('wl',getcurrentdirectory() + '\1.txt','行模式覆盖')
    gf_file_write('wl+',getcurrentdirectory() + '\1.txt','行模式追加')
    

#### 12.4 文件读取

① 函数定义

    /*
    \>====================================================================
    \> Function: gf_file_read
    \>--------------------------------------------------------------------
    \> 描述: 文件读取
    \>--------------------------------------------------------------------
    \> 参数:
    \> string fileway (打开文件的方式)
    \> string filepath (要读取的文件路径和文件名称)
    \> ref string filecontent[] (要返回的内容)
    \>--------------------------------------------------------------------
    \> 返回: integer (0:成功,-1:失败。)
    \>====================================================================
    */
    
    long ll_file,ll_FLength,ll_i,ll_j,ll_count
    string ls_content
    choose case fileway
    	case 'r'
    		//流模式、读取、所有用户均可读写该文件
    		ll_file = fileopen(filepath,streamMode!,Read!,Shared!)
    		IF ll_file > 0 THEN
    			ll_FLength = len(filepath)
    			if ll_FLength > 32765 then
                	if mod(ll_FLength,32765) = 0 then
    					ll_count = ll_FLength / 32765
    				else
    					ll_count = ll_FLength / 32765 + 1
    				end if
    			else
    				ll_count = 1
    			end if
    			for ll_i = 1 to ll_count
    				FileRead(ll_file,ls_content)
    				filecontent[1] += ls_content
    			next
    		else
    			messagebox('提示','gf_file_read:文件打开失败!')
    			return - 1
    		end if
        case 'rl'
    		//行模式、读取、所有用户均可读写该文件
    		ll_file = fileopen(filepath,LineMode!,Read!,Shared!)
    		IF ll_file > 0 THEN
    			ll_j = 1
    			ll_i = FileRead(ll_file,filecontent[ll_j])
    			do until string(ll_i) = '-100'
    				ll_j = ll_j + 1
    				ll_i = FileRead(ll_file,filecontent[ll_j])
    			loop
    				FileClose(ll_file)
    		else
    			messagebox('提示','gf_file_read:文件打开失败!')
    			return - 1
    		end if
    case else
    	messagebox('提示','gf_file_read:传入的参数错误')
    	return - 1
    end choose
    return 0
    

② 调用函数

    （1）、以流模式读取文件
    string ls_data[]
    gf_file_read('r',getcurrentdirectory() + '\1.txt',ls_data[] )
    messagebox('流模式返回值',ls_data[1])
    （2）、以行模式读取文件
    string ls_data[]
    gf_file_read('rl',getcurrentdirectory() + '\1.txt',ls_data[] )
    messagebox('行模式返回值',ls_data[1])
    messagebox('行模式返回值',ls_data[2])
    messagebox('行模式返回值',ls_data[3])
    

#### 12.5 字符串切割

① 定义函数

    /*
    \>====================================================================
    \> function: gf_string_cut.
    \>--------------------------------------------------------------------
    \> 描述: 字符串切割
    \>--------------------------------------------------------------------
    \> 参数:
    \> way:string (可选参数：array:将字符串分割并返回一个数组。string:将字符串分割并返回一个
    字符串)
    \> data:string (要进行分割的字符串数据)
    \> conditions:string (字符串分割的条件)
    \> value[] (字符串分割后的值)
    \>--------------------------------------------------------------------
    \> 返回: integer (0:成功,-1:失败。)
    \>====================================================================
    */
        
    long ll_empty_pos,i = 1
    string ls_value_string,ls_value_array[]
    choose case way
    	case 'array'
    		ll_empty_pos = pos(data,conditions)
    		if ll_empty_pos > 0 then
    			do
    				ls_value_array[i] = trim(mid(data,1,ll_empty_pos - 1))
    				data = trim(mid(data,ll_empty_pos + 1))
    				ll_empty_pos = pos(data,conditions)
    				i++
    				if ll_empty_pos = 0 then
    					ls_value_array[i] = trim(mid(data,0))
    				end if
    			loop while ll_empty_pos > 0
    				value[] = ls_value_array[]
    		else
    			messagebox('提示','gf_string_cut传入的字符串未找到!')
    			return - 1
    		end if
    	case 'string'
    		ll_empty_pos = pos(data,conditions)
    		if ll_empty_pos > 0 then
    			do
    				ls_value_string += trim(mid(data,1,ll_empty_pos - 1))
    				data = trim(mid(data,ll_empty_pos + 1))
    				ll_empty_pos = pos(data,conditions)
    				if ll_empty_pos = 0 then
    					ls_value_string += trim(mid(data,0))
    				end if
    			loop while ll_empty_pos > 0
    			value[1] = ls_value_string
    		else
    			messagebox('提示','gf_string_cut传入的字符串未找到!')
    			return - 1
    		end if
    case else
    	 messagebox('提示','gf_string_cut传入的参数错误!')
    	return - 1
    end choose
    return 0
    

② 调用函数

    string ls_data,ls_value[]
    ls_data = '123,456,789'
    //1、切割字符串，并返回切割后的字符串
    gf_string_cut('string',ls_data,',',ls_value[])
    messagebox('',ls_value[1]) //123456789
    //2、切割字符串，并返回数组
    gf_string_cut('array',ls_data,',',ls_value[])
    messagebox('',ls_value[1]) //123
    messagebox('',ls_value[2]) //456
    messagebox('',ls_value[3]) //789
    

#### 12.6 字符串替换

① 定义函数

    /*
    \>====================================================================
    \> function:gf_string_replace
    \>--------------------------------------------------------------------
    \> 描述: 字符串替换
    \>--------------------------------------------------------------------
    // 参数:
    // string data 字符串数据
    // string as_old 将要替换的字符
    // string as_new 要替换的新值
    \>--------------------------------------------------------------------
    \> 返回: string 替换后的字符
    \>====================================================================
    */
    long ll_oldlen, ll_newlen, ll_pos
    ll_pos = Pos(data,as_old)
    IF ll_pos > 0 Then
    	ll_oldlen = Len(as_old)
    	ll_newlen = Len(as_new)
    	DO WHILE ll_pos > 0
    		data = Replace(data,ll_pos,ll_oldlen,as_new)
    		ll_pos = Pos(data,as_old,ll_pos + ll_newlen)
    	LOOP
    END IF
    RETURN data
    

② 调用函数

    string ls_data
    ls_data = gf_string_replace('1234561','1','6')
    messagebox('返回值',ls_data) //6234566
    

#### 12.7 大文件写入（二进制数据流）

① 函数定义

    /*
    \>====================================================================
    \> function: gf_adodb_blob_write.
    \>--------------------------------------------------------------------
    \> 描述:大文件写入（二进制数据流）
    \>--------------------------------------------------------------------
    \> 参数:
    \> string filepath (要写入的文件路径和文件名称)
    \> blob filecontent (要写入的二进制数据文件内容)
    \>--------------------------------------------------------------------
    \> 返回:integer (0:成功,-1:失败。)
    \>====================================================================
    */
    long li_rtn,ll_file
    string ls_data
    OLEObject ADODB
    ADODB = CREATE OLEObject
    li_rtn = ADODB.ConnectToNewObject("ADODB.Stream")
    if li_rtn = 0 then
        ADODB.Type = 1 //设置ADODB类型（1、二进制数据，2、文本数据）
        ADODB.Mode = 3 //设置读写模式（1、读，2、写，3、读写）
        ADODB.open() //打开ADODB
        ADODB.Position = 0 //Position=0才能设置Charset
        ADODB.Write(filecontent) //Write 和 WriteText 方法向 Stream 中输入字节或文本。
        ADODB.savetofile(filepath,2) //savetofile(1、只写入1次。2、可覆盖写入多次)
        ADODB.flush() //清空缓冲区数据
        ADODB.Close() //关闭流
        destroy ADODB
    else
    	messagebox('提示', '无法连接【ADODB.Stream】!~r~n读取文件失败!')
    	return - 1
    end if
    return 0
    

② 调用函数

    gf_adodb_blob_write(getcurrentdirectory()+'\a.txt',blob('123'))
    

#### 12.8 大文件读取（二进制数据流）

① 函数定义

    /*
    \>====================================================================
    \> function: gf_adodb_blob_read.
    \>--------------------------------------------------------------------
    \> 描述: 大文件读取（二进制数据流）
    \>--------------------------------------------------------------------
    \> 参数:
    \> string filepath (要读取的文件路径和文件名称)
    \>--------------------------------------------------------------------
    \> 返回: blob (从文件中读取到的blob数据)
    \>====================================================================
    */
    long li_rtn
    blob lb_data
    OLEObject ADODB
    ADODB = CREATE OLEObject
    li_rtn = ADODB.ConnectToNewObject("ADODB.Stream")
    if li_rtn = 0 then
        ADODB.Type = 1 //设置ADODB类型（1、二进制数据，2、文本数据）
        ADODB.Mode = 3 //设置读写模式（1、读，2、写，3、读写）
        ADODB.Open() //打开ADODB
        ADODB.LoadFromFile(filepath) //加载文件
        ADODB.Position = 0 //Position=0才能设置Charset
        lb_data = ADODB.Read() //Read 和 ReadText 方法向 Stream 中读取字节或文本。
        ADODB.flush() //清空缓冲区数据
        ADODB.Close() //关闭流
        destroy ADODB
    else
    	messagebox('提示', '无法连接【ADODB.Stream】!~r~n读取文件失败!')
    end if
    return lb_data
    

② 函数调用

    blob lb_data
    lb_data = gf_adodb_blob_read(getcurrentdirectory()+'\a.txt')
    messagebox('blob',string(lb_data))
    

#### 12.9 大文件写入（文本流）

① 函数定义

    /*
    \>====================================================================
    \> function: gf_adodb_string_write.
    \>--------------------------------------------------------------------
    \> 描述:大文件写入（文本流）
    \>--------------------------------------------------------------------
    \> 参数:
    \> string filepath (要写入的文件路径和文件名称)
    \> string filecontent (要写入的文本流内容)
    \>--------------------------------------------------------------------
    \> 返回:integer (0:成功,-1:失败。)
    \>====================================================================
    */
    long li_rtn,ll_file
    string ls_data
    OLEObject ADODB
    ADODB = CREATE OLEObject
    li_rtn = ADODB.ConnectToNewObject("ADODB.Stream")
    if li_rtn = 0 then
        ADODB.Type = 2 //设置ADODB类型（1、二进制数据，2、文本数据）
        ADODB.Mode = 3 //设置读写模式（1、读，2、写，3、读写）
        ADODB.open() //打开ADODB
        ADODB.Position = 0 //Position=0才能设置Charset
        ADODB.WriteText(filecontent) //Write 和 WriteText 方法向 Stream 中输入字节或文本。
        ADODB.savetofile(filepath,2) //savetofile(1、只写入1次。2、可覆盖写入多次)
        ADODB.flush() //清空缓冲区数据
        ADODB.Close() //关闭流
        destroy ADODB
    else
    	messagebox('提示', '无法连接【ADODB.Stream】!~r~n读取文件失败!')
    	return - 1
    end if
    return 0
    

② 函数调用

    gf_adodb_string_write(getcurrentdirectory()+'\a.txt','123')
    

#### 12.10 大文件读取（文本流）

① 函数定义

    /*
    \>====================================================================
    \> function: gf_adodb_string_read.
    \>--------------------------------------------------------------------
    \> 描述: 大文件读取（文本流）
    \>--------------------------------------------------------------------
    \> 参数:
    \> string filepath (要读取的文件路径和文件名称)
    \>--------------------------------------------------------------------
    \> 返回: string (从文件中读取到的blob数据)
    \>====================================================================
    */
    long li_rtn
    string ls_data
    OLEObject ADODB
    ADODB = CREATE OLEObject
    li_rtn = ADODB.ConnectToNewObject("ADODB.Stream")
    if li_rtn = 0 then
        ADODB.Type = 2 //设置ADODB类型（1、二进制数据，2、文本数据）
        ADODB.Mode = 3 //设置读写模式（1、读，2、写，3、读写）
        ADODB.Open() //打开ADODB
        ADODB.LoadFromFile(filepath) //加载文件
        ADODB.Position = 0 //Position= 0才能设置Charset
        ls_data = ADODB.ReadText() //Read 和 ReadText 方法向 Stream 中读取字节或文本。
        ADODB.flush() //清空缓冲区数据
        ADODB.Close() //关闭流
        destroy ADODB
    else
    	messagebox('提示', '无法连接【ADODB.Stream】!~r~n读取文件失败!')
    end if
    return ls_data
    

② 函数调用

    string ls_data
    ls_data = gf_adodb_string_read(getcurrentdirectory()+'\a.txt')
    messagebox('string',ls_data)
    

#### 12.11 移除字符串中的字母

① 函数定义

    /*
    \>====================================================================
    \> Function: gf_remove_letter
    \>--------------------------------------------------------------------
    \> 描述: 移除字符串中的字母
    \>--------------------------------------------------------------------
    \> 参数:
    \> string ls_data 要去除字母的字符串
    \>--------------------------------------------------------------------
    \> 返回: string
    \>====================================================================
    */
    string str = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    string ls_data_new
    long i
    if ls_data = '' or isnull(ls_data) then
    	ls_data_new = ''
    else
    	for i = 1 to len(ls_data)
    	if pos(str,mid(ls_data,i,1)) = 0 then
    		ls_data_new += mid(ls_data,i,1)
    	end if
    	next
    end if
    return ls_data_new
    

② 函数调用

    gf_remove_letter('12abc3sdfsg4')
    

#### 12.12 获取上个月初到月底的时间

① 函数定义

    /*
    >====================================================================
    > Function: gf_last_month
    >--------------------------------------------------------------------
    > 描述: 获取上个月初到月底的时间
    >--------------------------------------------------------------------
    > 参数:
    > ref string lrt_start
    > ref string lrt_end
    >--------------------------------------------------------------------
    > 返回值: (none)
    >====================================================================
    */
    string ls_by2
    string ls_by,ls_sy
    ls_by2 = mid(string(date(today())),1,7) + '-01'
    ls_by = string(RelativeDate(date(ls_by2), - 1))
    ls_sy = string(Year(date(ls_by2))) + '-' + string(Month(date(ls_by2)) - 1) +
    '-01'
    lrt_start = ls_sy + ' 00:00:00'
    lrt_end = ls_by + ' 23:59:59'    
    

② 函数调用

    //调用示例
    string ls_start,ls_end
    of_last_month(ls_start,ls_end)
    messagebox('月初的（日期+时间）',ls_start)
    messagebox('月底的（日期+时间）',ls_end)
    

#### 12.13 时间转字符串

① 函数定义

    /*
    >====================================================================
    > Function: gf_datetime_string
    >--------------------------------------------------------------------
    > 描述: 时间转字符串
    >--------------------------------------------------------------------
    > 参数:
    > string as_datetime
    > string as_select
    >--------------------------------------------------------------------
    > 返回值: string
    >====================================================================
    */
    string ls_y,ls_m,ls_d,ls_h,ls_i,ls_s
    long ll_y,ll_m,ll_d,ll_h,ll_i,ll_s
    string ls_format,ls_return
    as_datetime = trim(as_datetime)
    if pos(as_datetime,'-') > 0 then
        ls_format = '-'
        ll_y = pos(as_datetime,'-')
        ll_m = pos(as_datetime,'-',ll_y + 1)
        ll_d = pos(as_datetime,' ',ll_m + 1)
        ll_h = pos(as_datetime,':')
        ll_i = pos(as_datetime,':',ll_h + 1)
    elseif pos(as_datetime,'/') > 0 then
        ls_format = '/'
        ll_y = pos(as_datetime,'/')
        ll_m = pos(as_datetime,'/',ll_y + 1)
        ll_d = pos(as_datetime,' ',ll_m + 1)
        ll_h = pos(as_datetime,':')
        ll_i = pos(as_datetime,':',ll_h + 1)
    elseif pos(as_datetime,'.') > 0 then
        ls_format = '.'
        ll_y = pos(as_datetime,'.')
        ll_m = pos(as_datetime,'.',ll_y + 1)
        ll_d = pos(as_datetime,' ',ll_m + 1)
        ll_h = pos(as_datetime,':')
        ll_i = pos(as_datetime,':',ll_h + 1)
    end if
    ls_y = mid(as_datetime,1,ll_y - 1)
    ls_m = mid(as_datetime,ll_y + 1,ll_m - 1 - ll_y)
    ls_d = mid(as_datetime,ll_m + 1,ll_d - 1 - ll_m)
    ls_h = mid(as_datetime,ll_d + 1,ll_h - 1 - ll_d)
    ls_i = mid(as_datetime,ll_h + 1,ll_i - 1 - ll_h)
    ls_s = mid(as_datetime,ll_i + 1)
    choose case lower(as_select)
    	case 'y' //年
    		ls_return = ls_y
    	case 'm' //月
    		ls_return = ls_m
    	case 'd' //日
    		ls_return = ls_d
    	case 'h' //时
    		ls_return = ls_h
    	case 'i' //分
    		ls_return = ls_i
    	case 's' //秒
    		ls_return = ls_s
    	case 'y-m' //年-月
    		ls_return = ls_y + ls_format + ls_m
    	case 'y-m-d' //年-月-日
    		ls_return = ls_y + ls_format + ls_m + ls_format + ls_d
    	case 'y-m-d h' //年-月-日 时
    		ls_return = ls_y + ls_format + ls_m + ls_format + ls_d + ' ' + ls_h
    	case 'y-m-d h:i' //年-月-日 时:分
    		ls_return = ls_y + ls_format + ls_m + ls_format + ls_d + ' ' + ls_h +':' + ls_i
    	case 'y-m-d h:i:s' //年-月-日 时:分:秒
    		ls_return = ls_y + ls_format + ls_m + ls_format + ls_d + ' ' + ls_h +':' + ls_i + ':' + ls_s
    	case 'lastday' //获取当月最后一天
            Integer li_year,li_month
            li_year = Integer(ls_y)
            li_month = Integer(ls_m)
            if li_month = 12 then
            	li_month = 1
            	li_year ++
    		else
    			li_month = li_month + 1
    		end if
    	ls_return = string(RelativeDate(Date(String(li_year) + '-' +
    	String(li_month) + '-01'), - 1))
    end choose
    return ls_return
    

② 函数调用

    string ls_datetime
    ls_datetime = '2021-01-01 11:12:13'
    gf_datetime_string(ls_datetime,'Y') //获取年
    gf_datetime_string(ls_datetime,'M') //获取月
    gf_datetime_string(ls_datetime,'D') //获取日
    gf_datetime_string(ls_datetime,'H') //获取时
    gf_datetime_string(ls_datetime,'I') //获取分
    gf_datetime_string(ls_datetime,'S') //获取秒
    gf_datetime_string(ls_datetime,'Y-M') //获取年+月
    gf_datetime_string(ls_datetime,'Y-M-D') //获取年+月+日
    gf_datetime_string(ls_datetime,'H-I') //获取时+分
    gf_datetime_string(ls_datetime,'H-I-S') //获取时+分+秒
    gf_datetime_string(ls_datetime,'Y-M-D H') //获取年+月+日 时
    gf_datetime_string(ls_datetime,'Y-M-D H:I') //获取年+月+日 时+分
    gf_datetime_string(ls_datetime,'Y-M-D H:I:S') //获取年+月+日 时+分+秒
    

#### 12.14 xml解析

① 函数定义

    /*
    >====================================================================
    > Function: gf_xml_get
    >--------------------------------------------------------------------
    > 描述: xml解析
    >--------------------------------------------------------------------
    > 参数:
    > string data
    > string label
    >--------------------------------------------------------------------
    > 返回值: string
    >====================================================================
    */
    long ll_start
    string ls_data,ls_data2,ls_data3
    ls_data = trim(data)
    ll_start = pos(ls_data,'<' + label + '>')
    if ll_start = 0 then
    	return ''
    else
        ls_data2 = mid(ls_data,ll_start + len('<' + label + '>'))
        ls_data3 = mid(ls_data2,1,pos(ls_data2,'<') - len('<'))
    return ls_data3
    end if
    

② 函数调用

    string ls_xml
    ls_xml = '<?xml version="1.0" encoding="UTF-8"?>' + &
    '<code>' + &
    '<a>1</a>' + &
    '<b>2</b>' + &
    '<c>3</c>' + &
    '<d>4</d>' + &
    '</code>'
    gf_xml_get(ls_xml,'a')
    

#### 12.15 获取指定路径下的所有文件和文件夹

① 函数定义

    /*
    >====================================================================
    >Function: gf_dir
    >--------------------------------------------------------------------
    > >
    描述: 获取指定路径下的所有文件和文件夹
    >--------------------------------------------------------------------
    > 
    >参数:
    > string as_dir
    > listbox lb_filelist
    > 
    >ref st_dir astr_itemlist[]
    >--------------------------------------------------------------------
    > >
    返回值: integer
    >====================================================================
    >*/
    Long ll_i
    Long ll_Count
    Long ll_DirCount
        
    If Not DirectoryExists ( as_Dir ) Then
    	Return -2 // 目录不存在
    End If
        
    If Right(as_Dir, 1) <> '\' Then
    	as_Dir += '\'
    End If
    // 处理目录
    ll_DirCount = 0
    lb_FileList.DirList( as_Dir + '*.*', 32784)
    ll_Count = lb_FileList.TotalItems()
    For ll_i = 1 To ll_Count
    	If lb_FileList.Text(ll_i) = '[..]' Then
    		Continue
    	End If
    	ll_DirCount ++
        astr_ItemList[ll_DirCount].Item_Name = lb_FileList.Text(ll_i)
        astr_ItemList[ll_DirCount].Item_Name = as_Dir +
        Mid(astr_ItemList[ll_DirCount].Item_Name, 2,
        Len(astr_ItemList[ll_DirCount].Item_Name) - 2) // 去除外部的[]
        astr_ItemList[ll_DirCount].Item_Type = 2
    Next
    // 处理文件
    lb_FileList.DirList( as_Dir + '*.*', 0)
    ll_Count = lb_FileList.TotalItems()
    For ll_i = 1 To ll_Count
    	ll_DirCount ++
    	astr_ItemList[ll_DirCount].Item_Name = as_Dir + lb_FileList.Text(ll_i)
    	astr_ItemList[ll_DirCount].Item_Type = 1
    Next
    Return ll_DirCount
    

② 函数调用

    st_dir astr_itemlist[]
    gf_dir('D:\',lb_1,astr_itemlist)
    

#### 12.16 将数值转换为大写金额

① 函数定义

    /*
    >====================================================================
    > Declare: gf_capital_amount
    >--------------------------------------------------------------------
    > 描述: 将数值转换为大写金额
    >--------------------------------------------------------------------
    > 参数:
    > ac_money 要转换的金额
    >--------------------------------------------------------------------
    > 返回: 大写金额
    >====================================================================
    */
    string ls_numstr[10] = {"零","壹","贰","叁","肆","伍","陆","柒","捌","玖"}
    string ls_monstr[20] =
    {"元","拾","佰","仟","万","拾","佰","仟","亿","拾","佰","仟","万","拾","佰","仟","亿",
    "拾","佰","仟"}
    integer i
    integer li_len
    string ls_temp
    string ls_char
    string ls_intstr
    string ls_decstr
    string ls_rtnintstr
    string ls_rtndecstr
    ls_temp = string(abs(ac_money),"0.00")
    ls_intstr = left (ls_temp,len(ls_temp) - 3)
    ls_decstr = right(ls_temp,2)
    li_len = len(ls_intstr)
    for i = 1 to li_len
    	ls_char = mid(ls_intstr,li_len - i + 1,1)
    	if ls_char = "0" then
            choose case i
                case 1,9,17
                    ls_rtnintstr = ls_monstr[i] + ls_rtnintstr
                case 5,13
                    if li_len > i + 3 then
                        if mid(ls_intstr,li_len - i - 2,3) <> "000" then
                            ls_rtnintstr = ls_monstr[i] + ls_rtnintstr
                        end if
                    else
                        ls_rtnintstr = ls_monstr[i] + ls_rtnintstr
                    end if
                case else
                    if mid(ls_intstr,li_len - i + 2,1) <> "0" then
                        ls_rtnintstr = "零" + ls_rtnintstr
                    end if
            end choose
    	else
            ls_rtnintstr = ls_numstr[integer(ls_char) + 1] + ls_monstr[i] +
            ls_rtnintstr
    	end if
    next
    if long(ls_intstr) = 0 then
        if long(ls_decstr) > 0 then
            ls_rtnintstr = ""
        else
            ls_rtnintstr = "零元"
        end if
    end if
    if ls_decstr = "00" then
    	ls_rtndecstr = "整"
    elseif mid(ls_decstr,1,1) = "0" then
    	ls_rtndecstr = ls_numstr[integer(mid(ls_decstr,2,1)) + 1] + "分"
    	if long(ls_intstr) > 0 then ls_rtndecstr = "零" + ls_rtndecstr
    elseif mid(ls_decstr,2,1) = "0" then
    	ls_rtndecstr = ls_numstr[integer(mid(ls_decstr,1,1)) + 1] + "角"
    else
        ls_rtndecstr = ls_numstr[integer(mid(ls_decstr,1,1)) + 1] + "角" + &
        ls_numstr[integer(mid(ls_decstr,2,1)) + 1] + "分"
    end if
    if ac_money >= 0 then
    	return ls_rtnintstr + ls_rtndecstr
    else
    	return "负" + ls_rtnintstr + ls_rtndecstr
    end if
    

② 函数定义

    gf_capital_amount(11.22)
    

#### 12.17 将按钮循环添加到按钮数组里

① 函数定义

    /*
    >====================================================================
    > Function: gf_button_array
    >--------------------------------------------------------------------
    > 描述: 将按钮循环添加到按钮数组里
    >--------------------------------------------------------------------
    > 参数:
    > commandbutton controls[]
    > ref commandbutton lbt_btn[]
    >====================================================================
    */
    long i
    for i = 1 to UpperBound(controls[])
    	if left(classname(controls[i]),3) = "cb_" then
    		lbt_btn[upperbound(lbt_btn) + 1] = controls[i]
    	end if
    next
    

② 函数调用

    commandbutton a[]
    a[1] = cb_1
    a[2] = cb_2
    gf_button_array(a)
    

#### 12.18 动态添加数据窗口字段下的ddlb下拉框

① 函数定义

    /*
    >====================================================================
    > Function: gf_dw_ddlb
    >--------------------------------------------------------------------
    > 描述:动态添加数据窗口字段下的ddlb下拉框
    >--------------------------------------------------------------------
    > 参数:
    > datawindow as_dw 要添加下拉框的数据窗口
    > string as_dw_column 要添加下拉框的列
    > transaction as_affairs 要查询的SQL事务
    > string as_table 要查询的表
    > string as_table 要查询的where条件
    > string as_table_display 要在下拉框显示的列
    > string as_table_data 要在下拉框中指定的数据
    >--------------------------------------------------------------------
    > 返回值: integer
    >====================================================================
    */
    string dw_sql,dw_style
    string dw_syntax,dw_syntax_error,dw_create_error
    boolean lb_flag = false
    string ls_data,ls_display
    string ls_value
    datastore dw_new
    dw_new = create datastore
    as_dw.Modify(as_dw_column + ".ddlb.case='any'")
    as_dw.modify(as_dw_column + ".ddlb.vscrollbar='yes'")
    if as_table_condition = '' or isnull(as_table_condition) then
    	dw_sql = "select distinct " + as_table_display + ',' + as_table_data + "
    	from " + as_table
    else
    	dw_sql = "select distinct " + as_table_display + ',' + as_table_data + "
    	from " + as_table + ' where ' + as_table_condition
    end if
    dw_style = "style(type=grid)"
    dw_syntax = sqlca.syntaxfromsql(dw_sql, dw_style, dw_syntax_error)
    if len(dw_syntax_error) > 0 then
    	messagebox("提示", "构造sql数据源错误: " + dw_syntax_error)
    	return - 1
    end if
    dw_new.create(dw_syntax,dw_create_error)
    if len(dw_create_error) > 0 then
    	messagebox("提示", "创建数据窗口错误: " + dw_create_error)
    	return - 1
    end if
    dw_new.settransobject(sqlca)
    dw_new.retrieve()
    long i,ll_rowcount
    ll_rowcount = dw_new.rowcount()
    if ll_rowcount > 0 then
        for i = 1 to ll_rowcount
        	ls_display = string(dw_new.GetItemString(i,as_table_display))
        	ls_data = string(dw_new.GetItemString(i,as_table_data))
       		if not lb_flag then
        		ls_value = as_dw_column + ".values='"
        		lb_flag = true
       		 else
       			 ls_value += "/"
       		 end if
        	ls_value += Trim(ls_display) + "~t" + Trim(ls_data)
        next
    	ls_value += "'"
        if as_dw.Modify(ls_value) <> "" then
            return - 1
        end if
    else
    	return - 1
    end if
    return 0
    

② 函数调用

    gf_dw_ddlb(dw_1,'name',sqlca,'user','name','id')
    

一下整理了这么多函数，这些函数呢不用都记住。有个印象就可以了，可以将文章当作工具书来查即可

本期内容到此就结束了，希望对你有所帮助。

我们下期再见~ (●'◡'●)