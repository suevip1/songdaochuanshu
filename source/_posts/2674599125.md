---
layout: post
title: "äº‘åŸç”Ÿæ—¶ä»£å´›èµ·çš„ç¼–ç¨‹è¯­è¨€Goå¸¸ç”¨æ ‡å‡†åº“å®æˆ˜"
date: "2023-05-06T01:01:48.775Z"
---
äº‘åŸç”Ÿæ—¶ä»£å´›èµ·çš„ç¼–ç¨‹è¯­è¨€Goå¸¸ç”¨æ ‡å‡†åº“å®æˆ˜
=====================

![äº‘åŸç”Ÿæ—¶ä»£å´›èµ·çš„ç¼–ç¨‹è¯­è¨€Goå¸¸ç”¨æ ‡å‡†åº“å®æˆ˜](https://img2023.cnblogs.com/blog/2442976/202305/2442976-20230505222932659-1500331835.png) é€šè¿‡å‰ä¸¤ç¯‡æ–‡ç« å¯¹Goç¼–ç¨‹çš„ç†è§£ï¼Œæœ¬ç¯‡ä»é‡ç‚¹å®æˆ˜ä½¿ç”¨è§’åº¦ä»‹ç»Goå¸¸è§åŸºç¡€æ ‡å‡†åº“çš„ä½¿ç”¨ï¼Œè¾ƒå¤§éƒ¨åˆ†ä¸šåŠ¡åœºæ™¯ç›´æ¥ä½¿ç”¨æ ‡å‡†åº“æä¾›çš„ä¸°å¯ŒåŠŸèƒ½å°±å¯å®ç°å¿«é€Ÿå¼€å‘ï¼Œç»“åˆç²¾ç®€ä»£ç ç¤ºä¾‹æ¼”ç¤ºäº†å­—ç¬¦ä¸²ã€IOã€ç¼–ç ã€ç½‘ç»œã€æ•°æ®åº“ã€å•å…ƒæµ‹è¯•ç­‰åå‡ ä¸ªæ ‡å‡†åŒ…çš„ä½¿ç”¨ã€‚

@

ç›®å½•

*   [åŸºç¡€æ ‡å‡†åº“](#åŸºç¡€æ ‡å‡†åº“)
    *   [ç®€è¿°](#ç®€è¿°)
    *   [å­—ç¬¦ä¸²-string](#å­—ç¬¦ä¸²-string)
        *   [åº•å±‚ç»“æ„](#åº•å±‚ç»“æ„)
        *   [å‡½æ•°](#å‡½æ•°)
        *   [é•¿åº¦](#é•¿åº¦)
        *   [æ ¼å¼åŒ–è¾“å‡º](#æ ¼å¼åŒ–è¾“å‡º)
    *   [æ¨¡ç‰ˆ-template](#æ¨¡ç‰ˆ-template)
        *   [text/template](#texttemplate)
        *   [html/template](#htmltemplate)
    *   [æ­£åˆ™è¡¨è¾¾å¼-regexp](#æ­£åˆ™è¡¨è¾¾å¼-regexp)
    *   [ç¼–ç -encoding](#ç¼–ç -encoding)
        *   [Base64](#base64)
        *   [JSON](#json)
        *   [XML](#xml)
    *   [æ—¶é—´-time](#æ—¶é—´-time)
    *   [ç½‘ç»œ-net](#ç½‘ç»œ-net)
        *   [URL](#url)
        *   [HTTPå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯](#httpå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯)
    *   [åŠ å¯†](#åŠ å¯†)
    *   [IOæ“ä½œ](#ioæ“ä½œ)
        *   [è¯»å†™æ–‡ä»¶](#è¯»å†™æ–‡ä»¶)
        *   [ç¯å¢ƒå˜é‡](#ç¯å¢ƒå˜é‡)
        *   [å‘½ä»¤è¡Œ](#å‘½ä»¤è¡Œ)
    *   [æ•°æ®åº“](#æ•°æ®åº“)
    *   [æ’åº-sort](#æ’åº-sort)
    *   [æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•](#æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•)

åŸºç¡€æ ‡å‡†åº“
=====

ç®€è¿°
--

Goè¯­è¨€çš„æ ‡å‡†åº“è¦†ç›–ç½‘ç»œã€ç³»ç»Ÿã€åŠ å¯†ã€ç¼–ç ã€å›¾å½¢ç­‰å„ä¸ªæ–¹é¢ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨æ ‡å‡†åº“çš„ http åŒ…è¿›è¡Œ HTTP åè®®çš„æ”¶å‘å¤„ç†ï¼›ç½‘ç»œåº“åŸºäºé«˜æ€§èƒ½çš„æ“ä½œç³»ç»Ÿé€šä¿¡æ¨¡å‹ï¼ˆLinux çš„ epollã€Windows çš„ IOCPï¼‰ï¼›æ‰€æœ‰çš„åŠ å¯†ã€ç¼–ç éƒ½å†…å»ºæ”¯æŒï¼Œæ— éœ€è¦å†ä»ç¬¬ä¸‰æ–¹å¼€å‘è€…å¤„è·å–ï¼›Go è¯­è¨€çš„ç¼–è¯‘å™¨ä¹Ÿæ˜¯æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ï¼Œé€šè¿‡è¯æ³•å™¨æ‰«ææºç ï¼Œä½¿ç”¨è¯­æ³•æ ‘è·å¾—æºç é€»è¾‘åˆ†æ”¯ç­‰ï¼›Go è¯­è¨€çš„å‘¨è¾¹å·¥å…·ä¹Ÿæ˜¯å»ºç«‹åœ¨è¿™äº›æ ‡å‡†åº“ä¸Šã€‚åœ¨æ ‡å‡†åº“ä¸Šå¯ä»¥å®Œæˆå‡ ä¹å¤§éƒ¨åˆ†çš„éœ€æ±‚ï¼ŒGo è¯­è¨€çš„æ ‡å‡†åº“ä»¥åŒ…çš„æ–¹å¼æä¾›æ”¯æŒï¼Œä¸‹è¡¨æ˜¯ Go è¯­è¨€æ ‡å‡†åº“ä¸­å¸¸è§çš„åŒ…åŠå…¶åŠŸèƒ½ã€‚

Goè¯­è¨€æ ‡å‡†åº“åŒ…å

åŠŸ èƒ½

bufio

å¸¦ç¼“å†²çš„ I/O æ“ä½œ

bytes

å®ç°å­—èŠ‚æ“ä½œ

container

å°è£…å †ã€åˆ—è¡¨å’Œç¯å½¢åˆ—è¡¨ç­‰å®¹å™¨

crypto

åŠ å¯†ç®—æ³•

database

æ•°æ®åº“é©±åŠ¨å’Œæ¥å£

debug

å„ç§è°ƒè¯•æ–‡ä»¶æ ¼å¼è®¿é—®åŠè°ƒè¯•åŠŸèƒ½

encoding

å¸¸è§ç®—æ³•å¦‚ JSONã€XMLã€Base64 ç­‰

flag

å‘½ä»¤è¡Œè§£æ

fmt

æ ¼å¼åŒ–æ“ä½œ

go

Go è¯­è¨€çš„è¯æ³•ã€è¯­æ³•æ ‘ã€ç±»å‹ç­‰ã€‚å¯é€šè¿‡è¿™ä¸ªåŒ…è¿›è¡Œä»£ç ä¿¡æ¯æå–å’Œä¿®æ”¹

html

HTML è½¬ä¹‰åŠæ¨¡æ¿ç³»ç»Ÿ

image

å¸¸è§å›¾å½¢æ ¼å¼çš„è®¿é—®åŠç”Ÿæˆ

io

å®ç° I/O åŸå§‹è®¿é—®æ¥å£åŠè®¿é—®å°è£…

log

ç”¨äºæ—¥å¿—è®°å½•å’Œæ§åˆ¶å°è¾“å‡º

math

æ•°å­¦åº“

net

ç½‘ç»œåº“ï¼Œæ”¯æŒ Socketã€HTTPã€é‚®ä»¶ã€RPCã€SMTP ç­‰

os

æ“ä½œç³»ç»Ÿå¹³å°ä¸ä¾èµ–å¹³å°æ“ä½œå°è£…

path

å…¼å®¹å„æ“ä½œç³»ç»Ÿçš„è·¯å¾„æ“ä½œå®ç”¨å‡½æ•°

plugin

Go 1.7 åŠ å…¥çš„æ’ä»¶ç³»ç»Ÿã€‚æ”¯æŒå°†ä»£ç ç¼–è¯‘ä¸ºæ’ä»¶ï¼ŒæŒ‰éœ€åŠ è½½

reflect

è¯­è¨€åå°„æ”¯æŒã€‚å¯ä»¥åŠ¨æ€è·å¾—ä»£ç ä¸­çš„ç±»å‹ä¿¡æ¯ï¼Œè·å–å’Œä¿®æ”¹å˜é‡çš„å€¼

regexp

æ­£åˆ™è¡¨è¾¾å¼å°è£…

runtime

è¿è¡Œæ—¶æ¥å£

sort

æ’åºæ¥å£

strings

å­—ç¬¦ä¸²è½¬æ¢ã€è§£æåŠå®ç”¨å‡½æ•°

sync

æä¾›åŒæ­¥åŸè¯­ï¼Œå¦‚äº’æ–¥é”å’Œæ¡ä»¶å˜é‡ï¼ˆä¸Šç¯‡æ–‡ç« æœ‰ä¸“é—¨è®²è§£ï¼‰

time

æ—¶é—´æ¥å£

text

æ–‡æœ¬æ¨¡æ¿åŠ Token è¯æ³•å™¨

å­—ç¬¦ä¸²-string
----------

### åº•å±‚ç»“æ„

æ ‡å‡†åº“çš„stringsåŒ…æä¾›äº†è®¸å¤šæœ‰ç”¨çš„ä¸å­—ç¬¦ä¸²ç›¸å…³çš„å‡½æ•°ã€‚Goå­—ç¬¦ä¸²åº•å±‚çš„æ•°æ®ç»“æ„åœ¨runtime/strings.goä¸­å®šä¹‰å¦‚ä¸‹:

![image-20230505092653839](https://img-blog.csdnimg.cn/img_convert/37d720f8fd81c797414fdbddc2f33b6f.png)

ä»ä¸Šé¢çš„stringStructç»“æ„ä½“å¾—çŸ¥å…¶åŒ…å«ä¸¤ä¸ªå­—æ®µï¼Œä¸€ä¸ªæ˜¯8ä¸ªå­—èŠ‚çš„ä¸‡èƒ½æŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„é‡Œé¢å­˜å‚¨å°±æ˜¯å®é™…çš„å­—ç¬¦ï¼Œå¦ä¸€ä¸ªåˆ™æ˜¯ä¸€ä¸ª8ä¸ªå­—èŠ‚è¡¨ç¤ºå…¶é•¿åº¦ï¼Œå› æ­¤ä¸ç®¡anyStringså¤šé•¿é€šè¿‡unsafe.Sizeof("anyStrings")æœ€ç»ˆè·å–å¤§å°éƒ½æ˜¯å›ºå®šçš„16ä¸ªå­—èŠ‚ã€‚

![image-20230505093428038](https://img-blog.csdnimg.cn/img_convert/4442d4e3ee69c471d9e89b765c2c11d4.png)

### å‡½æ•°

ä¸‹é¢æ˜¯ä¸€äº›å¸¸è§å‡½æ•°ä¸¾ä¾‹ï¼Œå¯ä»¥åˆ°stringsåŒ…æ–‡æ¡£ä¸­æ‰¾åˆ°æ›´å¤šçš„å‡½æ•°

    package main
    
    import (
    	"fmt"
    	s "strings"
    	"unsafe"
    )
    
    var p = fmt.Println
    
    func main() {
    	p(unsafe.Sizeof("anyStrings"))
    	p(unsafe.Sizeof("anyStringsMoreThenLength"))
    	p("Contains:  ", s.Contains("test", "es"))
    	p("Count:     ", s.Count("test", "t"))
    	p("HasPrefix: ", s.HasPrefix("test", "te"))
    	p("HasSuffix: ", s.HasSuffix("test", "st"))
    	p("Index:     ", s.Index("test", "e"))
    	p("Join:      ", s.Join([]string{"a", "b"}, "-"))
    	p("Repeat:    ", s.Repeat("a", 5))
    	p("Replace:   ", s.Replace("foo", "o", "0", -1))
    	p("Replace:   ", s.Replace("foo", "o", "0", 1))
    	p("Split:     ", s.Split("a-b-c-d-e", "-"))
    	p("ToLower:   ", s.ToLower("TEST"))
    	p("ToUpper:   ", s.ToUpper("test"))
    }
    

![image-20230505093738945](https://img-blog.csdnimg.cn/img_convert/a6aebf6d924f667359652d217949a0c7.png)

### é•¿åº¦

*   Go è¯­è¨€çš„å†…å»ºå‡½æ•° `len()`ï¼Œå¯ä»¥ç”¨æ¥è·å–åˆ‡ç‰‡ã€å­—ç¬¦ä¸²ã€é€šé“ï¼ˆchannelï¼‰ç­‰çš„é•¿åº¦ï¼Œ
*   Go è¯­è¨€çš„å­—ç¬¦ä¸²éƒ½ä»¥ UTF-8 æ ¼å¼ä¿å­˜ï¼Œæ¯ä¸ªä¸­æ–‡å ç”¨ 3 ä¸ªå­—èŠ‚ï¼Œå› æ­¤ä½¿ç”¨ len() è·å¾—ä¸¤ä¸ªä¸­æ–‡æ–‡å­—å¯¹åº”çš„ 6 ä¸ªå­—èŠ‚ï¼›
*   é’ˆå¯¹ASCII å­—ç¬¦ä¸²é•¿åº¦ä½¿ç”¨ len() å‡½æ•°ï¼ŒUnicode å­—ç¬¦ä¸²é•¿åº¦ä½¿ç”¨ utf8.RuneCountInString() å‡½æ•°ã€‚å¦‚æœæ²¡æœ‰ä½¿ç”¨ Unicodeï¼Œæ±‰å­—åˆ™æ˜¾ç¤ºä¸ºä¹±ç ã€‚
*   ASCII å­—ç¬¦ä¸²éå†ç›´æ¥ä½¿ç”¨ä¸‹æ ‡ï¼›Unicode å­—ç¬¦ä¸²éå†ç”¨ `for range`ã€‚
*   bytes.Bufferå®ç°å­—ç¬¦ä¸²æ‹¼æ¥ã€‚

    package main
    
    import (
    	"bytes"
    	"fmt"
    	"unicode/utf8"
    )
    
    var p = fmt.Println
    
    func main() {
    	str1 := "Hello World!"
    	str2 := "ä½ å¥½"
    	fmt.Println(len(str1))                          // 12
    	fmt.Println(len(str2))                          // 6
    	fmt.Println(utf8.RuneCountInString(str2))       // 2
    	fmt.Println(utf8.RuneCountInString("ä½ å¥½,world")) // 8
    
    	// å£°æ˜å­—èŠ‚ç¼“å†²
    	var stringBuilder bytes.Buffer
    	// æŠŠå­—ç¬¦ä¸²å†™å…¥ç¼“å†²
    	stringBuilder.WriteString(str1)
    	stringBuilder.WriteString(str2)
    	// å°†ç¼“å†²ä»¥å­—ç¬¦ä¸²å½¢å¼è¾“å‡º
    	fmt.Println(stringBuilder.String())
    
    	theme := "ç‹™å‡» start"
    	for i := 0; i < len(theme); i++ {
    		fmt.Printf("ascii: %c  %d\n", theme[i], theme[i])
    	}
    
    	for _, s := range theme {
    		fmt.Printf("Unicode: %c  %d\n", s, s)
    	}
    }
    

![image-20230505100058382](https://img-blog.csdnimg.cn/img_convert/3ae9629105436d3ce50231e33ab60e92.png)

### æ ¼å¼åŒ–è¾“å‡º

Goä¸ºä¼ ç»Ÿçš„printfå­—ç¬¦ä¸²æ ¼å¼åŒ–æä¾›äº†å¾ˆå¥½çš„æ”¯æŒï¼ŒGoæä¾›äº†è‹¥å¹²ä¸ªæ‰“å°â€œåŠ¨è¯â€ï¼Œç”¨äºæ ¼å¼åŒ–ä¸€èˆ¬Goå€¼ï¼Œä¸‹é¢æ˜¯ä¸€äº›å¸¸è§çš„å­—ç¬¦ä¸²æ ¼å¼åŒ–ä»»åŠ¡çš„ç¤ºä¾‹ã€‚

    package main
    
    import (
    	"fmt"
    	"os"
    )
    
    type point struct {
    	x, y int
    }
    
    func main() {
    
    	p := point{1, 2}
    	fmt.Printf("struct1: %v\n", p)
    
    	fmt.Printf("struct2: %+v\n", p)
    
    	fmt.Printf("struct3: %#v\n", p)
    
    	fmt.Printf("type: %T\n", p)
    
    	fmt.Printf("bool: %t\n", true)
    
    	fmt.Printf("int: %d\n", 123)
    
    	fmt.Printf("bin: %b\n", 14)
    
    	fmt.Printf("char: %c\n", 33)
    
    	fmt.Printf("hex: %x\n", 456)
    
    	fmt.Printf("float1: %f\n", 78.9)
    
    	fmt.Printf("float2: %e\n", 123400000.0)
    	fmt.Printf("float3: %E\n", 123400000.0)
    
    	fmt.Printf("str1: %s\n", "\"string\"")
    
    	fmt.Printf("str2: %q\n", "\"string\"")
    
    	fmt.Printf("str3: %x\n", "hex this")
    
    	fmt.Printf("pointer: %p\n", &p)
    
    	fmt.Printf("width1: |%6d|%6d|\n", 12, 345)
    
    	fmt.Printf("width2: |%6.2f|%6.2f|\n", 1.2, 3.45)
    
    	fmt.Printf("width3: |%-6.2f|%-6.2f|\n", 1.2, 3.45)
    
    	fmt.Printf("width4: |%6s|%6s|\n", "foo", "b")
    
    	fmt.Printf("width5: |%-6s|%-6s|\n", "foo", "b")
    
    	s := fmt.Sprintf("sprintf: a %s", "string")
    	fmt.Println(s)
    
    	fmt.Fprintf(os.Stderr, "io: an %s\n", "error")
    }
    

![image-20230505100238779](https://img-blog.csdnimg.cn/img_convert/ce2e090d76355c288bc267bb268c81be.png)

æ¨¡ç‰ˆ-template
-----------

### text/template

Golangä¸­çš„æ ‡å‡†åº“templateå°±åƒæ˜¯ä¸€ä¸ªâ€œè„šæœ¬è¯­è¨€è§£æå™¨â€ï¼Œå…¶ä¸­æ¶‰åŠåˆ°å˜é‡èµ‹å€¼ã€å‡½æ•°/æ–¹æ³•è°ƒç”¨å’Œå„ç§æ¡ä»¶/å¾ªç¯æ§åˆ¶ç»“æ„ç­‰ã€‚templateåŒ…å®ç°äº†æ•°æ®é©±åŠ¨çš„ç”¨äºç”Ÿæˆæ–‡æœ¬è¾“å‡ºçš„æ¨¡æ¿ï¼Œç®€å•æ¥è¯´å°±æ˜¯å°†ä¸€ç»„æ–‡æœ¬åµŒå…¥å¦ä¸€ç»„æ–‡æœ¬æ¨¡ç‰ˆä¸­ï¼Œè¿”å›ä¸€ä¸ªæœŸæœ›çš„æ–‡æœ¬ã€‚Goä¸ºæ¨¡æ¿æ“ä½œæä¾›äº†ä¸°å¯Œçš„æ”¯æŒã€‚åµŒå¥—æ¨¡æ¿ï¼Œå¯¼å…¥å‡½æ•°ï¼Œè¡¨ç¤ºå˜é‡ï¼Œè¿­ä»£æ•°æ®ç­‰ç­‰éƒ½å¾ˆç®€å•ã€‚å¦‚æœéœ€è¦æ¯”CSVæ•°æ®æ ¼å¼æ›´å¤æ‚çš„ä¸œè¥¿ï¼Œæ¨¡æ¿å¯èƒ½æ˜¯ä¸€ä¸ªä¸é”™çš„è§£å†³æ–¹æ¡ˆã€‚æ¨¡æ¿çš„å¦ä¸€ä¸ªåº”ç”¨æ˜¯ç½‘ç«™çš„é¡µé¢æ¸²æŸ“ï¼›å½“æˆ‘ä»¬æƒ³è¦å°†æœåŠ¡å™¨ç«¯æ•°æ®å‘ˆç°ç»™å®¢æˆ·ç«¯æ—¶ï¼Œæ¨¡æ¿å¯ä»¥å¾ˆå¥½åœ°æ»¡è¶³è¦æ±‚ã€‚

Goæä¾›äº†text/templateå’Œhtml/templateè¿™ä¸¤ä¸ªæ¨¡æ¿åŒ…ï¼Œè¿™ä¸¤ä¸ªåŒ…çš„éƒ¨åˆ†å‡½æ•°çœ‹èµ·æ¥éå¸¸ç›¸ä¼¼ï¼Œå®é™…åŠŸèƒ½ä¹Ÿç¡®å®å¦‚æ­¤

    package main
    
    import (
    	"os"
    	"text/template"
    )
    
    type Inventory struct {
    	Username string
    	Phone    uint
    	Tag      bool
    	Sex      string
    }
    
    func main() {
    	t1 := template.New("t1")
    	t1, err := t1.Parse("Value is {{.}}\n")
    	if err != nil {
    		panic(err)
    	}
    
    	t1 = template.Must(t1.Parse("Value: {{.}}\n"))
    
    	t1.Execute(os.Stdout, "some text")
    	t1.Execute(os.Stdout, 5)
    	t1.Execute(os.Stdout, []string{
    		"Go",
    		"Rust",
    		"C++",
    		"C#",
    	})
    
    	Create := func(name, t string) *template.Template {
    		return template.Must(template.New(name).Parse(t))
    	}
    
    	t2 := Create("t2", "Name: {{.Name}}\n")
    
    	t2.Execute(os.Stdout, struct {
    		Name string
    	}{"Jane Doe"})
    
    	t2.Execute(os.Stdout, map[string]string{
    		"Name": "Mickey Mouse",
    	})
    
    	t3 := Create("t3",
    		"{{if . -}} yes {{else -}} no {{end}}\n")
    	t3.Execute(os.Stdout, "not empty")
    	t3.Execute(os.Stdout, "")
    
    	t4 := Create("t4",
    		"Range: {{range .}}{{.}} {{end}}\n")
    	t4.Execute(os.Stdout,
    		[]string{
    			"Go",
    			"Rust",
    			"C++",
    			"C#",
    		})
    
    	sweaters := Inventory{"ç§»åŠ¨", 10086, false, "éš¾"}
    
    	content := `{{.Phone}} of {{.Username}} {{if .Tag }} tag=true {{else}}   tag=false {{end}}`
    	tmpl, err := template.New("test").Parse(content)
    	//{{.Phone}}è·å–çš„æ˜¯structå¯¹è±¡ä¸­çš„Phoneå­—æ®µçš„å€¼
    	if err != nil {
    		panic(err)
    	}
    	err = tmpl.Execute(os.Stdout, sweaters) // 10086 of ç§»åŠ¨  tag=true
    	if err != nil {
    		panic(err)
    	}
    }
    

![image-20230505104701798](https://img-blog.csdnimg.cn/img_convert/073d69db79303bf29bbd31c09835f93f.png)

### html/template

ä½¿ç”¨html/templateæ¥å‘ˆç°ç½‘ç«™ï¼Œæ¨¡æ¿æ˜¯çº¯æ–‡æœ¬ï¼Œä½†å˜é‡å’Œå‡½æ•°å¯ä»¥åœ¨å¤§æ‹¬å·å—å†…ä½¿ç”¨ï¼Œæ¨¡æ¿åŒ…è¿˜æä¾›äº†å¤„ç†æ–‡ä»¶çš„ä¾¿æ·æ–¹æ³•ã€‚html/templateåŒ…æ˜¯å¯¹text/templateåŒ…çš„åŒ…è£…ï¼Œå› æ­¤èƒ½åŒäºtext/templateåŸºæœ¬éƒ½å¯¹html/templateåŒ…åŒæ ·é€‚ç”¨ï¼Œé™¤äº†importè¯­å¥æ— éœ€å…¶ä»–ä»»ä½•ä¿®æ”¹ã€‚HTMLæ¨¡æ¿æä¾›äº†ä¸Šä¸‹æ–‡æ„ŸçŸ¥å®‰å…¨æ€§çš„é¢å¤–å¥½å¤„ï¼Œä¹Ÿå¯ä»¥é˜²æ­¢è¯¸å¦‚JavaScriptæ³¨å…¥ä¹‹ç±»çš„äº‹æƒ…ã€‚å¦‚æœè¦ç”ŸæˆHTMLæ ¼å¼çš„è¾“å‡ºï¼Œå‚è§html/templateåŒ…ï¼Œè¯¥åŒ…æä¾›äº†å’Œæœ¬åŒ…ç›¸åŒçš„æ¥å£ï¼Œä½†ä¼šè‡ªåŠ¨å°†è¾“å‡ºè½¬åŒ–ä¸ºå®‰å…¨çš„HTMLæ ¼å¼è¾“å‡ºï¼Œå¯ä»¥æŠµæŠ—ä¸€äº›ç½‘ç»œæ”»å‡»ã€‚

    package main
    
    import (
    	"html/template"
    	"net/http"
    )
    
    func tmpl(w http.ResponseWriter, r *http.Request) {
    	t1, err := template.ParseFiles("test.html")
    	if err != nil {
    		panic(err)
    	}
    	t1.Execute(w, "hello world")
    }
    
    func main() {
    	server := http.Server{
    		Addr: "127.0.0.1:8080",
    	}
    	http.HandleFunc("/tmpl", tmpl)
    	server.ListenAndServe()
    }
    

åˆ›å»ºtest.html

    <!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Go Web</title>
    </head>
    <body>
    {{ . }}
    </body>
    </html>
    

è®¿é—®æµ‹è¯•åœ°å€http://localhost:8080/tmpl

![image-20230505105330299](https://img-blog.csdnimg.cn/img_convert/dd699facc0c022a5632fdcb739a30097.png)

æ­£åˆ™è¡¨è¾¾å¼-regexp
------------

Goæä¾›äº†å¯¹æ­£åˆ™è¡¨è¾¾å¼çš„å†…ç½®æ”¯æŒï¼Œå…¶ç”±regexpåŒ…å®ç°äº†æ­£åˆ™è¡¨è¾¾å¼æœç´¢ï¼›Goæ ‡å‡†åº“ä½¿ç”¨RE2è¯­æ³•ï¼ŒRE2è¯­æ³•ä¹Ÿæ˜¯Pythonã€Cå’ŒPerlä½¿ç”¨çš„æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ï¼Œå¸¸è§å‡½æ•°ï¼š

*   MatchStringï¼š`regexp.MatchString()`ç”¨æ¥åŒ¹é…å­å­—ç¬¦ä¸²ã€‚ä¸‹é¢è¿™ä¸ªä¾‹å­æ˜¯æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä»¥`Golang`å¼€å¤´ã€‚æˆ‘ä»¬ä½¿ç”¨`^`æ¥åŒ¹é…å­—ç¬¦ä¸²ä¸­ä»¥æ–‡æœ¬çš„å¼€å§‹ã€‚æˆ‘ä»¬ä½¿ç”¨`^Golang`ä½œä¸ºæ­£åˆ™è¡¨è¾¾å¼è¿›è¡ŒåŒ¹é…ã€‚
*   Compileï¼š`Compile()` æˆ–è€… `MustCompile()`åˆ›å»ºä¸€ä¸ªç¼–è¯‘å¥½çš„æ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡ã€‚å‡å¦‚æ­£åˆ™è¡¨è¾¾å¼éæ³•ï¼Œé‚£ä¹ˆ`Compile()`æ–¹æ³•ä¼šè¿”å›error,è€Œ`MustCompile()`ç¼–è¯‘éæ³•æ­£åˆ™è¡¨è¾¾å¼æ—¶ä¸ä¼šè¿”å›errorï¼Œè€Œæ˜¯ä¼španicã€‚å¦‚æœä½ æƒ³è¦å¾ˆå¥½çš„æ€§èƒ½ï¼Œä¸è¦åœ¨ä½¿ç”¨çš„æ—¶å€™æ‰è°ƒç”¨`Compile()`ä¸´æ—¶è¿›è¡Œç¼–è¯‘ï¼Œè€Œæ˜¯é¢„å…ˆè°ƒç”¨`Compile()`ç¼–è¯‘å¥½æ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡ã€‚
*   FindStringï¼š`FindString()`ç”¨æ¥è¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…çš„ç»“æœã€‚å¦‚æœæ²¡æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå®ƒä¼šè¿”å›ä¸€ä¸ªç©ºçš„å­—ç¬¦ä¸²ï¼Œå½“ç„¶å¦‚æœä½ çš„æ­£åˆ™è¡¨è¾¾å¼å°±æ˜¯è¦åŒ¹é…ç©ºå­—ç¬¦ä¸²çš„è¯ï¼Œå®ƒä¹Ÿä¼šè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚ä½¿ç”¨ `FindStringIndex` æˆ–è€… `FindStringSubmatch`å¯ä»¥åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µã€‚
    *   FindStringIndexï¼š`FindStringIndex()`å¯ä»¥å¾—åˆ°åŒ¹é…çš„å­—ç¬¦ä¸²åœ¨æ•´ä½“å­—ç¬¦ä¸²ä¸­çš„ç´¢å¼•ä½ç½®ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²ï¼Œå®ƒä¼šè¿”å›nilå€¼ã€‚
    *   FindStringSubmatchï¼š`FindStringSubmatch()` é™¤äº†è¿”å›åŒ¹é…çš„å­—ç¬¦ä¸²å¤–ï¼Œè¿˜ä¼šè¿”å›å­è¡¨è¾¾å¼çš„åŒ¹é…é¡¹ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…é¡¹ï¼Œåˆ™è¿”å›nilå€¼ã€‚
*   FindAllStringï¼š`FindString`æ–¹æ³•çš„**All**ç‰ˆæœ¬ï¼Œå®ƒè¿”å›æ‰€æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²çš„sliceã€‚å¦‚æœè¿”å›nilå€¼ä»£è¡¨æ²¡æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²ã€‚
*   `ReplaceAllString` ï¼šç”¨æ¥æ›¿æ¢æ‰€æœ‰åŒ¹é…çš„å­—ç¬¦ä¸²ï¼Œè¿”å›ä¸€ä¸ªæºå­—ç¬¦ä¸²çš„æ‹·è´ã€‚

Goä¸­ä¸regexpç›¸å…³çš„ä¸€äº›å¸¸è§ç¤ºä¾‹

    package main
    
    import (
    	"bytes"
    	"fmt"
    	"regexp"
    )
    
    func main() {
    
    	match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    	fmt.Println(match)
    
    	r, _ := regexp.Compile("p([a-z]+)ch")
    
    	fmt.Println(r.MatchString("peach"))
    
    	fmt.Println(r.FindString("peach punch"))
    
    	fmt.Println("idx:", r.FindStringIndex("peach punch"))
    
    	fmt.Println(r.FindStringSubmatch("peach punch"))
    
    	fmt.Println(r.FindStringSubmatchIndex("peach punch"))
    
    	fmt.Println(r.FindAllString("peach punch pinch", -1))
    
    	fmt.Println("all:", r.FindAllStringSubmatchIndex(
    		"peach punch pinch", -1))
    
    	fmt.Println(r.FindAllString("peach punch pinch", 2))
    
    	fmt.Println(r.Match([]byte("peach")))
    
    	r = regexp.MustCompile("p([a-z]+)ch")
    	fmt.Println("regexp:", r)
    
    	fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))
    
    	in := []byte("a peach")
    	out := r.ReplaceAllFunc(in, bytes.ToUpper)
    	fmt.Println(string(out))
    }
    

![image-20230505112943707](https://img-blog.csdnimg.cn/img_convert/503e2af9817a6dafd2be16960e47bc3f.png)

ç¼–ç -encoding
-----------

`encoding` åŒ…æ˜¯ Go æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªé‡è¦åŒ…ï¼Œä¸»è¦ç”¨äºæ•°æ®ç¼–ç å’Œè§£ç ã€‚`encoding` åŒ…ä¸­åŒ…å«äº†è®¸å¤šå¸¸ç”¨çš„æ•°æ®ç¼–ç å’Œè§£ç ç®—æ³•ï¼Œå¦‚ JSONã€XMLã€CSVã€Base64 ç­‰ï¼Œè¿™äº›ç®—æ³•å¯ä»¥å¸®åŠ©æˆ‘ä»¬å°†æ•°æ®ä»ä¸€ç§æ ¼å¼è½¬æ¢ä¸ºå¦ä¸€ç§æ ¼å¼ï¼Œä¾¿äºåœ¨ä¸åŒçš„ç³»ç»Ÿä¹‹é—´ä¼ è¾“å’Œå¤„ç†ã€‚

### Base64

Goæä¾›å¯¹base64ç¼–ç /è§£ç çš„å†…ç½®æ”¯æŒã€‚

    package main
    
    import (
    	b64 "encoding/base64"
    	"fmt"
    )
    
    func main() {
    
    	data := "abc123!?$*&()'-=@~"
    
    	sEnc := b64.StdEncoding.EncodeToString([]byte(data))
    	fmt.Println(sEnc)
    
    	sDec, _ := b64.StdEncoding.DecodeString(sEnc)
    	fmt.Println(string(sDec))
    	fmt.Println()
    
    	uEnc := b64.URLEncoding.EncodeToString([]byte(data))
    	fmt.Println(uEnc)
    	uDec, _ := b64.URLEncoding.DecodeString(uEnc)
    	fmt.Println(string(uDec))
    }
    

![image-20230505151716877](https://img-blog.csdnimg.cn/img_convert/b076b58cad77abfd959206b85d7e17d1.png)

### JSON

Goæä¾›äº†å¯¹JSONç¼–ç å’Œè§£ç çš„å†…ç½®æ”¯æŒï¼ŒåŒ…æ‹¬æ¥è‡ªå†…ç½®å’Œè‡ªå®šä¹‰æ•°æ®ç±»å‹çš„æ”¯æŒã€‚éœ€è¦ä½¿ç”¨encoding/jsonåŒ…è¿›è¡Œjsonå®ç°åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ï¼Œgoçš„jsonè§£æä¸»è¦æ˜¯ç¼–ç å’Œè§£ç ä¸¤ä¸ªå‡½æ•°ï¼Œåºåˆ—åŒ–ä¹Ÿå°±æ˜¯ç”±ç»“æ„ä½“è½¬åŒ–ä¸ºjson stringå­—ç¬¦ä¸²ï¼Œä½¿ç”¨json.Marshalå‡½æ•°ï¼›ååºåˆ—åŒ–å°±æ˜¯å°†json stringå­—ç¬¦ä¸²è½¬åŒ–ä¸ºç»“æ„ä½“ï¼Œä½¿ç”¨å‡½æ•°json.Unmarshalå‡½æ•°å®Œæˆã€‚

    ~~~go
    package main
    
    import (
    	"encoding/json"
    	"fmt"
    	"os"
    )
    
    type response1 struct {
    	Page   int
    	Fruits []string
    }
    
    type response2 struct {
    	Page   int      `json:"page"`
    	Fruits []string `json:"fruits"`
    }
    
    func main() {
    
    	bolB, _ := json.Marshal(true)
    	fmt.Println(string(bolB))
    
    	intB, _ := json.Marshal(1)
    	fmt.Println(string(intB))
    
    	fltB, _ := json.Marshal(2.34)
    	fmt.Println(string(fltB))
    
    	strB, _ := json.Marshal("gopher")
    	fmt.Println(string(strB))
    
    	slcD := []string{"apple", "peach", "pear"}
    	slcB, _ := json.Marshal(slcD)
    	fmt.Println(string(slcB))
    
    	mapD := map[string]int{"apple": 5, "lettuce": 7}
    	mapB, _ := json.Marshal(mapD)
    	fmt.Println(string(mapB))
    
    	res1D := &response1{
    		Page:   1,
    		Fruits: []string{"apple", "peach", "pear"}}
    	res1B, _ := json.Marshal(res1D)
    	fmt.Println(string(res1B))
    
    	res2D := &response2{
    		Page:   1,
    		Fruits: []string{"apple", "peach", "pear"}}
    	res2B, _ := json.Marshal(res2D)
    	fmt.Println(string(res2B))
    
    	byt := []byte(`{"num":6.13,"strs":["a","b"]}`)
    
    	var dat map[string]interface{}
    
    	if err := json.Unmarshal(byt, &dat); err != nil {
    		panic(err)
    	}
    	fmt.Println(dat)
    
    	num := dat["num"].(float64)
    	fmt.Println(num)
    
    	strs := dat["strs"].([]interface{})
    	str1 := strs[0].(string)
    	fmt.Println(str1)
    
    	str := `{"page": 1, "fruits": ["apple", "peach"]}`
    	res := response2{}
    	json.Unmarshal([]byte(str), &res)
    	fmt.Println(res)
    	fmt.Println(res.Fruits[0])
    
    	enc := json.NewEncoder(os.Stdout)
    	d := map[string]int{"apple": 5, "lettuce": 7}
    	enc.Encode(d)
    }
    

![image-20230505135300690](https://img-blog.csdnimg.cn/img_convert/0941ac7814786cc3bf520ee7482f158b.png)

### XML

Goé€šè¿‡encoding.xmlåŒ…æä¾›äº†å¯¹XMLå’Œç±»XMLæ ¼å¼çš„å†…ç½®æ”¯æŒã€‚Goè¯­è¨€å†…ç½®çš„ encoding/xml åŒ…å¯ä»¥ç”¨åœ¨ç»“æ„ä½“å’Œ XML æ ¼å¼ä¹‹é—´è¿›è¡Œç¼–è§£ç ï¼Œå…¶æ–¹å¼è·Ÿ encoding/json åŒ…ç±»ä¼¼ï¼›ç„¶è€Œä¸ JSON ç›¸æ¯” XML çš„ç¼–ç å’Œè§£ç åœ¨åŠŸèƒ½ä¸Šæ›´è‹›åˆ»å¾—å¤šï¼Œè¿™æ˜¯ç”±äº encoding/xml åŒ…è¦æ±‚ç»“æ„ä½“çš„å­—æ®µåŒ…å«æ ¼å¼åˆç†çš„æ ‡ç­¾ï¼Œè€Œ JSON æ ¼å¼å´ä¸éœ€è¦ã€‚

    package main
    
    import (
    	"encoding/xml"
    	"fmt"
    )
    
    type Plant struct {
    	XMLName xml.Name `xml:"plant"`
    	Id      int      `xml:"id,attr"`
    	Name    string   `xml:"name"`
    	Origin  []string `xml:"origin"`
    }
    
    func (p Plant) String() string {
    	return fmt.Sprintf("Plant id=%v, name=%v, origin=%v",
    		p.Id, p.Name, p.Origin)
    }
    
    func main() {
    	coffee := &Plant{Id: 27, Name: "Coffee"}
    	coffee.Origin = []string{"Ethiopia", "Brazil"}
    
    	out, _ := xml.MarshalIndent(coffee, " ", "  ")
    	fmt.Println(string(out))
    
    	fmt.Println(xml.Header + string(out))
    
    	var p Plant
    	if err := xml.Unmarshal(out, &p); err != nil {
    		panic(err)
    	}
    	fmt.Println(p)
    
    	tomato := &Plant{Id: 81, Name: "Tomato"}
    	tomato.Origin = []string{"Mexico", "California"}
    
    	type Nesting struct {
    		XMLName xml.Name `xml:"nesting"`
    		Plants  []*Plant `xml:"parent>child>plant"`
    	}
    
    	nesting := &Nesting{}
    	nesting.Plants = []*Plant{coffee, tomato}
    
    	out, _ = xml.MarshalIndent(nesting, " ", "  ")
    	fmt.Println(string(out))
    }
    

![image-20230505135543401](https://img-blog.csdnimg.cn/img_convert/8763acf46995343668d915159fde5e2a.png)

æ—¶é—´-time
-------

åœ¨ç¼–ç¨‹ä¸­ç»å¸¸ä¼šé­é‡å…«å°æ—¶æ—¶é—´å·®é—®é¢˜ï¼Œè¿™æ˜¯ç”±æ—¶åŒºå·®å¼‚å¼•èµ·çš„ï¼Œä¸ºäº†èƒ½æ›´å¥½åœ°è§£å†³å®ƒä»¬ï¼Œéœ€è¦å…ˆç†è§£å‡ ä¸ªæ—¶é—´å®šä¹‰æ ‡å‡†ã€‚

*   GMTï¼ˆGreenwich Mean Timeï¼‰ï¼šæ ¼æ—å¨æ²»æ—¶é—´ï¼›GMT æ ¹æ®åœ°çƒçš„è‡ªè½¬å’Œå…¬è½¬æ¥è®¡ç®—æ—¶é—´ï¼Œå®ƒè§„å®šå¤ªé˜³æ¯å¤©ç»è¿‡ä½äºè‹±å›½ä¼¦æ•¦éƒŠåŒºçš„çš‡å®¶æ ¼æ—å¨æ²»å¤©æ–‡å°çš„æ—¶é—´ä¸ºä¸­åˆ12ç‚¹ï¼›GMT æ˜¯å‰ä¸–ç•Œæ ‡å‡†æ—¶ã€‚
*   UTCï¼ˆCoordinated Universal Timeï¼‰ï¼Œåè°ƒä¸–ç•Œæ—¶é—´ï¼Œåˆç§°ä¸–ç•Œç»Ÿä¸€æ—¶é—´ï¼›UTC æ¯” GMT æ›´ç²¾å‡†ï¼Œå®ƒæ ¹æ®åŸå­é’Ÿæ¥è®¡ç®—æ—¶é—´ï¼Œé€‚åº”ç°ä»£ç¤¾ä¼šçš„ç²¾ç¡®è®¡æ—¶ã€‚åœ¨ä¸éœ€è¦ç²¾ç¡®åˆ°ç§’çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥è®¤ä¸º UTC=GMTï¼›UTC æ˜¯ç°ä¸–ç•Œæ ‡å‡†æ—¶ã€‚

é€‚åº”ç°ä»£ç¤¾ä¼šçš„ç²¾ç¡®è®¡æ—¶ä»æ ¼æ—å¨æ²»æœ¬åˆå­åˆçº¿èµ·ï¼Œå¾€ä¸œä¸ºæ­£ï¼Œå¾€è¥¿ä¸ºè´Ÿï¼Œå…¨çƒå…±åˆ’åˆ†ä¸º 24 ä¸ªæ ‡å‡†æ—¶åŒºï¼Œç›¸é‚»æ—¶åŒºç›¸å·®ä¸€ä¸ªå°æ—¶ï¼›å¦‚ä½•è·å–è‡ªUnixçºªå…ƒä»¥æ¥çš„ç§’æ•°ã€æ¯«ç§’æ•°æˆ–çº³ç§’æ•°å’Œæ—¶é—´æ ¼å¼åŒ–ã€‚

    package main
    
    import (
    	"fmt"
    	"time"
    )
    
    func main() {
    	p := fmt.Println
    
    	now := time.Now()
    	p(now)
    
    	then := time.Date(
    		2009, 11, 17, 20, 34, 58, 651387237, time.UTC)
    	p(then)
    
    	p(then.Year())
    	p(then.Month())
    	p(then.Day())
    	p(then.Hour())
    	p(then.Minute())
    	p(then.Second())
    	p(then.Nanosecond())
    	p(then.Location())
    
    	p(then.Weekday())
    
    	p(then.Before(now))
    	p(then.After(now))
    	p(then.Equal(now))
    
    	diff := now.Sub(then)
    	p(diff)
    
    	p(diff.Hours())
    	p(diff.Minutes())
    	p(diff.Seconds())
    	p(diff.Nanoseconds())
    
    	p(then.Add(diff))
    	p(then.Add(-diff))
    	p("-----------------------")
    	fmt.Println(now.Unix())
    	fmt.Println(now.UnixMilli())
    	fmt.Println(now.UnixNano())
    
    	fmt.Println(time.Unix(now.Unix(), 0))
    	fmt.Println(time.Unix(0, now.UnixNano()))
    	p("-----------------------")
    	t := time.Now()
    	p(t.Format(time.RFC3339))
    
    	t1, e := time.Parse(
    		time.RFC3339,
    		"2012-11-01T22:08:41+00:00")
    	p(t1)
    
    	p(t.Format("3:04PM"))
    	p(t.Format("Mon Jan _2 15:04:05 2006"))
    	p(t.Format("2006-01-02T15:04:05.999999-07:00"))
    	form := "3 04 PM"
    	t2, e := time.Parse(form, "8 41 PM")
    	p(t2)
    
    	fmt.Printf("%d-%02d-%02dT%02d:%02d:%02d-00:00\n",
    		t.Year(), t.Month(), t.Day(),
    		t.Hour(), t.Minute(), t.Second())
    
    	ansic := "Mon Jan _2 15:04:05 2006"
    	_, e = time.Parse(ansic, "8:41PM")
    	p(e)
    }
    

![image-20230505181055251](https://img-blog.csdnimg.cn/img_convert/d17b93956dc75317f0718907392ceb8d.png)

ç½‘ç»œ-net
------

ç½‘ç»œç¼–ç¨‹æ˜¯goè¯­è¨€ä½¿ç”¨çš„ä¸€ä¸ªæ ¸å¿ƒæ¨¡å—ï¼›golangçš„ç½‘ç»œå°è£…ä½¿ç”¨å¯¹äºåº•å±‚socketæˆ–è€…ä¸Šå±‚çš„httpï¼Œç”šè‡³æ˜¯webæœåŠ¡éƒ½å¾ˆå‹å¥½ã€‚netåŒ…æä¾›äº†å¯ç§»æ¤çš„ç½‘ç»œI/Oæ¥å£ï¼ŒåŒ…æ‹¬TCP/IPã€UDPã€åŸŸåè§£æå’ŒUnixåŸŸsocketç­‰æ–¹å¼çš„é€šä¿¡ã€‚å…¶ä¸­æ¯ä¸€ç§é€šä¿¡æ–¹å¼éƒ½ä½¿ç”¨ xxConn ç»“æ„ä½“æ¥è¡¨ç¤ºï¼Œè¯¸å¦‚IPConnã€TCPConnç­‰ï¼Œè¿™äº›ç»“æ„ä½“éƒ½å®ç°äº†Connæ¥å£ï¼ŒConnæ¥å£å®ç°äº†åŸºæœ¬çš„è¯»ã€å†™ã€å…³é—­ã€è·å–è¿œç¨‹å’Œæœ¬åœ°åœ°å€ã€è®¾ç½®timeoutç­‰åŠŸèƒ½ã€‚

### URL

urlæä¾›äº†ä¸€ç§ç»Ÿä¸€çš„æ–¹å¼æ¥å®šä½èµ„æºï¼ŒGoä¸­è§£æurléœ€è¦ä½¿ç”¨åˆ°å…¶netåŒ…ã€‚

*   URLæ ¼å¼ï¼šğŸ˜•/:@:/:?#
*   `scheme` : æ–¹æ¡ˆæ˜¯å¦‚ä½•è®¿é—®æŒ‡å®šèµ„æºçš„ä¸»è¦æ ‡è¯†ç¬¦ï¼Œä»–ä¼šå‘Šè¯‰è´Ÿè´£è§£æ `URL` åº”ç”¨ç¨‹åºåº”è¯¥ä½¿ç”¨ä»€ä¹ˆåè®®ï¼›
*   `user` ï¼šç”¨æˆ·åï¼›
*   `password` ï¼šå¯†ç ï¼›
*   `host` : ä¸»æœºç»„ä»¶æ ‡è¯†äº†å› ç‰¹ç½‘ä¸Šèƒ½å¤Ÿè®¿é—®èµ„æºçš„å®¿ä¸»æœºå™¨ï¼Œå¯ä»¥æœ‰ä¸»æœºåæˆ–è€…æ˜¯ `IP` åœ°å€æ¥è¡¨ç¤ºï¼›
*   `port` : ç«¯å£æ ‡è¯†äº†æœåŠ¡å™¨æ­£åœ¨ç›‘å¬çš„ç½‘ç»œç«¯å£ã€‚é»˜è®¤ç«¯å£å·æ˜¯ 80ï¼›
*   `path` : `URL` çš„è·¯å¾„ç»„ä»¶è¯´æ˜äº†èµ„æºä½äºæœåŠ¡å™¨çš„ä»€ä¹ˆåœ°æ–¹ï¼›
*   `params` : `URL` ä¸­é€šè¿‡åè®®å‚æ•°æ¥è®¿é—®èµ„æºï¼Œæ¯”åå€¼å¯¹åˆ—è¡¨ï¼Œåˆ†å·åˆ†å‰²æ¥è¿›è¡Œè®¿é—®ï¼›
*   `query` : å­—ç¬¦ä¸²æ˜¯é€šè¿‡æé—®é—®é¢˜æˆ–è¿›è¡ŒæŸ¥è¯¢æ¥ç¼©å°è¯·æ±‚èµ„æºç±»çš„èŒƒå›´ï¼›
*   `frag` : ä¸ºäº†å¼•ç”¨éƒ¨åˆ†èµ„æºæˆ–èµ„æºçš„ä¸€ä¸ªç‰‡æ®µï¼Œæ¯”å¦‚ `URL` æŒ‡å®š `HTML` æ–‡æ¡£ä¸­ä¸€ä¸ªå›¾ç‰‡æˆ–ä¸€ä¸ªå°èŠ‚ï¼›

    package main
    
    import (
        "fmt"
        "net"
        "net/url"
    )
    
    func main() {
    
        s := "postgres://user:pass@host.com:5432/path?k=v#f"
    
        u, err := url.Parse(s)
        if err != nil {
            panic(err)
        }
    
        fmt.Println(u.Scheme)
    
        fmt.Println(u.User)
        fmt.Println(u.User.Username())
        p, _ := u.User.Password()
        fmt.Println(p)
    
        fmt.Println(u.Host)
        host, port, _ := net.SplitHostPort(u.Host)
        fmt.Println(host)
        fmt.Println(port)
    
        fmt.Println(u.Path)
        fmt.Println(u.Fragment)
    
        fmt.Println(u.RawQuery)
        m, _ := url.ParseQuery(u.RawQuery)
        fmt.Println(m)
        fmt.Println(m["k"][0])
    }
    

![image-20230505150102644](https://img-blog.csdnimg.cn/img_convert/ffd30735cc4708f5711f600588a243a4.png)

### HTTPå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯

Goè¯­è¨€æä¾›äº†ä¸€ä¸ªåŠŸèƒ½ä¸°å¯Œçš„net/httpåŒ…ï¼Œå®ƒæä¾›äº†å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„å®ç°ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒè½»æ˜“çš„åˆ›å»ºhttpæœåŠ¡ã€‚

*   ä½œä¸ºå®¢æˆ·ç«¯å‘é€httpè¯·æ±‚

    package main
    
    import (
        "bufio"
        "fmt"
        "net/http"
    )
    
    func main() {
    
        resp, err := http.Get("https://gobyexample.com")
        if err != nil {
            panic(err)
        }
        defer resp.Body.Close()
    
        fmt.Println("Response status:", resp.Status)
    
        scanner := bufio.NewScanner(resp.Body)
        for i := 0; scanner.Scan() && i < 5; i++ {
            fmt.Println(scanner.Text())
        }
    
        if err := scanner.Err(); err != nil {
            panic(err)
        }
    }
    

![image-20230505161903254](https://img-blog.csdnimg.cn/img_convert/843db0411f1d8644986bc140994c18bc.png)

*   ä½œä¸ºæœåŠ¡ç«¯ç›‘å¬HTTPè¯·æ±‚

    package main
    
    import (
        "fmt"
        "net/http"
    )
    
    func hello(w http.ResponseWriter, req *http.Request) {
    
        fmt.Fprintf(w, "hello\n")
    }
    
    func headers(w http.ResponseWriter, req *http.Request) {
    
        for name, headers := range req.Header {
            for _, h := range headers {
                fmt.Fprintf(w, "%v: %v\n", name, h)
            }
        }
    }
    
    func main() {
    
        http.HandleFunc("/hello", hello)
        http.HandleFunc("/headers", headers)
    
        http.ListenAndServe(":8090", nil)
    }
    

è®¿é—®æµ‹è¯•é¡µé¢:[http://localhost:8090/helloå’Œhttp://localhost:8090/headers](http://localhost:8090/hello%E5%92%8Chttp://localhost:8090/headers)

![image-20230505162247985](https://img-blog.csdnimg.cn/img_convert/7c778ff47cbda1bf6b6c1684aa750d8f.png)

åŠ å¯†
--

cryptoæ˜¯goçš„åŠ å¯†åº“ï¼ŒåŒ…å«äº†å¸¸ç”¨çš„å„ç§å¯†ç ç®—æ³•ï¼ŒAESï¼ŒDESï¼ŒCipherï¼ŒDSAï¼Œecdsaï¼Œellipticï¼ŒHMACï¼ŒMD5ï¼Œç‰¹åˆ«ç”¨äºåŠ å¯†çš„éšæœºæ•°ç”Ÿæˆå™¨randï¼ŒRC4ï¼ŒRSAï¼ŒSHA1ï¼ŒSHA256ï¼ŒSHA384ï¼ŒSHA512ï¼Œtls1.2ï¼Œtls1.3ï¼ŒX.509ï¼›å¦‚SHA256å“ˆå¸Œç»å¸¸ç”¨äºè®¡ç®—äºŒè¿›åˆ¶æˆ–æ–‡æœ¬blobçš„çŸ­èº«ä»½ï¼ŒTLS/SSLè¯ä¹¦å¸¸ä½¿ç”¨SHA256æ¥è®¡ç®—è¯ä¹¦çš„ç­¾åï¼›md5ç®—æ³•å±äºhashç®—æ³•çš„ä¸€ç§ã€‚

    package main
    
    import (
    	"crypto/md5"
    	"crypto/sha256"
    	"encoding/hex"
    	"fmt"
    )
    
    func main() {
    	s := "sha256 this string"
    
    	h := sha256.New()
    
    	h.Write([]byte(s))
    
    	bs := h.Sum(nil)
    
    	fmt.Println(s)
    	fmt.Printf("%x\n", bs)
    
    	has := md5.New()
    	has.Write([]byte("abc123"))
    	b := has.Sum(nil)
    	fmt.Println(b)
    	fmt.Println(hex.EncodeToString(b))
    	fmt.Printf("%x", b)
    
    	c := md5.Sum([]byte("abc123"))
    	fmt.Printf("%x", c)
    }
    

![image-20230505152229802](https://img-blog.csdnimg.cn/img_convert/ffc0cc7e39d511cadda9358ac20b6808.png)

IOæ“ä½œ
----

ioåŒ…æä¾›äº†å¯¹I/OåŸè¯­çš„åŸºæœ¬æ¥å£ã€‚è¯¥åŒ…çš„åŸºæœ¬ä»»åŠ¡æ˜¯åŒ…è£…è¿™äº›åŸè¯­å·²æœ‰çš„å®ç°ï¼ˆå¦‚osåŒ…é‡Œçš„åŸè¯­ï¼‰ï¼Œä½¿ä¹‹æˆä¸ºå…±äº«çš„å…¬å…±æ¥å£ï¼Œè¿™äº›å…¬å…±æ¥å£æŠ½è±¡å‡ºäº†æ³›ç”¨çš„å‡½æ•°å¹¶é™„åŠ äº†ä¸€äº›ç›¸å…³çš„åŸè¯­çš„æ“ä½œã€‚

### è¯»å†™æ–‡ä»¶

è¯»å†™æ–‡ä»¶åœ¨Goç¨‹åºæ˜¯å¸¸è§çš„åŠŸèƒ½ï¼ŒbufioåŒ…å®ç°äº†å¸¦ç¼“å†²åŒºçš„è¯»å†™ï¼Œæ˜¯å¯¹æ–‡ä»¶è¯»å†™çš„å°è£….å…¶ä¸­çš„è¯»å†™æ–‡ä»¶åœ¨Goç¨‹åºæ˜¯å¸¸è§çš„åŠŸèƒ½Goè¯­è¨€é‡Œä½¿ç”¨io.Readerå’Œio.Writerä¸¤ä¸ª interface æ¥æŠ½è±¡I/Oã€‚`io.Reader` æ¥å£ä»£è¡¨ä¸€ä¸ªå¯ä»¥ä»ä¸­è¯»å–å­—èŠ‚æµçš„å®ä½“ï¼Œè€Œ`io.Writer`åˆ™ä»£è¡¨ä¸€ä¸ªå¯ä»¥å‘å…¶å†™å…¥å­—èŠ‚æµçš„å®ä½“ã€‚io.Reader/Writer å¸¸ç”¨çš„å‡ ç§å®ç°ï¼š

*   net.Conn: è¡¨ç¤ºç½‘ç»œè¿æ¥ã€‚
*   os.Stdin, os.Stdout, os.Stderr: æ ‡å‡†è¾“å…¥ã€è¾“å‡ºå’Œé”™è¯¯ã€‚
*   os.File: ç½‘ç»œ,æ ‡å‡†è¾“å…¥è¾“å‡º,æ–‡ä»¶çš„æµè¯»å–ã€‚
*   strings.Reader: å­—ç¬¦ä¸²æŠ½è±¡æˆ io.Reader çš„å®ç°ã€‚
*   bytes.Reader: \[\]byteæŠ½è±¡æˆ io.Reader çš„å®ç°ã€‚
*   bytes.Buffer: \[\]byteæŠ½è±¡æˆ io.Reader å’Œ io.Writer çš„å®ç°ã€‚
*   bufio.Reader/Writer: å¸¦ç¼“å†²çš„æµè¯»å–å’Œå†™å…¥ï¼ˆæ¯”å¦‚æŒ‰è¡Œè¯»å†™ï¼‰ã€‚

    package main
    
    import (
    	"bufio"
    	"fmt"
    	"io"
    	"os"
    )
    
    func check(e error) {
    	if e != nil {
    		panic(e)
    	}
    }
    
    func main() {
    	writeDemo()
    	readDemo()
    }
    
    func writeDemo() {
    
    	d1 := []byte("hello\ngo\n")
    	err := os.WriteFile("/tmp/dat1", d1, 0644)
    	check(err)
    
    	f, err := os.Create("/tmp/dat2")
    	check(err)
    
    	defer f.Close()
    
    	d2 := []byte{115, 111, 109, 101, 10}
    	n2, err := f.Write(d2)
    	check(err)
    	fmt.Printf("wrote %d bytes\n", n2)
    
    	n3, err := f.WriteString("writes\n")
    	check(err)
    	fmt.Printf("wrote %d bytes\n", n3)
    
    	f.Sync()
    
    	w := bufio.NewWriter(f)
    	n4, err := w.WriteString("buffered\n")
    	check(err)
    	fmt.Printf("wrote %d bytes\n", n4)
    
    	w.Flush()
    
    }
    func readDemo() {
    	dat, err := os.ReadFile("/tmp/dat1")
    	check(err)
    	fmt.Print(string(dat))
    
    	f, err := os.Open("/tmp/dat1")
    	check(err)
    
    	b1 := make([]byte, 5)
    	n1, err := f.Read(b1)
    	check(err)
    	fmt.Printf("%d bytes: %s\n", n1, string(b1[:n1]))
    
    	o2, err := f.Seek(6, 0)
    	check(err)
    	b2 := make([]byte, 2)
    	n2, err := f.Read(b2)
    	check(err)
    	fmt.Printf("%d bytes @ %d: ", n2, o2)
    	fmt.Printf("%v\n", string(b2[:n2]))
    
    	o3, err := f.Seek(6, 0)
    	check(err)
    	b3 := make([]byte, 2)
    	n3, err := io.ReadAtLeast(f, b3, 2)
    	check(err)
    	fmt.Printf("%d bytes @ %d: %s\n", n3, o3, string(b3))
    
    	_, err = f.Seek(0, 0)
    	check(err)
    
    	r4 := bufio.NewReader(f)
    	b4, err := r4.Peek(5)
    	check(err)
    	fmt.Printf("5 bytes: %s\n", string(b4))
    
    	f.Close()
    }
    

![image-20230505154344078](https://img-blog.csdnimg.cn/img_convert/88a0642bf2f51a8aa7f6d3f18ba03386.png)

### ç¯å¢ƒå˜é‡

ç¯å¢ƒå˜é‡æ˜¯å‘Unixç¨‹åºä¼ é€’é…ç½®ä¿¡æ¯çš„é€šç”¨æœºåˆ¶ã€‚

    package main
    
    import (
    	"fmt"
    	"os"
    	"strings"
    )
    
    func main() {
    
    	os.Setenv("FOO", "1")
    	fmt.Println("FOO:", os.Getenv("FOO"))
    	fmt.Println("BAR:", os.Getenv("BAR"))
    
    	fmt.Println()
    	for _, e := range os.Environ() {
    		pair := strings.SplitN(e, "=", 2)
    		fmt.Println(pair[0])
    	}
    }
    

![image-20230505155532697](https://img-blog.csdnimg.cn/img_convert/90a8dab2c67ab0778a720e3f1a1f295f.png)

### å‘½ä»¤è¡Œ

*   å‘½ä»¤è¡Œå‚æ•°ï¼šç¨‹åºæ‰§è¡Œå‚æ•°åŒ–çš„å¸¸ç”¨æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œè¿è¡Œhelloã€‚Goä½¿ç”¨runå’Œhelloã€‚Goç¨‹åºçš„å‚æ•°ã€‚

    package main
    
    import (
    	"fmt"
    	"os"
    )
    
    func main() {
    
    	argsWithProg := os.Args
    	argsWithoutProg := os.Args[1:]
    
    	arg := os.Args[3]
    
    	fmt.Println(argsWithProg)
    	fmt.Println(argsWithoutProg)
    	fmt.Println(arg)
    }
    

    go run demo.go a b c d
    [./demo.exe a b c d]
    [a b c d]
    c
    

*   å‘½ä»¤è¡Œæ ‡è®°ï¼šä¸ºå‘½ä»¤è¡Œç¨‹åºæŒ‡å®šé€‰é¡¹çš„å¸¸ç”¨æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œåœ¨wc -lä¸­ï¼Œ-læ˜¯å‘½ä»¤è¡Œæ ‡å¿—ã€‚

    package main
    
    import (
    	"flag"
    	"fmt"
    )
    
    func main() {
    
    	wordPtr := flag.String("word", "foo", "a string")
    
    	numbPtr := flag.Int("numb", 42, "an int")
    	forkPtr := flag.Bool("fork", false, "a bool")
    
    	var svar string
    	flag.StringVar(&svar, "svar", "bar", "a string var")
    
    	flag.Parse()
    
    	fmt.Println("word:", *wordPtr)
    	fmt.Println("numb:", *numbPtr)
    	fmt.Println("fork:", *forkPtr)
    	fmt.Println("svar:", svar)
    	fmt.Println("tail:", flag.Args())
    }
    

    go run demo.go -word=opt -numb=7 -fork -svar=flag
    word: opt
    numb: 7
    fork: true
    svar: flag
    tail: []
    

*   å‘½ä»¤è¡Œå­å‘½ä»¤ï¼šä¸€äº›å‘½ä»¤è¡Œå·¥å…·å¦‚goå·¥å…·æˆ–gitæœ‰è®¸å¤šå­å‘½ä»¤ï¼Œæ¯ä¸ªå­å‘½ä»¤éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„æ ‡å¿—ï¼›ä¾‹å¦‚go buildå’Œgo getæ˜¯goå·¥å…·çš„ä¸¤ä¸ªä¸åŒçš„å­å‘½ä»¤ï¼›flagåŒ…å…è®¸æˆ‘ä»¬è½»æ¾åœ°å®šä¹‰å…·æœ‰è‡ªå·±æ ‡å¿—çš„ç®€å•å­å‘½ä»¤ã€‚

    package main
    
    import (
        "flag"
        "fmt"
        "os"
    )
    
    func main() {
    
        fooCmd := flag.NewFlagSet("foo", flag.ExitOnError)
        fooEnable := fooCmd.Bool("enable", false, "enable")
        fooName := fooCmd.String("name", "", "name")
    
        barCmd := flag.NewFlagSet("bar", flag.ExitOnError)
        barLevel := barCmd.Int("level", 0, "level")
    
        if len(os.Args) < 2 {
            fmt.Println("expected 'foo' or 'bar' subcommands")
            os.Exit(1)
        }
    
        switch os.Args[1] {
    
        case "foo":
            fooCmd.Parse(os.Args[2:])
            fmt.Println("subcommand 'foo'")
            fmt.Println("  enable:", *fooEnable)
            fmt.Println("  name:", *fooName)
            fmt.Println("  tail:", fooCmd.Args())
        case "bar":
            barCmd.Parse(os.Args[2:])
            fmt.Println("subcommand 'bar'")
            fmt.Println("  level:", *barLevel)
            fmt.Println("  tail:", barCmd.Args())
        default:
            fmt.Println("expected 'foo' or 'bar' subcommands")
            os.Exit(1)
        }
    }
    

    go run demo.go foo -enable -name=joe a1 a2
    subcommand 'foo'
      enable: true
      name: joe
      tail: [a1 a2]
    

æ•°æ®åº“
---

åœ¨Goä¸­ä½¿ç”¨SQLæˆ–ç±»SQLæ•°æ®åº“é€šè¿‡database/sqlåŒ…ï¼Œå®ƒä¸ºé¢å‘è¡Œçš„æ•°æ®åº“æä¾›äº†ä¸€ä¸ªè½»é‡çº§æ¥å£ï¼›ä¹Ÿå³æ˜¯åœ¨`Go` çš„æ ‡å‡†åº“ä¸­æ˜¯æ²¡æœ‰æ•°æ®åº“é©±åŠ¨ï¼Œåªæä¾›äº†é©±åŠ¨æ¥å£ï¼Œä½†æœ‰å¾ˆå¤šç¬¬ä¸‰æ–¹å®ç°äº†é©±åŠ¨ï¼Œå»ºè®®é€‰æ‹© `go-sql-driver` è¿™ä¸ªå®ç°æ˜¯ç›®å‰ä½¿ç”¨æœ€å¤šçš„ï¼Œå…¶github åœ°å€æ˜¯ï¼š[https://github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)

    # å‘½ä»¤è¡Œå®‰è£…ä¸‰æ–¹åº“ 
    go get github.com/go-sql-driver/mysql
    

    package main
    
    import (
    	"database/sql"
    	_ "github.com/go-sql-driver/mysql"
    	"log"
    )
    
    func main() {
    	db, err := sql.Open("mysql", "root:123456@tcp(mysqlserver:3306)/test")
    	if err != nil {
    		log.Fatal(err)
    	}
    	defer db.Close()
    
    	var (
    		id   int
    		name string
    	)
    	rows, err := db.Query("select id, name from test_data where id = ?", 1)
    	if err != nil {
    		log.Fatal(err)
    	}
    	defer rows.Close()
    	for rows.Next() {
    		err := rows.Scan(&id, &name)
    		if err != nil {
    			log.Fatal(err)
    		}
    		log.Println(id, name)
    	}
    	err = rows.Err()
    	if err != nil {
    		log.Fatal(err)
    	}
    }
    

ä¸Šé¢æ˜¯åŒ¿ååŠ è½½mysqlé©±åŠ¨çš„ï¼Œå°†å®ƒçš„åŒ…é™å®šç¬¦åˆ«åä¸º\_ï¼Œæ‰€ä»¥å®ƒå¯¼å‡ºçš„åç§°å¯¹æˆ‘ä»¬çš„ä»£ç æ˜¯ä¸å¯è§çš„ï¼›åœ¨åº•å±‚ï¼Œé©±åŠ¨ç¨‹åºå°†è‡ªå·±æ³¨å†Œä¸ºdatabase/sqlåŒ…å¯ç”¨ã€‚

![image-20230505181014653](https://img-blog.csdnimg.cn/img_convert/775f5c657c4a355261aa8ee93b42a8e7.png)

æ’åº-sort
-------

*   Goçš„sortåŒ…å®ç°äº†å¯¹å†…ç½®å’Œç”¨æˆ·å®šä¹‰ç±»å‹çš„æ’åºï¼Œå®ç°äº†åŒ…æ‹¬æ’å…¥æ’åº ã€ å †æ’åº ã€ å¿«æ’ å’Œ å½’å¹¶æ’åº4ç§æ’åºæ–¹æ³• ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æš´éœ²ç»™ç”¨æˆ·æ¥å£ã€‚sortåŒ…ä¼šæ ¹æ®æ•°æ®é€‰æ‹©æœ€ä¼˜çš„æ’åºæ–¹æ³•(å…¶å®åªä½¿ç”¨äº†3ç§ï¼Œ å½’å¹¶æ’åº é™¤å¤–)ã€‚ç”¨æˆ·éœ€è¦å®ç°ä»¥ä¸‹æ¥å£æ‰èƒ½ä½¿ç”¨sortåŒ…çš„æ’åºåŠŸèƒ½ã€‚å¯¹äºå¸¸ç”¨çš„ç±»å‹( æ•´å‹åˆ‡ç‰‡ ã€ float64åˆ‡ç‰‡ ã€ Stringåˆ‡ç‰‡ )ï¼ŒsortåŒ…æä¾›äº†å†…ç½®çš„æ¥å£å®ç°ï¼›å¦‚ç»å¸¸ç”¨åˆ°çš„ int32ã€int64ã€float32ã€bool ç±»å‹å¹¶æ²¡æœ‰ç”± sort åŒ…å®ç°ï¼Œä½¿ç”¨æ—¶ä¾ç„¶éœ€è¦å¼€å‘è€…è‡ªå·±ç¼–å†™ã€‚
    
*   é™¤äº†åŸºæœ¬ç±»å‹çš„æ’åºï¼Œä¹Ÿå¯ä»¥å¯¹ç»“æ„ä½“è¿›è¡Œæ’åºã€‚ ç»“æ„ä½“æ¯”åŸºæœ¬ç±»å‹æ›´ä¸ºå¤æ‚ï¼Œæ’åºæ—¶ä¸èƒ½åƒæ•°å€¼å’Œå­—ç¬¦ä¸²ä¸€æ ·æ‹¥æœ‰ä¸€äº›å›ºå®šçš„å•ä¸€åŸåˆ™ï¼›å¯ä»¥è‡ªå®šä¹‰æ’åºæ¥å£ï¼Œæ¯”å¦‚æƒ³è¦æŒ‰è‡ªç„¶é¡ºåºä»¥å¤–çš„æ–¹å¼å¯¹é›†åˆè¿›è¡Œæ’åº;ä¾‹å¦‚å¸Œæœ›æŒ‰å­—ç¬¦ä¸²çš„é•¿åº¦è€Œä¸æ˜¯æŒ‰å­—æ¯é¡ºåºæ’åºã€‚
    
*   Go çš„ sort åŒ…ä¸­æ‰€æœ‰çš„æ’åºç®—æ³•åœ¨æœ€åçš„æƒ…å†µä¸‹ä¼šåš n log n æ¬¡ æ¯”è¾ƒï¼Œn æ˜¯è¢«æ’åºåºåˆ—çš„é•¿åº¦ï¼Œæ‰€ä»¥æ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯ O ( n log n\*)ã€‚ å…¶å¤§å¤šæ•°çš„å‡½æ•°éƒ½æ˜¯ç”¨æ”¹è‰¯åçš„å¿«é€Ÿæ’åºç®—æ³•å®ç°çš„ã€‚
    

    package main
    
    import (
    	"fmt"
    	"sort"
    )
    
    type byLength []string
    
    func (s byLength) Len() int {
    	return len(s)
    }
    func (s byLength) Swap(i, j int) {
    	s[i], s[j] = s[j], s[i]
    }
    func (s byLength) Less(i, j int) bool {
    	return len(s[i]) < len(s[j])
    }
    
    func main() {
    
    	strs := []string{"c", "a", "b"}
    	sort.Strings(strs)
    	fmt.Println("Strings:", strs)
    
    	ints := []int{7, 2, 4}
    	sort.Ints(ints)
    	fmt.Println("Ints:   ", ints)
    
    	s := sort.IntsAreSorted(ints)
    	fmt.Println("Sorted: ", s)
    
    	fruits := []string{"peach", "banana", "kiwi"}
    	sort.Sort(byLength(fruits))
    	fmt.Println(fruits)
    }
    

![image-20230505172417244](https://img-blog.csdnimg.cn/img_convert/f974a25219fab29fd4accfacbf309c46.png)

æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•
-------

å•å…ƒæµ‹è¯•æ˜¯ç¼–å†™Goç¨‹åºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼ŒtestingåŒ…æä¾›äº†ç¼–å†™å•å…ƒæµ‹è¯•æ‰€éœ€çš„å·¥å…·ï¼Œé€šè¿‡go testå‘½ä»¤è¿è¡Œæµ‹è¯•ã€‚

    package main
    
    import (
        "fmt"
        "testing"
    )
    
    func IntMin(a, b int) int {
        if a < b {
            return a
        }
        return b
    }
    
    func TestIntMinBasic(t *testing.T) {
        ans := IntMin(2, -2)
        if ans != -2 {
            t.Errorf("IntMin(2, -2) = %d; want -2", ans)
        }
    }
    
    func TestIntMinTableDriven(t *testing.T) {
        var tests = []struct {
            a, b int
            want int
        }{
            {0, 1, 0},
            {1, 0, 0},
            {2, -2, -2},
            {0, -1, -1},
            {-1, 0, -1},
        }
    
        for _, tt := range tests {
    
            testname := fmt.Sprintf("%d,%d", tt.a, tt.b)
            t.Run(testname, func(t *testing.T) {
                ans := IntMin(tt.a, tt.b)
                if ans != tt.want {
                    t.Errorf("got %d, want %d", ans, tt.want)
                }
            })
        }
    }
    
    func BenchmarkIntMin(b *testing.B) {
        for i := 0; i < b.N; i++ {
            IntMin(1, 2)
        }
    }
    

å‘½ä»¤è¡Œæ‰§è¡Œgo test -v

![image-20230505171025194](https://img-blog.csdnimg.cn/img_convert/ec674164670749129b3d4f0914e975cf.png)

å‘½ä»¤è¡Œæ‰§è¡Œgo test -bench=.

![image-20230505171125845](https://img-blog.csdnimg.cn/img_convert/cf287416d7ed7dcbb09ce9a893799abf.png)

*   **æœ¬äººåšå®¢ç½‘ç«™**[**ITå°ç¥**](http://www.itxiaoshen.com) www.itxiaoshen.com