---
layout: post
title: "牛客题解-mixup2混乱的奶牛(状压dp)"
date: "2023-06-24T01:23:13.863Z"
---
牛客题解-mixup2混乱的奶牛(状压dp)
======================

牛客题解-mixup2混乱的奶牛(状压dp)

题解-mixup2混乱的奶牛
==============

\[原题连接\]([1026-mixup2混乱的奶牛\_2021秋季算法入门班第八章习题：动态规划2 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/25022/1026))

题目描述
----

    混乱的奶牛 [Don Piele, 2007] Farmer John的N(4 <= N <= 16)头奶牛中的每一头都有一个唯一的编号S_i (1 <= S_i <= 25,000). 奶牛为她们的编号感到骄傲, 所以每一头奶牛都把她的编号刻在一个金牌上, 并且把金牌挂在她们宽大的脖子上. 奶牛们对在挤奶的时候被排成一支”混乱”的队伍非常反感. 如果一个队伍里任意两头相邻的奶牛的编号相差超过K (1 <= K <= 3400), 它就被称为是混乱的. 比如说，当N = 6, K = 1时, 1, 3, 5, 2, 6, 4 就是一支”混乱”的队伍, 但是 1, 3, 6, 5, 2, 4 不是(因为5和6只相差1). 那么, 有多少种能够使奶牛排成”混乱”的队伍的方案呢?
    

输入描述
----

    * 第 1 行: 用空格隔开的两个整数N和K
    
    * 第 2..N+1 行: 第i+1行包含了一个用来表示第i头奶牛的编号的整数: S_i
    

输出描述
----

    第 1 行: 只有一个整数, 表示有多少种能够使奶牛排成”混乱”的队伍的方案. 答案保证是 一个在64位范围内的整数.
    

示例1
---

### 输入

    4 1
    3
    4
    2
    1
    

### 输出

    2
    

思路
--

状压dp求解

如果先想一想用`dfs`的方法怎么做这道题，那么在状压dp时，会比较容易地定义状态和写出状态转移方程

_**dfs方法**_

类似全排列的写法。每次选择一头牛，加到队列尾部。根据题目要求，选择的这头牛与它前面那头牛的编号差要大于k。有如下代码：

    int que[20];
    int ans = 0;
    bool vis[20];
    
    void dfs(int step) {
    	if (step == n + 1) {
    		ans++;
            return;
        }
        for (int i = 1; i <= n; ++i) {
            if (!vis[i] && abs(s[i] - s[step - 1]) > k) {
                vis[i] = true;
                que[step] = i;
                dfs(step + 1);
                vis[i] = false;
            }
        }
    }
    

以上是暴力的dfs写法。

_**状压dp方法**_

有了dfs方法的基础，我们也可以用同样的思路

状态定义：状态为i时，某位为1说明选中了对应的牛，为0说明没有选中。那么`dp[i][j]`表示状态为i时，选中的最后一头牛（队尾的牛）是j的情况下，有多少种方案

已知`dp[i][j]`的情况下，我们要选择下一头牛（一定从位为0的牛中选择）。假设下一头牛选择是p，那么有转移方程：

    dp[i | (1 << p)][p] += dp[i][j];
    

初始化条件：选择第一个牛，每个牛都有可能被选择作为第一个牛，对应方案数为1，代码如下：

    for (int i = 0; i < n; ++i) {
        dp[1 << i][i] = 1;
    }
    

AC代码：
-----

    #include<bits/stdc++.h>
    using namespace std;
    using i64 = long long;
    
    i64 s[20], dp[1 << 17][20];
    
    int main() {
    	ios::sync_with_stdio(false);
    	cin.tie(0);
    
    	int n, k;
    	cin >> n >> k;
    	for (int i = 0; i < n; ++i) {
    		cin >> s[i];
    		dp[1 << i][i] = 1;
    	}
    
    	for (int i = 0; i < (1 << n); ++i) {
    		for (int j = 0; j < n; ++j) {
    			if (!(i & (1 << j))) continue;
    			for (int p = 0; p < n; ++p) {
    				if (i & (1 << p)) continue;
    				if (abs(s[j] - s[p]) > k) {
    					dp[i | (1 << p)][p] += dp[i][j];
    				}
    			}
    		}
    	}
    
    	i64 ans = 0;
    	for (int i = 0; i < n; ++i) {
    		ans += dp[(1 << n) - 1][i];
    	}
    
    	cout << ans << '\n';
    
    	return 0;
    }