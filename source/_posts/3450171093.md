---
layout: post
title: "Mysql高阶自定义排序"
date: "2023-08-29T00:56:58.431Z"
---
Mysql高阶自定义排序
============

在MySQL中，可以使用ORDER BY子句来对结果集进行排序。对于自定义排序，可以使用一些特定的函数和关键字。比如：FIELD、LOCATE、INSTR、CASE WHEN等等。

**Mysql高阶自定义排序**
================

嗨，大家好，我是远码，隔三岔五给大家分享一点工作的技术总结，花费的时间不多，几分钟就行，谢谢！

Mysql对我们码农来说是在熟悉不过的日常了，就不在介绍它的基础用法了，今天我们来简单聊聊它的一个基本高阶使用。

一、**问题引入**
----------

今天看到一个小伙伴在写一个表查询排序时，整的有点焦头烂额，大致逻辑是这样的：有一个学生表(主要表字段包括，主键：id，姓名：name，阶段：stage)，其中stage的值包括(初中、高中、大学)，需要按照用户的一下需求指定排序：初中、高总、大学，如果使用系统默认的排序，始终达不到要求，那该如果实现呢？

二、**问题解决方式**
------------

咋一看，这不就是自定义排序嘛，借此机会就聊聊自定义排序的实现方式吧，大概有以下几种实现方式：

### （一）**FIELD函数实现**

FIELD()函数返回值列表中值的索引位置，语法：FIELD(value, val1, val2, val3, ...)，简单的说：改函数就是返回value在集合(val1,val2,val3，...)中对应的索引位置，结合上面的需求,是不是可以这样来使用，学生表stage值就映射函数的value,(初中、高总、大学)就映射函数的值列表集合，如果学生.stage=初中，返回值不是就是1；学生.stage=高中，返回值不是就是2；学生.stage=大学，返回值不是就是3，在对结果值排一个序，不就满足要求了嘛，话不多说上代码：

SELECT id,name,stage FROM \`user\` ORDER BY FIELD(stage,"初中","高中","大学") asc;

查询结果：搞定

![](https://img2023.cnblogs.com/blog/381957/202308/381957-20230828234821355-1105709738.png)

### （二）**LOCATE函数实现**

FIELD(substr,str,pos)函数返回字符串substr在str中第一次出现的位置，pos可空，表示开始坐标，例如：

SELECT LOCATE("初中","初中,高中,大学");--返回1
SELECT LOCATE("高中","初中,高中,大学");--返回2
SELECT LOCATE("大学","初中,高中,大学");--返回3

这不就正好满足上述需求嘛，话不多说上代码：

SELECT id,name,stage FROM \`user\` ORDER BY LOCATE(stage,"初中,高中,大学") asc;

![](https://img2023.cnblogs.com/blog/381957/202308/381957-20230828234900626-1919698143.png)

### （三）**INSTR函数实现**

INSTR(str,substr)函数返回字符串str中substr第一次出现的位置，例如：

SELECT INSTR("初中,高中,大学","初中");-- 返回1
SELECT INSTR("初中,高中,大学","高中");-- 返回2
SELECT INSTR("初中,高中,大学","大学");-- 返回3

这不就正好满足上述需求嘛，话不多说上代码：

SELECT id,name,stage FROM \`user\` ORDER BY INSTR("初中,高中,大学",stage) asc;

![](https://img2023.cnblogs.com/blog/381957/202308/381957-20230828234924024-1378945262.png)

### （四）**CASE WHEN语句实现**

CASE WHEN简单的说就是根据不同的条件将其转换为指定的值，比如：根据stage 的不同值转换为对应的数字，在对结果排序满足要求了，话不多说上代码：

SELECT id,name,stage FROM \`user\` ORDER BY

CASE stage

   WHEN "初中" THEN 1

WHEN "高中" THEN 2

WHEN "大学" THEN 3

   ELSE 4 END  asc;

![](https://img2023.cnblogs.com/blog/381957/202308/381957-20230828235004374-992745881.png)

### （五）**数据表字典实现**

数据表字典思路就是需要单独建立一个stage 的值映射对应关系表，最后通过关联查询，并对根据映射值排序，正好能够满足上述要求，话不多说上代码：

SELECT u.id,u.name,u.stage FROM \`user\` as u  

JOIN stage\_dic as sd on u.stage = sd.stage

ORDER BY sd.code asc;

![](https://img2023.cnblogs.com/blog/381957/202308/381957-20230828235059830-1891977370.png)

三、**问题总结**
----------

通过上面的5种排序，都能够解决问题引入提到的自定义排序需求。这5种排序，既有相同的应用场景，也有各自不同的应用场景，在实际使用中还需要根据实际情况选择不同的排序方式，下面对其做一个简单的总结：

1.  针对简单枚举值皆可实现，数字表字典更灵活
2.  LOCATE与INSTR最终效果一致，参数颠倒，INSTR区分大小写，LOCATE不区分大小写
3.  函数虽好，使用需要谨慎，能够在存储时就处理好数据，就不要在查询时通过函数计算来解

END  
为了更高的交流，欢迎大家关注我的公众号，扫描下面二维码即可关注，谢谢：

![](https://img2020.cnblogs.com/blog/381957/202006/381957-20200609102247158-1709176751.jpg)