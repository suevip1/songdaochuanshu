---
layout: post
title: "Linux 内存管理 pt.1"
date: "2023-04-28T01:07:52.067Z"
---
Linux 内存管理 pt.1
===============

哈喽大家好，我是咸鱼

今天我们来学习一下 Linux 操作系统核心之一：内存

跟 CPU 一样，内存也是操作系统最核心的功能之一，内存主要用来存储系统和程序的指令、数据、缓存等

关于内存的学习，我会尽量以通俗易懂的方式且分成多篇文章去讲解

那么今天在 pt.1 文章中，我们来**学习一下 Linux 中的虚拟内存、物理内存和内存映射**

Linux 内存
========

![](https://img2023.cnblogs.com/blog/2958925/202304/2958925-20230427173836278-371850911.png)

**只有内核才可以直接访问物理内存,进程是无法直接访问物理内存的**

*   **那么进程是如何访问物理内存？**
    

Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个空间是连续的，这样进程就可以很方便的访问到内存，准确来说是访问到虚拟内存

又因为这个虚拟地址空间（虚拟内存）与物理内存相关联，进程则是通过虚拟内存去访问物理内存的

 

![](https://img2023.cnblogs.com/blog/2958925/202304/2958925-20230427173845077-819086704.png)

虚拟地址空间又被分成**内核空间**和**用户空间**，进程在用户态时只能访问虚拟用户空间地址，在内核态可以访问虚拟内核空间地址

对于不同位数字长（单个 CPU 指令可以处理数据的最大长度）的处理器（32位系统、64位系统），地址空间的范围也不同

 

![](https://img2023.cnblogs.com/blog/2958925/202304/2958925-20230427173851108-1908451394.png)

由上图可以看到，32 位系统的内核空间占 1G，位于最高处；剩下的 3G 是用户空间

而 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的

虽然每个进程都有虚拟内核空间，但**每个进程的虚拟内核空间内存关联的都是相同的物理内存**，方便进程切换到内核态后去访问物理内存

![](https://img2023.cnblogs.com/blog/2958925/202304/2958925-20230427173859281-1058838600.png)

**物理地址空间是物理内存的范围，虚拟地址空间是虚拟内存的范围**，物理地址空间中的每个物理地址都是实打实地指向了具体的存储单元

虚拟地址空间中每个虚拟地址指向哪里有 3 种情况:

*   未分配，这个虚拟地址仅仅是个数字而已，没有任何指向
    
*   未缓冲，这个虚拟地址指向了磁盘的某个字节存储单元，里面存储了指令或者数据
    
*   已缓冲，这个虚拟地址指向了物理内存的某个字节存储单元，里面存储了指令或者数据。
    

*   **虚拟内存的好处：**
    

*   避免用户直接访问物理内存，防止一些破坏性操作，保护操作系统
    
*   每个进程都被分配了 4GB 的 虚拟地址空间，用户可使用比实力物理内存更大的地址空间（用的时候才分配）
    

![](https://img2023.cnblogs.com/blog/2958925/202304/2958925-20230427173916911-1331938431.png)

**那么当进程实际使用的时候，进程的虚拟内存是怎么分配到物理内存的呢？**

1.内存映射
------

并不是所有的虚拟内存都会被分配物理内存，只有那些**实际使用的虚拟内存才分配物理内存**，并且分配后的物理内存，是通过内存映射来管理的

内存映射，其实就是将**虚拟内存地址映射到物理内存地址**

为了完成内存映射，内核为每个进程都维护了一张页表，用来记录虚拟内存与物理内存的映射关系

页表实际上存储在 CPU 的内存管理单元 MMU 中。这样，正常情况下，CPU 就可以直接通过硬件，找出要访问的内存

 

![](https://img2023.cnblogs.com/blog/2958925/202304/2958925-20230427173925852-498387794.png)

这张页表里面有很多页表项，每个页表项的大小为 4KB。当进程访问的虚拟内存被分配了物理内存之后，系统就会更新页表，在页表项中添加虚拟内存与物理内存的映射关系

*   **缺页异常**
    

如果进程要访问的虚拟内存没有被分配物理内存（即在页表中找不到映射关系），就会产生一个缺页异常中断

这时候系统会进入内核空间分配物理内存、然后更新进程页表，最后再返回用户空间，恢复进程的运行

> MMU 中有一个高速缓存 TLB（（Translation Lookaside Buffer，转译后备缓冲器），TLB 访问速度要比 MMU 快得多
> 
> 通过提高 TLB 缓存使用率，可以提高 CPU 的内存访问性能 

总结
--

在 Linux 中，为了提高内存利用率和系统可靠性，同时也为了不同进程之间的内存隔离，进程不能直接访问到物理内存

Linux 为每一个进程都分配了一个虚拟内存，当进程实际使用的时候，虚拟内存才会被分配物理内存

Linux 通过内存映射的方式来实现通过虚拟内存去访问物理内存，为了完成内存映射，内核为每个进程都维护了一张页表，用来记录虚拟内存与物理内存的映射关系

如果进程要访问的虚拟内存没有被分配物理内存（即在页表中找不到映射关系），就会产生一个缺页异常中断

这时候系统会进入内核空间分配物理内存、然后更新进程页表，最后再返回用户空间，恢复进程的运行

* * *

**感谢阅读，****喜欢作者就动动小手****\[****一键三连\]**，这是我写作最大的动力