---
layout: post
title: "《数据结构》之栈和堆结构及JVM简析"
date: "2023-06-05T01:18:16.234Z"
---
《数据结构》之栈和堆结构及JVM简析
==================

导言：
===

在数据结构中，我们第一了解到了栈或堆栈，它的结构特点是什么呢？先进后出，它的特点有什么用呢？我们在哪里可以使用到栈结构，栈结构那么简单，使用这么久了为什么不用其它结构替代？

一.程序在内存中的分布
===========

作为一个程序猿，我们应该会常常跟代码打交道，那么我们所编写的程序或代码，是怎么跑起来的，操作系统怎么调用的，怎么划分的我们可以使用一个简单的图来了解一下：

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230603184520802-1168631084.png)

在图片中，把我们的内存一共分为了两个部分，一个是操作系统的内核区，另外一个就是用户区

对于操作系统： 操作系统（英语：Operating System，缩写：OS）是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。

操作系统内核要负责：程序调用，驱动调用，内存管理和分配，有兴趣可以学学操作系统，我们这里主要是看看用户内存区

用户内存区主要是用户对计算机发出的指令，计算机要做出相应的操作，用户区也是我们最大化操作计算机的地方，启动一个APP，打开网站，鼠标单击，Linux中的一次 dir指令等等，都是我们人，用户在进行操作和管理

我们写的程序或代码也是运行在用户空间上的

程序在用户空间上加载出来六个部分：

*   代码段
*   只读数据段
*   初始化数据段
*   未初始化数据段
*   heap堆
*   stack栈

代码段：就是我们写的源生的一些语言指令，在操作系统也可以叫做临界区，他在运行是不可改变的，又是纯的

只读数据段：就是我们在程序中写的一些常量，比如c或Java中使用const修饰的变量，它们是全局唯一且不可变的，包括语言本省有一些自定义的宏都是不可变的

初始化和未初始化的数据段：都是一些申请的全局变量，有些是未初始化的，有些是初始化的，在程序运行的时候就会被调用，都是数据段范围

heap堆：这就是我们的重点了，它的作用是动态申请空间的程序存放的地方，比如Java中我们new了一个对象，对象都存放在堆中的，还有c语言中malloc函数，它们所申请的东西都是存放在堆中的

stack栈：这是程序运行时被调用最频繁的了，它的结构很适合存储不长时间存在的变量，以及断点记录，每当一个函数执行完，它就会释放此次函数所产生的空间

### 补充：

我们仔细去看看图片就会发现，堆空间是向上扩张的，栈空间是向下扩张的，除了这两个空间，其它的空间都是静态资源，即在编译时分配的空间在执行的时候所需的空间还是那么大

栈空间是紧贴内核区的，因为栈在程序运行时本身就需要大量的操作，即使在内存中，把数据送到cpu或内核都是要开销的，所以为了使计算机可以快起来，栈作为操作多的结构就被选择紧贴内核

堆中存储的数据结构普遍都很大，包括对象这些操作集合，它们两者都向中间靠，会不会相遇呢？其实中间的数据区空间是很大的，绝大多数情况不会

栈中存储的都是值类型，指针也是值类型

二.JVM中的内存模型
===========

内存模型分析
------

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230603200208401-576204111.png)
--------------------------------------------------------------------------------------------

 在JVM中，

栈空间，负责的就是存放着函数调用产生的局部变量，每当一个函数被调用它所产生的内存开销都会在栈中，随着函数的结束会被销毁，但是我们知道，在函数执行的时候会有对象的创建，对象大多数情况都是存在堆空间的，

那么函数怎么执行对象呢？其实它会在栈中存放一个指针，用于指向某个对象，在栈中存在的是一个链接地址

堆空间是共有的，也就是一个线程创建出来的对象，另外一个对象可以继续调用，对空间的执行结构就比栈更加复杂，它伴随着内存清理，堆空间的对象一旦不使用了就会被jvm的GC机制给清理掉，它和C语言的free（）释放空间一样，都是对堆空间进行操作，由于栈空间会被系统接管，所以很少有对栈空间的操作

本地方法栈，其实和Java语言没什么关系，它是用于其它语言和Java兼容的，我们导入了其它语言的方法，就会被存在这里，包括C++等，jvm就是c++写出来的，它交由jvm执行而专门设置的一个栈

程序计数器，就和它的名字一样，它是用来记录程序执行到那个位置的，它的所占空间需求很小，它会对栈空间的函数开始点和结束点进行记录

方法区，它是具体的实现，也是我们自定义的一些静态方法存储的地方，与之对应还有一个元空间的东西，它和方法区的区别就是，方法区注重编写接口，而元空间注重实现这些接口，在jdk1.8以前元空间是在堆空间的一块区域，1.8以后就把它从堆空间中独立出来了

### 栈空间（线程私有）

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604095850510-254094600.png)

 我们可以看到一次函数执行中，从括号开始，就会为传进来的参数创建空间，如果函数内部有单独声明的变量，在这时候也会去申请空间

函数的计算阶段，没有额外的内存开销，如果对已有的变量进行赋值，也是在开始创建的空间上完成覆盖，这里a = 11进行赋值，其实这个a去覆盖了刚开始传进来空间开辟的a =10，所以没有额外的空间开销

当遇到调用函数的结束大括号 } 时，就会结束函数，相应的在栈空间内就会删除相应的在函数运行时开辟的空间，所以一次调用完成以后，就像最左边一样，栈内的空间就仅有主函数了

我们可以看看函数执行的结果：

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604101329656-1989428130.png)

 我们在fun函数不是把值已经改变成11了嘛，为什么主函数打印最后执行还是输出自己定义的a = 10呢？

这就是栈空间的特点，基于这个特点，我们可以很容易就实现了局部变量和全局变量，我们来细细的品一下这段代码内存的分布：

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604102831614-1862829973.png)

 从这个实例中我们可换一种思维来理解局部变量，或者说全局变量和局部变量本意上都是一样的，在栈中也具有同等地位，不同的是局部变量的特点是朝生夕死的，而全局变量在栈中活到了最后

这也是为什么静态变量，常量一般都是全局作用域，它们在程序开始的时候就已经被压到栈内了，栈的特点是先进后出，也就是说要把常量和静态资源拿出来需要把绝大部分的变量方法和参数都要拿出来，符合这种情况的就只有程序快结束的时候，主函数也到了大括号 } 

每执行完成一个函数就删除它所开辟的空间，对内存利用的效率也是很高的

### 堆空间（程序公共访问）

不同于栈空间的线程私有，所在堆中的对象都可以被任何栈中指针访问，栈结构总归是有序的，但是堆空间是无序存储的，不像栈空间有先进后出这一特点

对象在堆空间中如果内部属性为基本变量，就会是自己就是一个实体，但是如果内部属性涵盖了其它对象，它会以一个指针的形式去指向那个对象，如果对象存在，否则再去自己造一个对象指向它，很显然是为了减少对象频繁构建的大量开销

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604111213823-1367033717.png)

 我们可以看到图中，id=1是直接赋值到自己的person对象内部的，但是String类型的却是用指针指向，因为String也是一个对象，不是基本类型，对象都会以指针的形式去指向

且堆空间是公用的，也就是我们person对象执行完成以后，其它对象需要用到String对象的时候，会直接链向这两个String，而不是自己去创建

可能这些链接来自于不同的私有栈，但是都是可以的，对于堆的清理，我们就要知道jvm的GC机制了，它是专门负责清理堆中不会再使用的对象的，会使用到的对象还是一样的会继续存放再堆空间中

### 栈和堆与对象的关系

既然对象和变量是分别存在堆和栈中的，我们在函数执行的时候主要还是对栈操作，那么当栈中需要使用到对象的时候怎么办呢？

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604113137528-598712098.png)

 如图，因为栈中只存储基本类型，所以使用栈要使用对象的时候，它会用一个指针去指向堆中的对象，一般对象的大小是不确定的，每个对象有它自己的大小，所以栈中存储指针是基本类型它和int大小是一样的，对栈的管理也更进一步

值得注意的是，当栈中开辟的函数空间被清理了以后，堆中的空间不会立马被清理，可能其它的栈正在调用，或者还没有触发jvm的GC机制

这样的设定又变相的解决了堆中对象的共享问题

省流：栈空间中存储的都是值类型，指针也是值类型，而堆中存储的都是对象

三.JVM的GC机制（堆特别篇）
================

我们从jvm的内存模型中分析了，堆的中产生的对象在一个栈使用完了以后不会立即清理，而是要等到GC机制来清理，我们就来看看GC机制是怎么清理的

*   首先我们得知道什么样的情况可以清理

1.  正在使用的不能清理
2.  间接被其它对象调用的不能清理
3.  本地方法栈和方法区（元空间）的对象不能清理

除了这些情况其它都是可以清理的，这样GC机制就会启动去清理这些不在此范围内的对象

清理方案（三种）
--------

### 1.标记清理

标记清理指的是GC对堆中的对象先进行扫描，那些对象没有用了可以清理的就打上标记，然后扫描完了统一清理有标记的

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604125538045-695807102.png)

 这种方式执行起来简单，实现逻辑清楚，但是有个很明显的缺点，在删除完成后，会有内碎片，相信学过操作系统的堆内碎片一定很熟悉，尤其是程序的对象不一，会导致内碎片越来越多

### 2.标记整理

标记整理是基于标记清理实现的，它在清理完成以后会把对象的位置向前移动，使得后面可以空出来大片区域

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604132101881-2010600249.png)

 标记整理的方式，的确非常符合我们对堆空间的清理，但是它的开销很大，每次清理都伴随着大量的移动

### 3.分区复制

 分区指的是把堆空间分为两个部分，在进行清理标记的时候，把没有标记的分到另外一个半区，表示对象还在使用，然后把此半区的全部清理掉，以供它们交替工作

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604134125384-127985350.png)

 分区复制的缺点也很明显，它需要两倍的内存，开销也是非常大的

JVM中的GC机制
---------

那么在jvm中，它的对象清理机制是如何实现的呢？肯定比上面三种更合理

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604170415365-1518569946.png)

 jvm中的堆空间大致被分为了两个比较大的部分，一个是老年代，即old，一个是年轻代，即young

年轻代中装的是E区和S区，E区即Eden，想必大家都很熟悉，就是伊甸园的意思，是亚当和夏娃偷食禁果产生新生命的地方，在jvm中也是一样的每个新new出来的对象都是出生在E区的，S区对应的就是Survivor，即幸存的意思

老年代中装的是在S区存活6次都没被清理掉的对象，因为开发者认为6次都没被清理掉，说明这个对象可能会存活更久或者存活到到最后

### young区工作过程

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604162928930-414130442.png)

 我们知道了E区是装载新对象的地方，当Eden区快要装满时，触发GC的时候，就会有一次扫描标记，然后将没有标记的复制到S区中区，表示存活的对象，然后清理全部的E区和另外的一个S区，我们有两个S区其实是交替工作的，这次复制到S0区，下次必复制到S1区，

E区要满的时候就会触发youngGC因为是在young区触发 的也很好理解，每一次复制都会有一个年龄标志，当一个对象达到6岁的时候就会被复制到old区中区，表示它会存活更长或者存活到最后

我们可以看到S区比E区要小，其实在JVM的设定中S0：S1：E 是 1：1：8，也就是E区要比S区大很多，这是因为对象也满足朝生夕死的特点，每次触发GC的时候大部分的对象都会被标记清理

补充：

还有一个FullGC，指的是old区要满的时候触发的，old区要是满了，会造成程序异常终止，JVM会专门来处理FullGC，同时会顺带的触发youngGC，所以每次FullGC必youngGC，但是一般不会FullGC，因为old区很大，

FullGC的清理方式是标记整理，也就是那三种清理方法的前两种，而youngGC是复制也就是第三种清理方法，youngGC是专门为对象的朝生夕死而设计的

JVM中的垃圾收集器（了解）
--------------

由于我们的堆是有两部分构成的，老年代和年轻代，所以垃圾收集器也是分别有两种：

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604172756086-2051184876.png)

解释： 

Serial是单线程的移动复制用于young区，与之对应的就是Serial  Old 是标记整理用于old区，会发生STM

PawNew是多线程的移动复制和Serial其它都一样，而CMS则是服务器段old区使用最多的垃圾回收器他不会造成STM

parallel Scavenge 则是更注重吞吐量，在客户端使用最多的就是它，单次执行很满，但整体的效率很高，与之对应就是old区的Parallel  Old

 注：STM指的是stop-the-world，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。

由于young区的空间小，所以STW时间短，但是old区要是发生了GC，STW停顿时间很长，这也是服务器端为什么要使用CMS的原因，它不会发生STM现象，因为它采用的是标记清理，但是缺点我们也知道，会有内碎片

young区的算法都是移动复制，就不用说了，并且会发生短暂的STM，我们可以着重看看CMS，这个服务器端常用的垃圾收集器

CMS：

1.  初次标记，GCRoot对象，会发生STM
2.  并发标记，所有old区的对象
3.  从新标记，修正第二步（有可能在标记的时候又产生了废弃对象）会发生STM
4.  并发清理，标记清理

此外，G1垃圾收集器是从jdk1.9开始沿用的，它对堆的划分就不像这几种那么规律了，它提出了一个堆空间的新型划分概念，有兴趣的朋友可以去了解一下

四.拓展
====

### Java逃逸分析机制：

逃逸分析在jdk6以后是默认开启的

逃逸分析指的是它会分析对象如果是在当前函数使用完了不存，因而改为在栈上申请空间，而栈运行完就清理，所以不需要等GC，大大缓解了GC的压力

如果不是当前函数范围则不会在栈上，而是在堆上申请

### 对象的大小计算：

![](https://img2023.cnblogs.com/blog/2846424/202306/2846424-20230604190159621-1155932346.png)

 非数组对象，头部大小是固定的12字节，数组对象则多了4字节为16字节

内容会根据具体的基本类型和其它对象大小而定

如果我此对象中有两个int变量，那么对象大小就是 12+8=20，但结果会是24，因为Java为了使对象在空间上对齐，会对不满足8倍数的大小对象强制扩大，24是8的倍数所以可以，

这里就会有个小tips，那你会发现一个对象中两个int型和三个int型的对象大小是一样的

如果此对象的一个属性是对象的的话，会取决于被引用对象的基本类型和它包含的其它对象

分析：

地址：是此对象在堆中的实际位置

标记：记录了hash值，是否有锁，年龄（是否进入old区使用的）

数组长度：记录了数组的下标，这也是为什么数组对象长度为一个int的大小，它们是等字节的