---
layout: post
title: "Python_11 类的方法"
date: "2023-04-25T01:09:07.060Z"
---
Python\_11 类的方法
===============

实例方法a. 定义在类里面的普通方法(函数) b. 第一个参数必须是类实例，在方法调用的时候会自动传递，这个参数名称可以随便定义默认self c. 类内部：self.方法名称()类外部：实例.方法名称()

一、查缺补漏

1. 实例方法必须用类实例化对象()来调用，用类来调用时会执行，但是self中不是实例化类地址而是传的字符串

二、类中的方法

1. 实例方法

1. 定义在类里面的普通方法(函数)

2. 第一个参数必须是类实例，在方法调用的时候会自动传递，这个参数名称可以随便定义默认self

3. 类内部：self.方法名称()

4. 类外部：实例.方法名称()

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424220812209-281995472.png)

2. 类方法

1. 定义在类中，通过@classmethod修饰的普通方法就叫类方法

2. 第一个参数为当前类，这个参数的名称可以随便定义默认使用cls定义，但是用self调用

3. 类内部：self.方法名称()

4. 类外部：类.方法名称()  和类实例.方法名称()

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424220832400-1490608919.png)

3. 静态方法（不需要传任何参数，自己可以定义参数不用写self参数，其他和类方法一致）

1. 定义在类中，通过@staticmethod修饰的普通方法就叫静态方法

2. 默认无需传任何参数

3. 类内部：self.方法名称()

4. 类外部：类.方法名称()

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424220853002-1233697621.png)

4. 私有方法 （私有的函数体）

1. 双下划线开头的方法就叫私有方法

2. 传参无区别和普通方法一致

3. 类内部：self.\_ \_方法名()

4. 类外部：不允许访问，可以强行访问，但是最好不用

5. \_函数名,\_ \_函数名\_ \_方法和属性，就算不是私有的也不要在外部去访问，可能是开发预留之后要用到的

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424220914479-754447808.png)

5. 总结

1. 实例方法：一般要实现某些功能用实例方法，常用

2. 类方法：类没有初始化方法，也不需要初始化的时候传任何参数进来，只传self，不想去实例化类时候用

3. 静态方法：类没有初始化方法，也不需要初始化的时候传任何参数进来，不用传self，也不用去实例化类

4. 类方法和静态方法的使用一般是在需要运算出结果时但又不需要实例化类时使用

5. 私有方法：在类的内部使用，不希望被外部使用，类里面某些方法的辅助方法，用于封装

三、类的特性：继承、封装、多态   所有类统一都继承的类叫基类object，默认继承

1. 一些概念：

1. 什么继承：子类继承父类，就能直接使用父类的属性和方法(私有属性和方法除外)   继承过来之后就可以访问属性

2. 什么是封装：隐藏实现细节，只对外提供某些功能

3. 什么是多态：还没讲

2. 单继承\--自动化不用

1. 写法：class  新函数名(要继承的函数名)  

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424220938618-1786848048.png)

     2. 初始化子类：初始化之后会自动去调用初始化方法，如果子类没有初始化方法，会去父类找初始化方法去执行

子类有先用子类的，没有用父亲的

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424221013409-278995237.png)

 3. 子类调用自己的方法：子类和父类有同名的方法和属性，优先使用子类自己的方法和属性

子类没有实现某个方法，他会去父类找，找到了就执行父类的方法

查找顺序：调用时先找子类之后找父类

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424221050232-252775253.png)

  4. 子类直接调用父类的方法  super().父类方法名()     子类和父类都有但是想用父类的

查找顺序：图1先查找父类，在执行子类；图2只查找父类，父类中没有的会报错

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424221115426-276665099.png)

普通方法、初始化方法(\_\_init\_\_)有区别在多继承时，单继承无区别

父类名称().\_\_init\_\_()    多继承会导致重复支持父类的初始化方法，单继承也会调用两次

super().\_\_init()    调用父类方法推荐使用

5. 继承的使用场景

1. 拓展父类的功能在父类和子类同名方法时

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424221159123-1180805844.png)

　　　　2. 重写父类【父类和子类同名方法】 

![](https://img2023.cnblogs.com/blog/2444250/202304/2444250-20230424221225193-115681292.png)

6. 需要使用父类方法，避免重实现

7. 继承之后对父类方法的修改原则

1. 父类已经实现的功能，不要去修改父类的方法【不要做】

2. 如果需要你可以对父类方法进行功能拓展【可以做】

本文来自博客园，作者：[Alisa-sweet](https://www.cnblogs.com/Alisa-sweet/)，转载请注明原文链接：[https://www.cnblogs.com/Alisa-sweet/p/17351158.html](https://www.cnblogs.com/Alisa-sweet/p/17351158.html)