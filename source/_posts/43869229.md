---
layout: post
title: "string类型可以作为lock的锁对象吗"
date: "2023-06-24T01:23:13.831Z"
---
string类型可以作为lock的锁对象吗
=====================

lock 关键字介绍
----------

lock 关键字是用于在多线程编程中实现同步和互斥访问的关键字。它的作用是确保共享资源在任意时刻只能被一个线程访问，从而避免出现竞态条件（race condition）和数据不一致的问题。

当多个线程同时访问共享资源时，如果没有合适的同步机制，可能会导致数据损坏、结果的不确定性或其他不可预测的行为。

使用 lock 关键字可以解决这个问题。当一个线程进入 .NET lock 块时，它会获取到指定的锁对象，并且其他线程将被阻塞，直到该线程释放锁对象。

    private static object lockObject = new object();
    
    //在进入 lock 块之前，线程会尝试获取 lockObject 的锁，如果锁可用，则进入代码块执行操作；如果锁不可用（已被其他线程持有），则线程将被阻塞，直到锁被释放。
    lock (lockObject)
    {
    }
    

* * *

lock 语句的正文中引发异常，也会释放 lock
-------------------------

    lock (x)
    {
        // Your code...
    }
    
    //等同于
    object __lockObj = x;
    bool __lockWasTaken = false;
    try
    {
        System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);
        // Your code...
    }
    finally
    {
        if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
    }
    

由于该代码使用 try-finally 语句，因此即使在 lock 语句的正文中引发异常，也会释放 lock。

* * *

lock 关键字的锁对象必须是引用类型，而不能是值类型。
----------------------------

![image](https://img2023.cnblogs.com/blog/411991/202306/411991-20230623164713407-669161874.png)

在 lock 语句的正文中不能使用 await 表达式
---------------------------

![image](https://img2023.cnblogs.com/blog/411991/202306/411991-20230623164847922-381845821.png)

lock 锁定对象实例，通常使用引用对象
--------------------

在 C# 中，引用类型包括类、接口、委托等。引用类型具有一个重要的特性，即它们在内存中具有唯一的地址。因此，能够使用引用类型作为锁对象，让多个线程通过共享同一个引用来实现同步。

当多个线程尝试进入 lock 代码块时，它们需要获取锁对象的控制权。如果使用值类型作为锁对象，每个线程都会创建并持有自己的锁对象实例，导致无法达到互斥的目的。因为值类型是每个实例独立存在的，它们在内存中具有不同的地址，这样就无法确保多个线程之间共享同一个锁对象。

使用引用类型作为锁对象可以解决这个问题。多个线程可以通过使用相同的引用对象来获取锁的控制权，并且只有一个线程能够成功获取锁，其他线程将被阻塞。这样，就实现了所谓的互斥访问，确保了线程安全。

string类型也是引用类型，为什么不推荐
---------------------

在 .NET Framework 中，由于字符串类型的特殊性，编译器对字符串进行了一种优化，即字符串的常量值会被缓存并重用。这意味着多个字符串变量引用相同的字符串常量时，它们实际上引用的是同一个内存位置，或者说字符串常量是“暂留”的。

由于字符串常量的“暂留”特性，如果将字符串作为锁对象，可能会导致意外的行为和不正确的同步。因为其他部分的代码也可能引用相同的字符串常量，并且在不同的上下文中使用该字符串作为锁对象，这可能导致无法预测的竞争条件。