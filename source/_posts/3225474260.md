---
layout: post
title: "binfmt_misc"
date: "2023-06-15T01:13:51.295Z"
---
binfmt\_misc
============

一：binfmt\_misc是什么
=================

　　binfmt\_misc是内核中的一个功能，它能将非本机的二进制文件与特定的解析器自动匹配起来，进行二进制解析。

       例如，在x86上解析arm64架构的二进制。

       通过binfmt\_misc可以注册解析器来处理指定二进制文件格式的请求。这些解析器可以是本地可执行文件，也可以是跨平台（ARM、MIPS）可执行文件。

二：怎么使用binfmt\_misc
==================

2.1.注册解析器　
----------

　　注册解析器的目的是为了让Linux在执行特定格式的二进制时，能够识别并自动选择相应的解析器来处理。

1.挂载

　　首先需要挂载 binfmt\_misc，并使用\`mount\`命令将\`binfmt\_misc\`文件挂载到/proc/sys/fs/binfmt\_misc/。

mount binfmt\_misc -t binfmt\_misc /proc/sys/fs/binfmt\_misc

2.创建解析器配置文件

      在 `/proc/sys/fs/binfmt_misc/` 目录下，可以创建一个配置文件，命名为 register，其中 register是要注册的二进制文件格式的标识符。

3.注册

　　在解释器配置文件中，可以使用 `echo` 命令将相应的配置信息写入。这些配置信息指定了二进制文件格式的特征、解释器的路径以及其他相关参数。例如，对于 Windows 可执行文件的解释器配置，可以指定其魔术数字、解释器的路径等。

　　使用\`echo\`命令向\``/proc/sys/fs/binfmt_misc/` \`目录中的特定文件写入配置信息，以注册特定的二进制文件格式和解释器。

     注册格式：:name:type:offset:magic:mask:interpreter:flags

#/usr/bin/qemu-arm64为解析器程序的路径  
#magic为\\x7fELF\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28\\x00  
#mask为\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff

echo ':arm:M::\\x7fELF\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28\\x00:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff:/usr/bin/qemu-arm64-static:' > register

以下是这些字段的含义：

*   `name：`是一个标识符字符串。_指定解析器的名称或标识。在这个例子中，解析器的名称为"arm"；_`   `
    
*   `type：`是识别类型。给予`M`魔法和`E`扩展。
    
*   `offset：`是文件中 magic/mask 的偏移量，以字节计算。默认为 0 `:name:type::magic...`。使用文件扩展名匹配时忽略。
    
*   `magic：`是 binfmt\_misc 匹配的字节序列。魔术字符串可能包含十六进制编码的字符，
    
*   `mask：`是一个（可选，默认为所有 0xff）掩码。  
    
*   `interpreter：`是应该使用二进制文件作为第一个参数调用的程序（指定完整路径）
    
*   `flags：`_这些标志控制解析器的行为和操作方式。下面是一些常见的 flags 标志及其作用：_
    
    _O：覆盖（Override）标志。当多个解析器的匹配规则冲突时，使用具有此标志的解析器进行匹配和执行。_
    
    _E：可执行文件标志。指定解析器用于执行可执行文件的功能。_
    
    _F：开启自动刷新标志。当启用此标志时，每次访问 register 文件时都会重新加载解析器配置。_
    
    _C：关闭自动刷新标志。当关闭此标志时，解析器配置只在系统启动时加载一次，之后不会自动刷新。_
    
    _B：启用解析器的特权执行。这将允许使用具有特权的解析器执行文件。_
    
    _M：启用魔数验证标志。指定解析器在匹配时必须验证魔数。_
    
    注意事项：offset+size(magic) 必须小于 128，解释器字符串不得超过 127 个字符
    

2.2.解析器是如何自动匹配
--------------

　　在Linux中，内核通过魔术数字（Magic Nmuber）来识别特定的二进制文件格式。

　　具体的识别过程如下：

1.  内核读取二进制文件的开头部分的字节序列，通常是文件的前几个字节。
    
2.  内核将读取到的字节序列与已注册解释器的魔术数字进行比对。
    
3.  如果找到与魔术数字匹配的解释器，则选择该解释器来处理该二进制文件。
    
4.  如果没有找到匹配的解释器，内核将无法执行该二进制文件，并可能会返回错误。
    

2.3.怎么获取二进制的魔法数字
----------------

　　在 Linux 终端中，可以使用 hexdump -C <binary\_file>或xxd <binary\_file>等命令行工具来查看二进制文件的内容。这些工具会显示文件的十六进制表示，并可以帮助你找到文件开头部分的魔数。

      案例如下：

　　![](https://img2023.cnblogs.com/blog/1024482/202306/1024482-20230614200218188-267247789.png)

2.4.子网掩码的作用
-----------

　　除了magic还有一个mask这个怎么理解？

　　mask的作用是屏蔽或过滤魔数中的某些位，将魔数与掩码进行与运算，如果不想匹配魔数某些位，则再mask中将对应位设置为0即可。

　　掩码的主要目的是允许对魔数进行更灵活的匹配。有时候，二进制文件的魔数中的某些位是可变的或不重要的，但其他位则必须匹配。通过定义一个掩码来屏蔽那些不重要的位，可以提高匹配的灵活性。

2.5.魔数和掩码的与运算
-------------

与运算规则如下：

*   如果魔数和掩码的对应位都为1，结果位为1。
*   如果魔数和掩码的对应位有一个为0，结果位为0。

　　如果你想要通过按位与运算得到0表示不匹配，可以将掩码中需要匹配的位设置为1，不需要匹配的位设置为0。这样，在按位与运算时，如果魔数的对应位与掩码的对应位都为1，结果位为1，否则为0。如果按位与运算的结果为0，表示魔数与掩码不匹配。

　　**示例1**：最终的按位与运算结果与原始的魔数值相同，即没有发生变化。

　　![](https://img2023.cnblogs.com/blog/1024482/202306/1024482-20230614202227983-1250528927.png)

 　　**示例2**：最终的按位与运算结果后6位全部为0，则后6位不进行比较

　　![](https://img2023.cnblogs.com/blog/1024482/202306/1024482-20230614202456656-2057168524.png)

2.6.与运算结果与注册表中魔数对比
------------------

**1.取注册表魔数**

　　使用 `cat` 命令读取 `/proc/sys/fs/binfmt_misc/` 目录下的相关文件。每个注册表都以文件的形式存在该目录中，文件名代表了对应的架构。例如，`/proc/sys/fs/binfmt_misc/arm_64，`表示 ARM 架构的注册表。

     ![](https://img2023.cnblogs.com/blog/1024482/202306/1024482-20230614204516777-543779754.png)

**2.对比**

 　　案例1：如下图，因为与运算结果与注册表魔数相同，则可以调用到对应注册表中interpreter对应的解析器文件。

　　![](https://img2023.cnblogs.com/blog/1024482/202306/1024482-20230614204438549-872259574.png)

 　　案例2：如下图，与运算结果的非0位与注册表魔数结果相同， 则可以调用到对应注册表中interpreter对应的解析器文件。

　　![](https://img2023.cnblogs.com/blog/1024482/202306/1024482-20230614204714299-840265570.png)