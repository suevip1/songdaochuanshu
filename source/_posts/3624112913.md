---
layout: post
title: "Linux中重定向应注意的事情"
date: "2023-05-09T01:08:19.859Z"
---
Linux中重定向应注意的事情
===============

你是否见过\`bash ... 2>&1 1>file.txt\`的写法? 还没发现这样的写法有什么问题? 那么恭喜你, 看完本文你又将学会一个新知识!

引言
==

你是否见过`bash ... 2>&1 1>file.txt`的写法? 还没发现这样的写法有什么问题? 那么恭喜你, 看完本文你又将学会一个新知识!

重定向的错误用法
========

以引言中命令为例, `2>&1`表示将错误输出重定向到标准输出, `1>file.txt`表示将标准输出重定向到`file.txt`文件, 看起来的意思就是将标准输出和错误输出全都重定向到`file.txt`?

错啦! 上述命令只会标准输出重定向到`file.txt`文件, 而错误输出还是重定向到终端(或者叫做命令行, 控制台, 屏幕). 因为首先解析的是`2>&1`,此时的`1`指向的还是标准输出, 即终端, 解析到`1>file.txt`时, 标准输出才被重定向到`file.txt`. 下面我将用一个例子来验证我的结论:

`test.sh`是一个简单的脚本, 会把`STDOUT`输出到标准输出, 将`STDERR`输出到错误输出

    $ cat test.sh
    echo 'STDOUT' >&1
    echo 'STDERR' >&2
    

我们先验证脚本的正确性, 标准输出和错误输出都被正确的捕捉到了, 脚本可以同时输出标准输出和错误输出, 正确性得以验证.  
![](https://img2023.cnblogs.com/blog/2168641/202305/2168641-20230508233518937-1318749587.png)

现在我们再来验证我一开始的结论, 执行`bash ... 2>&1 1>file.txt`形式的命令, 可以看到错误输出`STDERR`被输出到了终端, 而`file.txt`中仅有标准输出`STDOUT`  
![](https://img2023.cnblogs.com/blog/2168641/202305/2168641-20230508233726662-268182639.png)

那么应该怎么改成我们想要的结果呢? 很简单, 将`2>&1`和1>file.txt调换个位置即可, 即`bash ... 1>file.txt 2>&1`; 或者使用`bash ... &>file.txt`, 都可以达到我们想要的效果  
![](https://img2023.cnblogs.com/blog/2168641/202305/2168641-20230508233901796-1387776674.png)

![](https://img2023.cnblogs.com/blog/2168641/202305/2168641-20230508233936838-350436051.png)

重定向另外一个值得注意的事项
==============

重定向另外一个需要注意的事项就是: 执行类似于`command > file.txt`的命令时, **会首先判断`file.txt`是否存在, 若存在则先清空文件, 若不存在则创建文件, 随后才会执行`command`**

假设有一个**已经排好序**的文件`file.txt`, 我们对这个文件去重的话, 执行`uniq file.txt > file.txt`会直接清空文件  
![](https://img2023.cnblogs.com/blog/2168641/202305/2168641-20230508233032635-1619258662.png)

想要不生成额外的临时文件做到去重的话, 正确的做法应该是使用管道`|`配合`tee`命令, 而不是使用重定向  
![](https://img2023.cnblogs.com/blog/2168641/202305/2168641-20230508234421383-720301780.png)