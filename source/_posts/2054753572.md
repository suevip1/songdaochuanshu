---
layout: post
title: "重新实现hashCode()方法"
date: "2023-04-23T01:13:03.088Z"
---
重新实现hashCode()方法
================

在Java中，为了让对象在集合中能够更高效地进行查找和比较，我们通常需要重写对象的`equals()`和`hashCode()`方法。其中，`equals()`方法用于比较两个对象是否相等，而`hashCode()`方法则用于返回对象哈希值，供集合类使用。

默认情况下，Java会根据每个对象的内存地址来计算哈希值，因此如果两个对象在内存中的位置不同，它们的哈希值也会不同。但是，在实际开发中，我们可能需要比较的是对象的属性值而不是内存地址，这时就需要自己来实现`hashCode()`方法了。

为什么需要重新实现hashCode()方法
---------------------

虽然默认实现的`hashCode()`方法可以满足基本的哈希表需求，但是它有一个很大的问题：它只是返回对象的内存地址的哈希码，这意味着两个内容完全相同的对象在哈希表中还是会被认为是不同的对象，这样就会浪费大量的空间和时间。例如：

    String s1 = new String("hello");
    String s2 = new String("hello");
    System.out.println(s1.hashCode()); // 输出 99162322
    System.out.println(s2.hashCode()); // 输出 99162322
    

虽然`s1`和`s2`的内容相同，但是它们在内存中的地址不同，因此它们的哈希值也不同。

在实际使用中，这可能会导致一些问题，比如无法正确识别集合中的重复元素。

但是一些标准Java类库中的类（例如`String`、`Integer`等）已经重写了`hashCode()`方法，以便让具有相同属性值的对象具有相同的哈希码。

所以上面代码结果会显示哈希值相同。

如何重新实现hashCode()方法
------------------

要重新实现`hashCode()`方法，我们需要结合对象的属性值来计算哈希码，以便让具有相同属性值的对象具有相同的哈希码。一般来说，可以采用以下步骤：

1.  把对象的非零属性用一个质数（比如31）进行加权，并把它们相加。
2.  如果属性是布尔型，则使用`(f ? 1 : 0)` 的形式转换成数值型。
3.  如果属性是浮点型，则使用`Float.floatToIntBits(f)`的方式把它们转换成整型。
4.  如果属性是双精度型，则使用`Double.doubleToLongBits(f)`的方式把它们转换成长整型，并对其进行异或操作。
5.  如果属性是数组，则对每个元素进行递归处理。

例如，在一个自定义的`Person`类中，如果我们想让两个对象在`name`和`age`属性都相同的情况下返回相同的哈希码，可以按照以下方式重新实现`hashCode()`方法：

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + name.hashCode();
        result = 31 * result + age;
        return result;
    }
    

其中，`17`和`31`都是选定的质数。

![](https://img2023.cnblogs.com/blog/2938721/202304/2938721-20230422223721819-166074877.gif)

注意事项
----

在重新实现`hashCode()`方法时，需要牢记以下几点：

1.  哈希码的计算方式应该尽量均匀分布，这样可以提高哈希表的性能。
2.  如果两个对象的`equals()`方法返回`true`，那么它们的哈希码应该相同。
3.  如果对象的属性值发生变化，那么它的哈希码也应该随之变化。
4.  哈希码的计算过程中，应该避免使用可能会发生溢出的操作。
5.  建议使用自动生成的`hashCode()`方法，例如Eclipse和IntelliJ IDEA都支持自动生成`hashCode()`和`equals()`方法的功能。

总结
--

重新实现`hashCode()`方法可以提高哈希表的效率，使得具有相同属性值的对象具有相同的哈希码。要实现`hashCode()`方法，需要按照一定的步骤进行计算，并考虑到一些细节问题。在实际开发中，建议使用自动生成的`hashCode()`方法。